<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ros-z Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Native Rust ROS 2 implementation using Zenoh">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="mdbook-admonish.css">
        <link rel="stylesheet" href="book/mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ros-z Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ZettaScaleLabs/ros-z" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>ros-z is a native Rust ROS 2 implementation powered by Zenoh, delivering high-performance robotics communication with type safety and zero-cost abstractions.</strong> Build reliable robot applications using modern Rust idioms while maintaining full ROS 2 compatibility.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>ros-z provides three integration paths to suit different use cases:</p>
<div style="position: relative; width: 100%; height: 700px; margin: 20px 0; overflow: hidden;">
    <iframe src="architecture.html" style="width: 1600px; height: 1000px; border: none; transform: scale(0.75); transform-origin: top left;" title="Interactive ros-z Architecture" scrolling="no"></iframe>
</div>
<h2 id="why-choose-ros-z"><a class="header" href="#why-choose-ros-z">Why Choose ros-z?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Native Rust</strong></td><td>Pure Rust implementation with no C/C++ dependencies</td><td>Memory safety, concurrency without data races</td></tr>
<tr><td><strong>Zenoh Transport</strong></td><td>High-performance pub-sub engine</td><td>Low latency, efficient bandwidth usage</td></tr>
<tr><td><strong>ROS 2 Compatible</strong></td><td>Works seamlessly with standard ROS 2 tools</td><td>Integrate with existing robotics ecosystems</td></tr>
<tr><td><strong>Flexible Key Expression Formats</strong></td><td>Compatible with rmw_zenoh_cpp and zenoh-bridge-ros2dds</td><td>Interoperate with different Zenoh-ROS bridges</td></tr>
<tr><td><strong>Multiple Serializations</strong></td><td>Support for various data representations: CDR (ROS default), Protobuf</td><td>Flexible message encoding for different performance and interoperability needs</td></tr>
<tr><td><strong>Type Safety</strong></td><td>Compile-time message validation</td><td>Catch errors before deployment</td></tr>
<tr><td><strong>Modern API</strong></td><td>Idiomatic Rust patterns</td><td>Ergonomic developer experience</td></tr>
<tr><td><strong>Safety First</strong></td><td>Ownership model prevents common bugs</td><td>No data races, null pointers, or buffer overflows at compile time</td></tr>
<tr><td><strong>High Productivity</strong></td><td>Cargo ecosystem with excellent tooling</td><td>Fast development without sacrificing reliability</td></tr>
</tbody></table>
</div><div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="introduction.html#admonition-note"></a>
</div>
<div>
<p>ros-z is designed for both new projects and gradual migration. Deploy ros-z nodes alongside existing ROS 2 C++/Python nodes with full interoperability.</p>
</div>
</div>
<h2 id="communication-patterns"><a class="header" href="#communication-patterns">Communication Patterns</a></h2>
<p>ros-z supports all essential ROS 2 communication patterns:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Use Case</th><th>Learn More</th></tr></thead><tbody>
<tr><td><strong>Pub/Sub</strong></td><td>Continuous data streaming, sensor data, status updates</td><td><a href="./chapters/pubsub.html">Pub/Sub</a></td></tr>
<tr><td><strong>Services</strong></td><td>Request-response operations, remote procedure calls</td><td><a href="./chapters/services.html">Services</a></td></tr>
<tr><td><strong>Actions</strong></td><td>Long-running tasks with feedback and cancellation support</td><td><a href="./chapters/actions.html">Actions</a></td></tr>
</tbody></table>
</div><div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="introduction.html#admonition-tip"></a>
</div>
<div>
<p>Start with pub/sub for data streaming, use services for request-response operations, and leverage actions for long-running tasks that need progress feedback.</p>
</div>
</div>
<h2 id="ergonomic-api-design"><a class="header" href="#ergonomic-api-design">Ergonomic API Design</a></h2>
<p>ros-z provides flexible, idiomatic Rust APIs that adapt to your preferred programming style:</p>
<p><strong>Flexible Builder Pattern:</strong></p>
<pre><code class="language-rust ignore">let pub = node.create_pub::&lt;Vector3&gt;("vector")
    // Quality of Service settings
    .with_qos(QosProfile {
        reliability: QosReliability::Reliable,
        ..Default::default()
    })
    // custom serialization
    .with_serdes::&lt;ProtobufSerdes&lt;Vector3&gt;&gt;()
    .build()?;</code></pre>
<p><strong>Async &amp; Sync Patterns:</strong></p>
<pre><code class="language-rust ignore">// Publishers: sync and async variants
zpub.publish(&amp;msg)?;
zpub.async_publish(&amp;msg).await?;

// Subscribers: sync and async receiving
let msg = zsub.recv()?;
let msg = zsub.async_recv().await?;</code></pre>
<p><strong>Callback or Polling Style for Subscribers:</strong></p>
<pre><code class="language-rust ignore">// Callback style - process messages with a closure
let sub = node.create_sub::&lt;RosString&gt;("topic")
    .build_with_callback(|msg| {
        println!("Received: {}", msg);
    })?;

// Polling style - receive messages on demand
let sub = node.create_sub::&lt;RosString&gt;("topic").build()?;
while let Ok(msg) = sub.recv() {
    println!("Received: {}", msg);
}</code></pre>
<h2 id="next-step"><a class="header" href="#next-step">Next Step</a></h2>
<p><strong>Ready to build safer, faster robotics applications? Start with the <a href="./chapters/quick_start.html">Quick Start Guide</a>.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p><strong>Get ros-z running in under 5 minutes with this hands-on tutorial.</strong> Build a complete publisher-subscriber system to understand the core concepts through working code.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-tip"></a>
</div>
<div>
<p>This guide assumes basic Rust knowledge. If you're new to Rust, complete the <a href="https://doc.rust-lang.org/book/">Rust Book</a> first for the best experience.</p>
</div>
</div>
<h2 id="choose-your-path"><a class="header" href="#choose-your-path">Choose Your Path</a></h2>
<p>There are two ways to get started with ros-z:</p>
<ol>
<li><strong><a href="chapters/quick_start.html#option-1-try-the-examples">Try the Examples</a></strong> - Clone the ros-z repository and run pre-built examples (fastest way to see it in action)</li>
<li><strong><a href="chapters/quick_start.html#option-2-create-your-own-project">Create Your Own Project</a></strong> - Start a new Rust project with ros-z as a dependency</li>
</ol>
<hr />
<h2 id="option-1-try-the-examples"><a class="header" href="#option-1-try-the-examples">Option 1: Try the Examples</a></h2>
<p>The quickest way to experience ros-z is to run the included examples from the repository.</p>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/ZettaScaleLabs/ros-z.git
cd ros-z
</code></pre>
<h3 id="start-the-zenoh-router"><a class="header" href="#start-the-zenoh-router">Start the Zenoh Router</a></h3>
<p>ros-z uses a router-based architecture (matching ROS 2's <code>rmw_zenoh</code>), so you'll need to start a Zenoh router first.</p>
<p><strong>Terminal 1 - Start the Router:</strong></p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
<h3 id="run-the-pubsub-example"><a class="header" href="#run-the-pubsub-example">Run the Pub/Sub Example</a></h3>
<p>Open two more terminals in the same <code>ros-z</code> directory:</p>
<p><strong>Terminal 2 - Start the Listener:</strong></p>
<pre><code class="language-bash">cargo run --example z_pubsub -- -r listener
</code></pre>
<p><strong>Terminal 3 - Start the Talker:</strong></p>
<pre><code class="language-bash">cargo run --example z_pubsub -- -r talker
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-success"></a>
</div>
<div>
<p>You should see the listener receiving messages published by the talker in real-time. Press Ctrl+C to stop any process.</p>
</div>
</div>
<h3 id="understanding-the-code"><a class="header" href="#understanding-the-code">Understanding the Code</a></h3>
<p>Here's the complete example you just ran:</p>
<pre><code class="language-rust ignore">use std::time::Duration;

use clap::{Parser, ValueEnum};
use ros_z::{
    Builder, Result,
    context::{ZContext, ZContextBuilder},
};
use ros_z_msgs::std_msgs::String as RosString;

/// Subscriber function that continuously receives messages from a topic
async fn run_subscriber(ctx: ZContext, topic: String) -&gt; Result&lt;()&gt; {
    // Create a ROS 2 node - the fundamental unit of computation
    // Nodes are logical groupings of publishers, subscribers, services, etc.
    let node = ctx.create_node("Sub").build()?;

    // Create a subscriber for the specified topic
    // The type parameter RosString determines what message type we'll receive
    let zsub = node.create_sub::&lt;RosString&gt;(&amp;topic).build()?;

    // Continuously receive messages asynchronously
    // This loop will block waiting for messages on the topic
    while let Ok(msg) = zsub.async_recv().await {
        println!("Hearing:&gt;&gt; {}", msg.data);
    }
    Ok(())
}

/// Publisher function that continuously publishes messages to a topic
async fn run_publisher(
    ctx: ZContext,
    topic: String,
    period: Duration,
    payload: String,
) -&gt; Result&lt;()&gt; {
    // Create a ROS 2 node for publishing
    let node = ctx.create_node("Pub").build()?;

    // Create a publisher for the specified topic
    // The type parameter RosString determines what message type we'll send
    let zpub = node.create_pub::&lt;RosString&gt;(&amp;topic).build()?;

    let mut count = 0;
    loop {
        // Create a new message with incrementing counter
        let str = RosString {
            data: format!("{payload} - #{count}"),
        };
        println!("Telling:&gt;&gt; {}", str.data);

        // Publish the message asynchronously to all subscribers on this topic
        zpub.async_publish(&amp;str).await?;

        // Wait for the specified period before publishing again
        let _ = tokio::time::sleep(period).await;
        count += 1;
    }
}

// The #[tokio::main] attribute sets up the async runtime
// ros-z requires an async runtime (Tokio is the most common choice)
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let args = Args::parse();

    // Convert backend enum to KeyExprFormat
    let format = match args.backend {
        Backend::RmwZenoh =&gt; ros_z_protocol::KeyExprFormat::RmwZenoh,
        #[cfg(feature = "ros2dds")]
        Backend::Ros2Dds =&gt; ros_z_protocol::KeyExprFormat::Ros2Dds,
    };

    // Create a ZContext - the entry point for ros-z applications
    // ZContext manages the connection to the Zenoh network and coordinates
    // communication between nodes. It can be configured with different modes:
    // - "peer" mode: nodes discover each other via multicast scouting
    // - "client" mode: nodes connect to a Zenoh router
    let ctx = if let Some(e) = args.endpoint {
        ZContextBuilder::default()
            .with_mode(args.mode)
            .with_connect_endpoints([e])
            .keyexpr_format(format)
            .build()?
    } else {
        ZContextBuilder::default()
            .with_mode(args.mode)
            .keyexpr_format(format)
            .build()?
    };

    let period = std::time::Duration::from_secs_f64(args.period);
    zenoh::init_log_from_env_or("error");

    // Run as either a publisher (talker) or subscriber (listener)
    // Both share the same ZContext but perform different roles
    match args.role.as_str() {
        "listener" =&gt; run_subscriber(ctx, args.topic).await?,
        "talker" =&gt; run_publisher(ctx, args.topic, period, args.data).await?,
        role =&gt; println!(
            "Please use \"talker\" or \"listener\" as role, {} is not supported.",
            role
        ),
    }
    Ok(())
}

#[derive(Debug, Clone, Copy, ValueEnum)]
enum Backend {
    /// RmwZenoh backend (default) - compatible with rmw_zenoh nodes
    /// Uses key expressions with domain prefix: &lt;domain_id&gt;/&lt;topic&gt;/**
    RmwZenoh,
    /// Ros2Dds backend - compatible with zenoh-bridge-ros2dds
    /// Uses key expressions without domain prefix: &lt;topic&gt;/**
    #[cfg(feature = "ros2dds")]
    Ros2Dds,
}

#[derive(Debug, Parser)]
struct Args {
    #[arg(short, long, default_value = "Hello ROS-Z")]
    data: String,
    #[arg(short, long, default_value = "/chatter")]
    topic: String,
    #[arg(short, long, default_value = "1.0")]
    period: f64,
    #[arg(short, long, default_value = "listener")]
    role: String,
    #[arg(short, long, default_value = "peer")]
    mode: String,
    #[arg(short, long)]
    endpoint: Option&lt;String&gt;,
    /// Backend selection: rmw-zenoh (default) or ros2-dds
    #[arg(short, long, value_enum, default_value = "rmw-zenoh")]
    backend: Backend,
}</code></pre>
<hr />
<h2 id="option-2-create-your-own-project"><a class="header" href="#option-2-create-your-own-project">Option 2: Create Your Own Project</a></h2>
<p>Ready to build your own ros-z application? Follow these steps to create a new project from scratch.</p>
<h3 id="1-install-the-zenoh-router"><a class="header" href="#1-install-the-zenoh-router">1. Install the Zenoh Router</a></h3>
<p>Since you won't have access to the <code>zenoh_router</code> example outside the ros-z repository, you'll need to install a Zenoh router. Here are the quickest options:</p>
<p><strong>Option A: Using cargo (if you have Rust):</strong></p>
<pre><code class="language-bash">cargo install zenohd
</code></pre>
<p><strong>Option B: Using pre-built binary (no Rust needed):</strong></p>
<p>Download the latest release for your platform from:
<strong><a href="https://github.com/eclipse-zenoh/zenoh/releases">https://github.com/eclipse-zenoh/zenoh/releases</a></strong></p>
<p>Then extract and run:</p>
<pre><code class="language-bash">unzip zenoh-*.zip
chmod +x zenohd
./zenohd
</code></pre>
<p><strong>Option C: Using Docker:</strong></p>
<pre><code class="language-bash">docker run --init --net host eclipse/zenoh:latest
</code></pre>
<p><strong>Start the router:</strong></p>
<pre><code class="language-bash">zenohd
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-tip-1"></a>
</div>
<div>
<p>For more installation options (apt, brew, Windows, etc.), see the comprehensive <a href="chapters/./networking.html#running-the-zenoh-router">Zenoh Router Installation Guide</a>.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-note"></a>
</div>
<div>
<p>Keep the router running in a separate terminal. All ros-z applications will connect to it.</p>
</div>
</div>
<h3 id="2-create-a-new-rust-project"><a class="header" href="#2-create-a-new-rust-project">2. Create a New Rust Project</a></h3>
<pre><code class="language-bash">cargo new my_ros_z_project
cd my_ros_z_project
</code></pre>
<h3 id="3-add-dependencies"><a class="header" href="#3-add-dependencies">3. Add Dependencies</a></h3>
<p>Add ros-z to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ros-z = "*"
ros-z-msgs = "*"  # Standard ROS 2 message types
tokio = { version = "1", features = ["full"] }  # Async runtime
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-note-1"></a>
</div>
<div>
<p>An async runtime is required for ros-z. This example uses Tokio, the most popular choice in the Rust ecosystem.</p>
</div>
</div>
<h3 id="4-write-your-first-application"><a class="header" href="#4-write-your-first-application">4. Write Your First Application</a></h3>
<p>Replace the contents of <code>src/main.rs</code> with this simple publisher example:</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use ros_z::{Builder, Result, context::ZContextBuilder};
use ros_z_msgs::std_msgs::String as RosString;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Initialize ros-z context (connects to router on localhost:7447)
    let ctx = ZContextBuilder::default().build()?;

    // Create a ROS 2 node
    let node = ctx.create_node("my_talker").build()?;

    // Create a publisher for the /chatter topic
    let pub_handle = node.create_pub::&lt;RosString&gt;("/chatter").build()?;

    // Publish messages every second
    let mut count = 0;
    loop {
        let msg = RosString {
            data: format!("Hello from ros-z #{}", count),
        };
        println!("Publishing: {}", msg.data);
        pub_handle.async_publish(&amp;msg).await?;

        count += 1;
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
}</code></pre>
<h3 id="5-run-your-application"><a class="header" href="#5-run-your-application">5. Run Your Application</a></h3>
<p>Make sure the Zenoh router (<code>zenohd</code>) is running in another terminal, then:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<div id="admonition-success-1" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-1-title">
<div class="admonition-title">
<div id="admonition-success-1-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-success-1"></a>
</div>
<div>
<p>You should see messages being published every second. The application will continue until you press Ctrl+C.</p>
</div>
</div>
<h3 id="6-test-with-multiple-nodes"><a class="header" href="#6-test-with-multiple-nodes">6. Test with Multiple Nodes</a></h3>
<p>Open another terminal and create a simple listener to verify communication:</p>
<p><strong>Create <code>src/bin/listener.rs</code>:</strong></p>
<pre><code class="language-rust ignore">use ros_z::{Builder, Result, context::ZContextBuilder};
use ros_z_msgs::std_msgs::String as RosString;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let ctx = ZContextBuilder::default().build()?;
    let node = ctx.create_node("my_listener").build()?;
    let sub = node.create_sub::&lt;RosString&gt;("/chatter").build()?;

    println!("Listening on /chatter...");
    while let Ok(msg) = sub.async_recv().await {
        println!("Received: {}", msg.data);
    }
    Ok(())
}</code></pre>
<p><strong>Run both:</strong></p>
<pre><code class="language-bash"># Terminal 1: Router
zenohd

# Terminal 2: Publisher
cargo run

# Terminal 3: Listener
cargo run --bin listener
</code></pre>
<hr />
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Usage</th></tr></thead><tbody>
<tr><td><strong>ZContextBuilder</strong></td><td>Initialize ros-z environment</td><td>Entry point, configure settings</td></tr>
<tr><td><strong>ZContext</strong></td><td>Manages ROS 2 connections</td><td>Create nodes from this</td></tr>
<tr><td><strong>Node</strong></td><td>Logical unit of computation</td><td>Publishers/subscribers attach here</td></tr>
<tr><td><strong>Publisher</strong></td><td>Sends messages to topics</td><td><code>node.create_pub::&lt;Type&gt;("topic")</code></td></tr>
<tr><td><strong>Subscriber</strong></td><td>Receives messages from topics</td><td><code>node.create_sub::&lt;Type&gt;("topic")</code></td></tr>
</tbody></table>
</div><div id="admonition-why-a-zenoh-router" class="admonition admonish-tip" role="note" aria-labelledby="admonition-why-a-zenoh-router-title">
<div class="admonition-title">
<div id="admonition-why-a-zenoh-router-title">
<p>Why a Zenoh router?</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-why-a-zenoh-router"></a>
</div>
<div>
<p>ros-z uses router-based discovery by default, aligning with ROS 2's official Zenoh middleware (<code>rmw_zenoh_cpp</code>). This provides:</p>
<ul>
<li><strong>Better scalability</strong> for large deployments with many nodes</li>
<li><strong>Lower network overhead</strong> compared to multicast discovery</li>
<li><strong>Production-ready</strong> architecture used in real ROS 2 systems</li>
</ul>
<p>See the <a href="chapters/./networking.html">Networking</a> chapter for customization options, including how to revert to multicast scouting mode if needed.</p>
</div>
</div>
<h2 id="whats-happening"><a class="header" href="#whats-happening">What's Happening?</a></h2>
<pre class="mermaid">sequenceDiagram
    participant T as Talker
    participant Z as Zenoh Network
    participant L as Listener

    T-&gt;&gt;Z: Publish &quot;Hello 0&quot;
    Z-&gt;&gt;L: Deliver message
    L-&gt;&gt;L: Print to console
    Note over T: Wait 1 second
    T-&gt;&gt;Z: Publish &quot;Hello 1&quot;
    Z-&gt;&gt;L: Deliver message
    L-&gt;&gt;L: Print to console
</pre>
<p>The talker publishes messages every second to the <code>/chatter</code> topic. The listener subscribes to the same topic and prints each received message. Zenoh handles the network transport transparently.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/quick_start.html#admonition-info"></a>
</div>
<div>
<p>Both nodes run independently. You can start/stop them in any order, and multiple listeners can receive from one talker simultaneously.</p>
</div>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the basics:</p>
<p><strong>Core Concepts:</strong></p>
<ul>
<li><strong><a href="chapters/./pubsub.html">Pub/Sub</a></strong> - Deep dive into pub-sub patterns and QoS</li>
<li><strong><a href="chapters/./services.html">Services</a></strong> - Request-response communication</li>
<li><strong><a href="chapters/./actions.html">Actions</a></strong> - Long-running tasks with feedback</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - How message types work</li>
<li><strong><a href="chapters/./custom_messages.html">Custom Messages</a></strong> - Define your own message types</li>
</ul>
<p><strong>Development:</strong></p>
<ul>
<li><strong><a href="chapters/./building.html">Building</a></strong> - Build configurations and dependencies</li>
<li><strong><a href="chapters/./networking.html">Networking</a></strong> - Zenoh router setup and options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishers-and-subscribers"><a class="header" href="#publishers-and-subscribers">Publishers and Subscribers</a></h1>
<p><strong>ros-z implements ROS 2's publish-subscribe pattern with type-safe, zero-copy messaging over Zenoh.</strong> This enables efficient, decoupled communication between nodes with minimal overhead.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/pubsub.html#admonition-note"></a>
</div>
<div>
<p>The pub-sub pattern forms the foundation of ROS 2 communication, allowing nodes to exchange data without direct coupling. ros-z leverages Zenoh's efficient transport layer for optimal performance.</p>
</div>
</div>
<h2 id="visual-flow"><a class="header" href="#visual-flow">Visual Flow</a></h2>
<pre class="mermaid">graph TD
    A[ZContextBuilder] --&gt;|configure| B[ZContext]
    B --&gt;|create| C[Node]
    C --&gt;|publisher| D[Publisher]
    C --&gt;|subscriber| E[Subscriber]
    D --&gt;|publish| F[Topic]
    F --&gt;|deliver| E
    E --&gt;|callback| G[Message Handler]
</pre>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Type Safety</strong></td><td>Strongly-typed messages using Rust structs</td><td>Compile-time error detection</td></tr>
<tr><td><strong>Zero-Copy</strong></td><td>Efficient message passing via Zenoh</td><td>Reduced latency and CPU usage</td></tr>
<tr><td><strong>QoS Profiles</strong></td><td>Configurable reliability, durability, history</td><td>Fine-grained delivery control</td></tr>
<tr><td><strong>Async/Blocking</strong></td><td>Dual API for both paradigms</td><td>Flexible integration patterns</td></tr>
</tbody></table>
</div>
<h2 id="publisher-example"><a class="header" href="#publisher-example">Publisher Example</a></h2>
<p>This example demonstrates publishing "Hello World" messages to a topic. The publisher sends messages periodically, showcasing the fundamental publishing pattern.</p>
<pre><code class="language-rust ignore">/// Talker node that publishes "Hello World" messages to a topic
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `topic` - The topic name to publish to
/// * `period` - Duration between messages
/// * `max_count` - Optional maximum number of messages to publish. If None, publishes indefinitely.
pub async fn run_talker(
    ctx: ZContext,
    topic: &amp;str,
    period: Duration,
    max_count: Option&lt;usize&gt;,
) -&gt; Result&lt;()&gt; {
    // Create a node named "talker"
    let node = ctx.create_node("talker").build()?;

    // Create a publisher with a custom Quality of Service profile
    let qos = QosProfile {
        history: QosHistory::KeepLast(NonZeroUsize::new(7).unwrap()),
        ..Default::default()
    };
    let publisher = node.create_pub::&lt;RosString&gt;(topic).with_qos(qos).build()?;

    let mut count = 1;

    loop {
        // Create the message
        let msg = RosString {
            data: format!("Hello World: {}", count),
        };

        // Log the message being published
        println!("Publishing: '{}'", msg.data);

        // Publish the message (non-blocking)
        publisher.async_publish(&amp;msg).await?;

        // Check if we've reached the max count
        if let Some(max) = max_count
            &amp;&amp; count &gt;= max
        {
            break;
        }

        // Wait for the next publish cycle
        tokio::time::sleep(period).await;

        count += 1;
    }

    Ok(())
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>QoS Configuration</strong>: Uses <code>KeepLast(7)</code> to buffer the last 7 messages</li>
<li><strong>Async Publishing</strong>: Non-blocking <code>async_publish()</code> for efficient I/O</li>
<li><strong>Rate Control</strong>: Uses <code>tokio::time::sleep()</code> to control publishing frequency</li>
<li><strong>Bounded Operation</strong>: Optional <code>max_count</code> for testing scenarios</li>
</ul>
<p><strong>Running the publisher:</strong></p>
<pre><code class="language-bash"># Basic usage
cargo run --example demo_nodes_talker

# Custom topic and rate
cargo run --example demo_nodes_talker -- --topic /my_topic --period 0.5

# Publish 10 messages then exit
cargo run --example demo_nodes_talker -- --max-count 10
</code></pre>
<h2 id="subscriber-example"><a class="header" href="#subscriber-example">Subscriber Example</a></h2>
<p>This example demonstrates subscribing to messages from a topic. The subscriber receives and displays messages, showing both timeout-based and async reception patterns.</p>
<pre><code class="language-rust ignore">/// Listener node that subscribes to a topic
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `topic` - The topic name to subscribe to
/// * `max_count` - Optional maximum number of messages to receive. If None, listens indefinitely.
/// * `timeout` - Optional timeout duration. If None, waits indefinitely.
///
/// # Returns
/// A vector of received messages
pub async fn run_listener(
    ctx: ZContext,
    topic: &amp;str,
    max_count: Option&lt;usize&gt;,
    timeout: Option&lt;Duration&gt;,
) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
    // Create a node named "listener"
    let node = ctx.create_node("listener").build()?;

    // Create a subscription to the "chatter" topic
    let qos = QosProfile {
        history: QosHistory::KeepLast(NonZeroUsize::new(10).unwrap()),
        ..Default::default()
    };
    let subscriber = node.create_sub::&lt;RosString&gt;(topic).with_qos(qos).build()?;

    let mut received_messages = Vec::new();
    let start = std::time::Instant::now();

    // Receive messages in a loop
    loop {
        // Check timeout
        if let Some(t) = timeout
            &amp;&amp; start.elapsed() &gt; t
        {
            break;
        }

        // Try to receive with a small timeout to allow checking other conditions
        let recv_result = if timeout.is_some() || max_count.is_some() {
            subscriber.recv_timeout(Duration::from_millis(100))
        } else {
            // If no limits, use async_recv
            subscriber.async_recv().await
        };

        match recv_result {
            Ok(msg) =&gt; {
                // Log the received message
                println!("I heard: [{}]", msg.data);
                received_messages.push(msg.data.clone());

                // Check if we've received enough messages
                if let Some(max) = max_count
                    &amp;&amp; received_messages.len() &gt;= max
                {
                    break;
                }
            }
            Err(_) =&gt; {
                // Continue if timeout on recv_timeout
                if timeout.is_some() || max_count.is_some() {
                    continue;
                } else {
                    break;
                }
            }
        }
    }

    Ok(received_messages)
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Flexible Reception</strong>: Supports timeout-based and indefinite blocking</li>
<li><strong>Testable Design</strong>: Returns received messages for verification</li>
<li><strong>Bounded Operation</strong>: Optional <code>max_count</code> and <code>timeout</code> parameters</li>
<li><strong>QoS Configuration</strong>: Uses <code>KeepLast(10)</code> for message buffering</li>
</ul>
<p><strong>Running the subscriber:</strong></p>
<pre><code class="language-bash"># Basic usage
cargo run --example demo_nodes_listener

# Custom topic
cargo run --example demo_nodes_listener -- --topic /my_topic

# Receive 5 messages then exit
cargo run --example demo_nodes_listener -- --max-count 5
</code></pre>
<h2 id="complete-pub-sub-workflow"><a class="header" href="#complete-pub-sub-workflow">Complete Pub-Sub Workflow</a></h2>
<p>To see publishers and subscribers in action together, you'll need to start a Zenoh router first:</p>
<p><strong>Terminal 1 - Start Zenoh Router:</strong></p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
<p><strong>Terminal 2 - Start Subscriber:</strong></p>
<pre><code class="language-bash">cargo run --example demo_nodes_listener
</code></pre>
<p><strong>Terminal 3 - Start Publisher:</strong></p>
<pre><code class="language-bash">cargo run --example demo_nodes_talker
</code></pre>
<script src="https://asciinema.org/a/l7L1vuoyZSYwXEGE.js" id="asciicast-l7L1vuoyZSYwXEGE" async="true"></script>
<h2 id="subscriber-patterns"><a class="header" href="#subscriber-patterns">Subscriber Patterns</a></h2>
<p>ros-z provides three patterns for receiving messages, each suited for different use cases:</p>
<h3 id="pattern-1-blocking-receive-pull-model"><a class="header" href="#pattern-1-blocking-receive-pull-model">Pattern 1: Blocking Receive (Pull Model)</a></h3>
<p>Best for: Simple sequential processing, scripting</p>
<pre><code class="language-rust ignore">let subscriber = node
    .create_sub::&lt;RosString&gt;("topic_name")
    .build()?;

while let Ok(msg) = subscriber.recv() {
    println!("Received: {}", msg.data);
}</code></pre>
<h3 id="pattern-2-async-receive-pull-model"><a class="header" href="#pattern-2-async-receive-pull-model">Pattern 2: Async Receive (Pull Model)</a></h3>
<p>Best for: Integration with async codebases, handling multiple streams</p>
<pre><code class="language-rust ignore">let subscriber = node
    .create_sub::&lt;RosString&gt;("topic_name")
    .build()?;

while let Ok(msg) = subscriber.async_recv().await {
    println!("Received: {}", msg.data);
}</code></pre>
<h3 id="pattern-3-callback-push-model"><a class="header" href="#pattern-3-callback-push-model">Pattern 3: Callback (Push Model)</a></h3>
<p>Best for: Event-driven architectures, low-latency response</p>
<pre><code class="language-rust ignore">let subscriber = node
    .create_sub::&lt;RosString&gt;("topic_name")
    .build_with_callback(|msg| {
        println!("Received: {}", msg.data);
    })?;

// No need to call recv() - callback handles messages automatically
// Your code continues while messages are processed in the background</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/pubsub.html#admonition-tip"></a>
</div>
<div>
<p>Use callbacks for low-latency event-driven processing. Use blocking/async receive when you need explicit control over when messages are processed.</p>
</div>
</div>
<h3 id="pattern-comparison"><a class="header" href="#pattern-comparison">Pattern Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Blocking Receive</th><th>Async Receive</th><th>Callback</th></tr></thead><tbody>
<tr><td><strong>Control Flow</strong></td><td>Sequential</td><td>Sequential</td><td>Event-driven</td></tr>
<tr><td><strong>Latency</strong></td><td>Medium (poll-based)</td><td>Medium (poll-based)</td><td>Low (immediate)</td></tr>
<tr><td><strong>Memory</strong></td><td>Queue size × message</td><td>Queue size × message</td><td>No queue</td></tr>
<tr><td><strong>Backpressure</strong></td><td>Built-in (queue full)</td><td>Built-in (queue full)</td><td>None (drops if slow)</td></tr>
<tr><td><strong>Use Case</strong></td><td>Simple scripts</td><td>Async applications</td><td>Real-time response</td></tr>
</tbody></table>
</div>
<h2 id="quality-of-service-qos"><a class="header" href="#quality-of-service-qos">Quality of Service (QoS)</a></h2>
<p>QoS profiles control message delivery behavior:</p>
<pre><code class="language-rust ignore">use ros_z::qos::{QosProfile, QosHistory, Reliability};

let qos = QosProfile {
    history: QosHistory::KeepLast(10),
    reliability: Reliability::Reliable,
    ..Default::default()
};

let publisher = node
    .create_pub::&lt;RosString&gt;("topic")
    .with_qos(qos)
    .build()?;</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/pubsub.html#admonition-tip-1"></a>
</div>
<div>
<p>Use <code>QosHistory::KeepLast(1)</code> for sensor data and <code>Reliability::Reliable</code> for critical commands. Match QoS profiles between publishers and subscribers for optimal message delivery.</p>
</div>
</div>
<h2 id="ros-2-interoperability"><a class="header" href="#ros-2-interoperability">ROS 2 Interoperability</a></h2>
<p>ros-z publishers and subscribers work seamlessly with ROS 2 C++ and Python nodes:</p>
<pre><code class="language-bash"># List active topics
ros2 topic list

# Echo messages from ros-z publisher
ros2 topic echo /chatter

# Publish to ros-z subscriber from ROS 2
ros2 topic pub /chatter std_msgs/msg/String "data: 'Hello from ROS 2'"

# Check topic info
ros2 topic info /chatter
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/pubsub.html#admonition-success"></a>
</div>
<div>
<p>ros-z provides full ROS 2 compatibility via Zenoh bridge or rmw_zenoh, enabling cross-language communication.</p>
</div>
</div>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./custom_messages.html">Custom Messages</a></strong> - Defining and using custom message types</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - Generating Rust types from ROS 2 messages</li>
<li><strong><a href="chapters/./quick_start.html">Quick Start</a></strong> - Getting started guide</li>
</ul>
<p><strong>Start with the examples above to understand the basic pub-sub workflow, then explore custom messages for domain-specific communication.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services"><a class="header" href="#services">Services</a></h1>
<p><strong>ros-z implements ROS 2's service pattern with type-safe request-response communication over Zenoh.</strong> This enables synchronous, point-to-point interactions between nodes using a pull-based model for full control over request processing.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/services.html#admonition-note"></a>
</div>
<div>
<p>Services provide request-response communication for operations that need immediate feedback. Unlike topics, services are bidirectional and ensure a response for each request. ros-z uses a pull model that gives you explicit control over when to process requests.</p>
</div>
</div>
<h2 id="visual-flow-1"><a class="header" href="#visual-flow-1">Visual Flow</a></h2>
<pre class="mermaid">graph TD
    A[ZContextBuilder] --&gt;|configure| B[ZContext]
    B --&gt;|create| C[Client Node]
    B --&gt;|create| D[Server Node]
    C --&gt;|create_client| E[Service Client]
    D --&gt;|create_service| F[Service Server]
    E --&gt;|send_request| G[Service Call]
    G --&gt;|route| F
    F --&gt;|take_request| H[Request Handler]
    H --&gt;|send_response| G
    G --&gt;|deliver| E
    E --&gt;|take_response| I[Response Handler]
</pre>
<h2 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Type Safety</strong></td><td>Strongly-typed service definitions with Rust structs</td><td>Compile-time error detection</td></tr>
<tr><td><strong>Pull Model</strong></td><td>Explicit control over request processing timing</td><td>Predictable concurrency and backpressure</td></tr>
<tr><td><strong>Async/Blocking</strong></td><td>Dual API for both paradigms</td><td>Flexible integration patterns</td></tr>
<tr><td><strong>Request Tracking</strong></td><td>Key-based request/response matching</td><td>Reliable message correlation</td></tr>
</tbody></table>
</div>
<h2 id="service-server-example"><a class="header" href="#service-server-example">Service Server Example</a></h2>
<p>This example demonstrates a service server that adds two integers. The server waits for requests, processes them, and sends responses back to clients.</p>
<pre><code class="language-rust ignore">/// AddTwoInts server node that provides a service to add two integers
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `max_requests` - Optional maximum number of requests to handle. If None, handles requests indefinitely.
pub fn run_add_two_ints_server(ctx: ZContext, max_requests: Option&lt;usize&gt;) -&gt; Result&lt;()&gt; {
    // Create a node named "add_two_ints_server"
    let node = ctx.create_node("add_two_ints_server").build()?;

    // Create a service that will handle requests
    let mut service = node.create_service::&lt;AddTwoInts&gt;("add_two_ints").build()?;

    println!("AddTwoInts service server started, waiting for requests...");

    let mut request_count = 0;

    loop {
        // Wait for a request
        let (key, req) = service.take_request()?;
        println!("Incoming request\na: {} b: {}", req.a, req.b);

        // Compute the sum
        let sum = req.a + req.b;

        // Create the response
        let resp = AddTwoIntsResponse { sum };

        println!("Sending response: {}", resp.sum);

        // Send the response
        service.send_response(&amp;resp, &amp;key)?;

        request_count += 1;

        // Check if we've reached the max requests
        if let Some(max) = max_requests
            &amp;&amp; request_count &gt;= max
        {
            break;
        }
    }

    Ok(())
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Pull Model</strong>: Uses <code>take_request()</code> for explicit control over when to accept requests</li>
<li><strong>Request Key</strong>: Each request has a unique key for matching responses</li>
<li><strong>Bounded Operation</strong>: Optional <code>max_requests</code> parameter for testing</li>
<li><strong>Simple Processing</strong>: Demonstrates synchronous request handling</li>
</ul>
<p><strong>Running the server:</strong></p>
<pre><code class="language-bash"># Basic usage - runs indefinitely
cargo run --example demo_nodes_add_two_ints_server

# Handle 5 requests then exit
cargo run --example demo_nodes_add_two_ints_server -- --count 5

# Connect to specific Zenoh router
cargo run --example demo_nodes_add_two_ints_server -- --endpoint tcp/localhost:7447
</code></pre>
<h2 id="service-client-example"><a class="header" href="#service-client-example">Service Client Example</a></h2>
<p>This example demonstrates a service client that sends addition requests to the server and displays the results.</p>
<pre><code class="language-rust ignore">/// AddTwoInts client node that calls the service to add two integers
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `a` - First number to add
/// * `b` - Second number to add
/// * `async_mode` - Whether to use async response waiting
pub fn run_add_two_ints_client(ctx: ZContext, a: i64, b: i64, async_mode: bool) -&gt; Result&lt;i64&gt; {
    // Create a node named "add_two_ints_client"
    let node = ctx.create_node("add_two_ints_client").build()?;

    // Create a client for the service
    let client = node.create_client::&lt;AddTwoInts&gt;("add_two_ints").build()?;

    println!(
        "AddTwoInts service client started (mode: {})",
        if async_mode { "async" } else { "sync" }
    );

    // Create the request
    let req = AddTwoIntsRequest { a, b };
    println!("Sending request: {} + {}", req.a, req.b);

    // Wait for the response
    let resp = if async_mode {
        tokio::runtime::Runtime::new().unwrap().block_on(async {
            client.send_request(&amp;req).await?;
            client.take_response_async().await
        })?
    } else {
        tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { client.send_request(&amp;req).await })?;
        client.take_response_timeout(Duration::from_secs(5))?
    };

    println!("Received response: {}", resp.sum);

    Ok(resp.sum)
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Async Support</strong>: Supports both blocking and async response patterns</li>
<li><strong>Timeout Handling</strong>: Uses <code>take_response_timeout()</code> for reliable operation</li>
<li><strong>Simple API</strong>: Send request, receive response, process result</li>
<li><strong>Type Safety</strong>: Request and response types are enforced at compile time</li>
</ul>
<p><strong>Running the client:</strong></p>
<pre><code class="language-bash"># Basic usage
cargo run --example demo_nodes_add_two_ints_client -- --a 10 --b 20

# Using async mode
cargo run --example demo_nodes_add_two_ints_client -- --a 5 --b 3 --async-mode

# Connect to specific Zenoh router
cargo run --example demo_nodes_add_two_ints_client -- --a 100 --b 200 --endpoint tcp/localhost:7447
</code></pre>
<h2 id="complete-service-workflow"><a class="header" href="#complete-service-workflow">Complete Service Workflow</a></h2>
<p>To see services in action, you'll need to start a Zenoh router first:</p>
<p><strong>Terminal 1 - Start Zenoh Router:</strong></p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
<p><strong>Terminal 2 - Start Server:</strong></p>
<pre><code class="language-bash">cargo run --example demo_nodes_add_two_ints_server
</code></pre>
<p><strong>Terminal 3 - Send Client Requests:</strong></p>
<pre><code class="language-bash"># Request 1
cargo run --example demo_nodes_add_two_ints_client -- --a 10 --b 20

# Request 2
cargo run --example demo_nodes_add_two_ints_client -- --a 100 --b 200
</code></pre>
<script src="https://asciinema.org/a/yChRkMOyYKoKBPqM.js" id="asciicast-yChRkMOyYKoKBPqM" async="true"></script>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/services.html#admonition-success"></a>
</div>
<div>
<p>Each client request is processed immediately by the server, demonstrating synchronous request-response communication over Zenoh.</p>
</div>
</div>
<h2 id="service-server-patterns"><a class="header" href="#service-server-patterns">Service Server Patterns</a></h2>
<p>Service servers in ros-z follow a <strong>pull model</strong> pattern, similar to subscribers. You explicitly receive requests when ready to process them, giving you full control over request handling timing and concurrency.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/services.html#admonition-info"></a>
</div>
<div>
<p>This pull-based approach is consistent with subscriber's <code>recv()</code> pattern, allowing you to control when work happens rather than having callbacks interrupt your flow.</p>
</div>
</div>
<h3 id="pattern-1-blocking-request-handling"><a class="header" href="#pattern-1-blocking-request-handling">Pattern 1: Blocking Request Handling</a></h3>
<p>Best for: Simple synchronous service implementations</p>
<pre><code class="language-rust ignore">let mut service = node
    .create_service::&lt;ServiceType&gt;("service_name")
    .build()?;

loop {
    let (key, request) = service.take_request()?;
    let response = process_request(&amp;request);
    service.send_response(&amp;response, &amp;key)?;
}</code></pre>
<h3 id="pattern-2-async-request-handling"><a class="header" href="#pattern-2-async-request-handling">Pattern 2: Async Request Handling</a></h3>
<p>Best for: Services that need to await other operations</p>
<pre><code class="language-rust ignore">let mut service = node
    .create_service::&lt;ServiceType&gt;("service_name")
    .build()?;

loop {
    let (key, request) = service.take_request_async().await?;
    let response = async_process_request(&amp;request).await;
    service.send_response(&amp;response, &amp;key)?;
}</code></pre>
<h3 id="why-pull-model"><a class="header" href="#why-pull-model">Why Pull Model?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Pull Model (take_request)</th><th>Push Model (callback)</th></tr></thead><tbody>
<tr><td><strong>Control</strong></td><td>Explicit control over when to accept requests</td><td>Interrupts current work</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Easy to reason about</td><td>Requires careful synchronization</td></tr>
<tr><td><strong>Backpressure</strong></td><td>Natural - slow processing slows acceptance</td><td>Can overwhelm if processing is slow</td></tr>
<tr><td><strong>Consistency</strong></td><td>Same pattern as subscriber <code>recv()</code></td><td>Different pattern</td></tr>
</tbody></table>
</div>
<h2 id="service-client-patterns"><a class="header" href="#service-client-patterns">Service Client Patterns</a></h2>
<p>Service clients send requests to servers and receive responses. Both blocking and async patterns are supported.</p>
<h3 id="pattern-1-blocking-client"><a class="header" href="#pattern-1-blocking-client">Pattern 1: Blocking Client</a></h3>
<p>Best for: Simple synchronous request-response operations</p>
<pre><code class="language-rust ignore">let client = node
    .create_client::&lt;ServiceType&gt;("service_name")
    .build()?;

let request = create_request();
client.send_request(&amp;request)?;
let response = client.take_response()?;</code></pre>
<h3 id="pattern-2-async-client"><a class="header" href="#pattern-2-async-client">Pattern 2: Async Client</a></h3>
<p>Best for: Integration with async codebases</p>
<pre><code class="language-rust ignore">let client = node
    .create_client::&lt;ServiceType&gt;("service_name")
    .build()?;

let request = create_request();
client.send_request(&amp;request).await?;
let response = client.take_response_async().await?;</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/services.html#admonition-tip"></a>
</div>
<div>
<p>Match your client and server patterns for consistency. Use blocking patterns for simple scripts and async patterns when integrating with async runtimes like tokio.</p>
</div>
</div>
<h2 id="ros-2-interoperability-1"><a class="header" href="#ros-2-interoperability-1">ROS 2 Interoperability</a></h2>
<p>ros-z services work seamlessly with ROS 2 C++ and Python nodes:</p>
<pre><code class="language-bash"># List available services
ros2 service list

# Call ros-z service from ROS 2 CLI
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 42, b: 58}"

# Show service type
ros2 service type /add_two_ints

# Get service info
ros2 service info /add_two_ints
</code></pre>
<div id="admonition-success-1" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-1-title">
<div class="admonition-title">
<div id="admonition-success-1-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/services.html#admonition-success-1"></a>
</div>
<div>
<p>ros-z service servers and clients are fully compatible with ROS 2 via Zenoh bridge or rmw_zenoh, enabling cross-language service calls.</p>
</div>
</div>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./custom_messages.html">Custom Messages</a></strong> - Defining and using custom service types</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - Generating service definitions</li>
<li><strong><a href="chapters/./actions.html">Actions</a></strong> - For long-running operations with feedback</li>
</ul>
<p><strong>Start with the examples above to understand the basic service workflow, then explore custom service types for domain-specific operations.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p><strong>Actions enable long-running tasks with progress feedback and cancellation support, perfect for operations that take seconds or minutes to complete.</strong> Unlike services that return immediately, actions provide streaming feedback while executing complex workflows.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/actions.html#admonition-tip"></a>
</div>
<div>
<p>Use actions for robot navigation, trajectory execution, or any operation where you need progress updates and the ability to cancel mid-execution. Use services for quick request-response operations.</p>
</div>
</div>
<h2 id="action-lifecycle"><a class="header" href="#action-lifecycle">Action Lifecycle</a></h2>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Idle
    Idle --&gt; Accepted: Send Goal
    Accepted --&gt; Executing: Start Processing
    Executing --&gt; Executing: Send Feedback
    Executing --&gt; Succeeded: Complete
    Executing --&gt; Canceled: Cancel Request
    Executing --&gt; Aborted: Error Occurs
    Succeeded --&gt; [*]
    Canceled --&gt; [*]
    Aborted --&gt; [*]
</pre>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Type</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Goal</strong></td><td>Input</td><td>Defines the desired outcome</td></tr>
<tr><td><strong>Feedback</strong></td><td>Stream</td><td>Progress updates during execution</td></tr>
<tr><td><strong>Result</strong></td><td>Output</td><td>Final outcome when complete</td></tr>
<tr><td><strong>Status</strong></td><td>State</td><td>Current execution state</td></tr>
</tbody></table>
</div>
<h2 id="communication-pattern"><a class="header" href="#communication-pattern">Communication Pattern</a></h2>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant S as Server

    C-&gt;&gt;S: Send Goal
    S-&gt;&gt;C: Goal Accepted
    loop During Execution
        S-&gt;&gt;C: Feedback Update
    end
    alt Success
        S-&gt;&gt;C: Result (Success)
    else Canceled
        C-&gt;&gt;S: Cancel Request
        S-&gt;&gt;C: Result (Canceled)
    else Error
        S-&gt;&gt;C: Result (Aborted)
    end
</pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p><strong>Robot Navigation:</strong></p>
<ul>
<li>Goal: Target position and orientation</li>
<li>Feedback: Current position, distance remaining, obstacles detected</li>
<li>Result: Final position, success/failure reason</li>
</ul>
<p><strong>Gripper Control:</strong></p>
<ul>
<li>Goal: Desired grip force and position</li>
<li>Feedback: Current force, contact detection</li>
<li>Result: Grip achieved, object secured</li>
</ul>
<p><strong>Long Computations:</strong></p>
<ul>
<li>Goal: Computation parameters</li>
<li>Feedback: Progress percentage, intermediate results</li>
<li>Result: Final computed value, execution time</li>
</ul>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/actions.html#admonition-info"></a>
</div>
<div>
<p>Actions excel when operations take more than a few seconds and users need visibility into progress. For sub-second operations, prefer services for simplicity.</p>
</div>
</div>
<h2 id="action-server-example"><a class="header" href="#action-server-example">Action Server Example</a></h2>
<p>This example demonstrates an action server that computes Fibonacci sequences. The server accepts goals, publishes periodic feedback with partial results, and supports cancellation.</p>
<pre><code class="language-rust ignore">/// Fibonacci action server node that computes Fibonacci sequences
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `timeout` - Optional timeout duration. If None, runs until ctrl+c.
pub async fn run_fibonacci_action_server(ctx: ZContext, timeout: Option&lt;Duration&gt;) -&gt; Result&lt;()&gt; {
    // Create a node named "fibonacci_action_server"
    let node = ctx.create_node("fibonacci_action_server").build()?;

    // Create an action server
    // Note: The server variable must be kept alive for the duration of the function
    // to ensure the action server and its background tasks remain active
    let _server = node
        .create_action_server::&lt;Fibonacci&gt;("fibonacci")
        .build()?
        .with_handler(|executing: ExecutingGoal&lt;Fibonacci&gt;| async move {
            let order = executing.goal.order;
            let mut sequence = vec![0, 1];

            println!("Executing Fibonacci goal with order {}", order);

            let mut canceled = false;
            let mut cancel_sequence = None;

            for i in 2..=order {
                // Check for cancellation
                if executing.is_cancel_requested() {
                    println!("Goal canceled!");
                    canceled = true;
                    cancel_sequence = Some(sequence.clone());
                    break;
                }

                let next = sequence[i as usize - 1] + sequence[i as usize - 2];
                sequence.push(next);

                // Publish feedback
                // Distro-specific feedback field names
                #[cfg(feature = "kilted")]
                let feedback = FibonacciFeedback {
                    sequence: sequence.clone(),
                };
                #[cfg(not(feature = "kilted"))]
                let feedback = FibonacciFeedback {
                    partial_sequence: sequence.clone(),
                };
                executing
                    .publish_feedback(feedback)
                    .expect("Failed to publish feedback");

                tokio::time::sleep(Duration::from_millis(500)).await;
            }

            if canceled {
                executing
                    .canceled(FibonacciResult {
                        sequence: cancel_sequence.unwrap(),
                    })
                    .unwrap();
            } else {
                println!("Goal succeeded!");
                executing.succeed(FibonacciResult { sequence }).unwrap();
            }
        });

    println!("Fibonacci action server started");

    if let Some(timeout) = timeout {
        // For testing: run for the specified timeout
        tokio::time::sleep(timeout).await;
    } else {
        tokio::signal::ctrl_c().await?;
    }

    Ok(())
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Handler Pattern</strong>: Uses <code>.with_handler()</code> to define asynchronous goal execution</li>
<li><strong>Feedback Publishing</strong>: Sends partial results periodically via <code>publish_feedback()</code></li>
<li><strong>Cancellation Support</strong>: Checks <code>is_cancel_requested()</code> and handles graceful cancellation</li>
<li><strong>Completion</strong>: Uses <code>.succeed()</code> or <code>.canceled()</code> to send final result</li>
</ul>
<p><strong>Running the server:</strong></p>
<pre><code class="language-bash"># Start Zenoh router first
cargo run --example zenoh_router

# Run the server (runs until Ctrl+C)
cargo run --example demo_nodes_fibonacci_action_server
</code></pre>
<h2 id="action-client-example"><a class="header" href="#action-client-example">Action Client Example</a></h2>
<p>This example demonstrates an action client that sends goals and monitors execution progress with feedback updates.</p>
<pre><code class="language-rust ignore">/// Fibonacci action client node that sends goals to compute Fibonacci sequences
///
/// # Arguments
/// * `ctx` - The ROS-Z context
/// * `order` - The order of the Fibonacci sequence to compute
pub async fn run_fibonacci_action_client(ctx: ZContext, order: i32) -&gt; Result&lt;Vec&lt;i32&gt;&gt; {
    // Create a node named "fibonacci_action_client"
    let node = ctx.create_node("fibonacci_action_client").build()?;

    // Create an action client
    let client = node
        .create_action_client::&lt;Fibonacci&gt;("fibonacci")
        .build()?;

    // Wait a bit for the server to be discovered
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

    println!(
        "Fibonacci action client started, sending goal with order {}",
        order
    );

    // Send the goal
    let mut goal_handle = client.send_goal(FibonacciGoal { order }).await?;
    println!("Goal sent and accepted!");

    // Set up feedback monitoring
    if let Some(mut feedback_stream) = goal_handle.feedback() {
        tokio::spawn(async move {
            while let Some(fb) = feedback_stream.recv().await {
                // Distro-specific feedback field names
                #[cfg(feature = "kilted")]
                println!("Feedback: {:?}", fb.sequence);
                #[cfg(not(feature = "kilted"))]
                println!("Feedback: {:?}", fb.partial_sequence);
            }
        });
    }

    // Wait for the result with timeout
    println!("Waiting for result (timeout: 10s)...");
    let result = match tokio::time::timeout(
        tokio::time::Duration::from_secs(10),
        goal_handle.result(),
    )
    .await
    {
        Ok(Ok(result)) =&gt; {
            println!("Final result: {:?}", result.sequence);
            result
        }
        Ok(Err(e)) =&gt; {
            eprintln!("Action failed: {}", e);
            return Err(e);
        }
        Err(_) =&gt; {
            eprintln!("Timeout waiting for action result");
            return Err(zenoh::Error::from("Timeout waiting for action result"));
        }
    };

    Ok(result.sequence)
}</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Goal Sending</strong>: Uses <code>send_goal()</code> to submit goals and get a handle</li>
<li><strong>Feedback Monitoring</strong>: Spawns async task to receive and display feedback</li>
<li><strong>Result Handling</strong>: Waits for completion with timeout and error handling</li>
<li><strong>Type Safety</strong>: Strongly-typed goal, feedback, and result messages</li>
</ul>
<p><strong>Running the client:</strong></p>
<pre><code class="language-bash"># Basic usage - compute Fibonacci(10)
cargo run --example demo_nodes_fibonacci_action_client

# Compute Fibonacci(15)
cargo run --example demo_nodes_fibonacci_action_client -- --order 15

# Connect to specific router
cargo run --example demo_nodes_fibonacci_action_client -- --endpoint tcp/localhost:7447
</code></pre>
<h2 id="complete-action-workflow"><a class="header" href="#complete-action-workflow">Complete Action Workflow</a></h2>
<p><strong>Terminal 1 - Start Zenoh Router:</strong></p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
<p><strong>Terminal 2 - Start Action Server:</strong></p>
<pre><code class="language-bash">cargo run --example demo_nodes_fibonacci_action_server
</code></pre>
<p><strong>Terminal 3 - Send Goals from Client:</strong></p>
<pre><code class="language-bash">cargo run --example demo_nodes_fibonacci_action_client -- --order 10
</code></pre>
<p>You'll see:</p>
<ul>
<li><strong>Client</strong>: Goal sent, feedback updates with partial sequences, final result</li>
<li><strong>Server</strong>: Goal received, executing with feedback, completion status</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/actions.html#admonition-warning"></a>
</div>
<div>
<p>Always implement timeout mechanisms for action clients. Long-running actions can fail or hang, and clients need graceful degradation strategies.</p>
</div>
</div>
<h2 id="comparison-with-other-patterns"><a class="header" href="#comparison-with-other-patterns">Comparison with Other Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Duration</th><th>Feedback</th><th>Cancellation</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Pub-Sub</strong></td><td>Continuous</td><td>No</td><td>N/A</td><td>Sensor data streaming</td></tr>
<tr><td><strong>Service</strong></td><td>&lt; 1 second</td><td>No</td><td>No</td><td>Quick queries</td></tr>
<tr><td><strong>Action</strong></td><td>Seconds to minutes</td><td>Yes</td><td>Yes</td><td>Long-running tasks</td></tr>
</tbody></table>
</div>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<ul>
<li><strong><a href="https://docs.ros.org/en/rolling/Tutorials/Intermediate/Writing-an-Action-Server-Client/Py.html">ROS 2 Actions Documentation</a></strong> - Official ROS 2 action guide</li>
<li><strong><a href="https://github.com/ZettaScaleLabs/ros-z/tree/main/ros-z/examples">ros-z Examples</a></strong> - Working action implementations</li>
<li><strong><a href="chapters/./services.html">Services</a></strong> - Simpler request-response pattern</li>
</ul>
<p><strong>Action implementation is evolving. Check the ros-z repository for the latest examples and API updates.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-ros-z"><a class="header" href="#building-ros-z">Building ros-z</a></h1>
<p><strong>ros-z is designed to work without ROS 2 dependencies by default, enabling pure Rust development while optionally integrating with existing ROS 2 installations.</strong> This flexible approach lets you choose your dependency level based on project requirements.</p>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>ros-z follows a <strong>dependency-optional</strong> design:</p>
<ul>
<li>Build pure Rust applications without ROS 2 installed</li>
<li>Use bundled message definitions for common types</li>
<li>Opt-in to ROS 2 integration when needed</li>
<li>Pay only for what you use</li>
</ul>
<h2 id="adding-ros-z-to-your-project"><a class="header" href="#adding-ros-z-to-your-project">Adding ros-z to Your Project</a></h2>
<p>Get started by adding ros-z to your <code>Cargo.toml</code>. Choose the dependency setup that matches your needs:</p>
<h3 id="scenario-1-pure-rust-with-custom-messages"><a class="header" href="#scenario-1-pure-rust-with-custom-messages">Scenario 1: Pure Rust with Custom Messages</a></h3>
<p><strong>Use when:</strong> You want to define your own message types without ROS 2 dependencies</p>
<p><strong>Add to your <code>Cargo.toml</code>:</strong></p>
<pre><code class="language-toml">[dependencies]
ros-z = "0.x"
tokio = { version = "1", features = ["full"] }  # Async runtime required
</code></pre>
<p><strong>What you get:</strong></p>
<ul>
<li>Full ros-z functionality</li>
<li>Custom message support via derive macros</li>
<li>Zero external dependencies</li>
<li>Fast build times</li>
</ul>
<h3 id="scenario-2-using-bundled-ros-messages"><a class="header" href="#scenario-2-using-bundled-ros-messages">Scenario 2: Using Bundled ROS Messages</a></h3>
<p><strong>Use when:</strong> You need standard ROS 2 message types (no ROS 2 installation required)</p>
<p><strong>Add to your <code>Cargo.toml</code>:</strong></p>
<pre><code class="language-toml">[dependencies]
ros-z = "0.x"
ros-z-msgs = "0.x"  # Includes core_msgs by default
tokio = { version = "1", features = ["full"] }
</code></pre>
<p><strong>Default message packages (core_msgs):</strong></p>
<ul>
<li><code>std_msgs</code> - Primitive types (String, Int32, Float64, etc.)</li>
<li><code>geometry_msgs</code> - Spatial data (Point, Pose, Transform, Twist)</li>
<li><code>sensor_msgs</code> - Sensor data (LaserScan, Image, Imu, PointCloud2)</li>
<li><code>nav_msgs</code> - Navigation (Path, OccupancyGrid, Odometry)</li>
<li><code>example_interfaces</code> - Tutorial services (AddTwoInts)</li>
<li><code>action_tutorials_interfaces</code> - Tutorial actions (Fibonacci)</li>
</ul>
<h3 id="scenario-3-all-message-packages"><a class="header" href="#scenario-3-all-message-packages">Scenario 3: All Message Packages</a></h3>
<p><strong>Use when:</strong> You need all available message types including test messages</p>
<p><strong>Requirements:</strong> None (all messages are vendored)</p>
<p><strong>Add to your <code>Cargo.toml</code>:</strong></p>
<pre><code class="language-toml">[dependencies]
ros-z = "0.x"
ros-z-msgs = { version = "0.x", features = ["all_msgs"] }
tokio = { version = "1", features = ["full"] }
</code></pre>
<p><strong>Build your project:</strong></p>
<pre><code class="language-bash">cargo build
</code></pre>
<p><strong>All available packages:</strong></p>
<ul>
<li><code>std_msgs</code> - Basic types</li>
<li><code>geometry_msgs</code> - Spatial data</li>
<li><code>sensor_msgs</code> - Sensor data</li>
<li><code>nav_msgs</code> - Navigation</li>
<li><code>example_interfaces</code> - Tutorial services (AddTwoInts)</li>
<li><code>action_tutorials_interfaces</code> - Tutorial actions (Fibonacci)</li>
<li><code>test_msgs</code> - Test types</li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/building.html#admonition-tip"></a>
</div>
<div>
<p>The default <code>core_msgs</code> feature includes everything except <code>test_msgs</code>. Use <code>all_msgs</code> only if you need test message types.</p>
</div>
</div>
<h2 id="ros-2-distribution-compatibility"><a class="header" href="#ros-2-distribution-compatibility">ROS 2 Distribution Compatibility</a></h2>
<p><strong>ros-z defaults to ROS 2 Jazzy compatibility</strong>, which is the recommended distribution for new projects. If you need to target a different distribution like Humble, see the <a href="chapters/./distro_compatibility.html">ROS 2 Distribution Compatibility</a> chapter for detailed instructions.</p>
<p><strong>Quick reference:</strong></p>
<pre><code class="language-bash"># Default (Jazzy) - works out of the box
cargo build

# For Humble - use --no-default-features
cargo build --no-default-features --features humble

# For Rolling/Kilted - just add the feature
cargo build --features rolling
</code></pre>
<p>The distribution choice affects type hash support and interoperability with ROS 2 nodes. See the <a href="chapters/./distro_compatibility.html">Distribution Compatibility chapter</a> for full details.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>This section is for contributors working on ros-z itself. If you're using ros-z in your project, you can skip this section.</p>
<h3 id="package-organization"><a class="header" href="#package-organization">Package Organization</a></h3>
<p>The ros-z repository is organized as a Cargo workspace with multiple packages:</p>
<div class="table-wrapper"><table><thead><tr><th>Package</th><th>Default Build</th><th>Purpose</th><th>Dependencies</th></tr></thead><tbody>
<tr><td><strong>ros-z</strong></td><td>Yes</td><td>Core Zenoh-native ROS 2 library</td><td>None</td></tr>
<tr><td><strong>ros-z-codegen</strong></td><td>Yes</td><td>Message generation utilities</td><td>None</td></tr>
<tr><td><strong>ros-z-msgs</strong></td><td>No</td><td>Pre-generated message types</td><td>None (all vendored)</td></tr>
<tr><td><strong>ros-z-tests</strong></td><td>No</td><td>Integration tests</td><td>ros-z-msgs</td></tr>
<tr><td><strong>rcl-z</strong></td><td>No</td><td>RCL C bindings</td><td>ROS 2 required</td></tr>
</tbody></table>
</div><div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/building.html#admonition-note"></a>
</div>
<div>
<p>Only <code>ros-z</code> and <code>ros-z-codegen</code> build by default. Other packages are optional for development, testing, and running examples.</p>
</div>
</div>
<h3 id="building-the-repository"><a class="header" href="#building-the-repository">Building the Repository</a></h3>
<p>When contributing to ros-z, you can build different parts of the workspace:</p>
<pre><code class="language-bash"># Build core library
cargo build

# Run tests
cargo test

# Build with bundled messages for examples
cargo build -p ros-z-msgs

# Build all packages (requires ROS 2)
source /opt/ros/jazzy/setup.bash
cargo build --all
</code></pre>
<h3 id="message-package-resolution"><a class="header" href="#message-package-resolution">Message Package Resolution</a></h3>
<p>The build system automatically locates ROS message definitions:</p>
<p><strong>Search order:</strong></p>
<ol>
<li>System ROS installation (<code>AMENT_PREFIX_PATH</code>, <code>CMAKE_PREFIX_PATH</code>)</li>
<li>Common ROS paths (<code>/opt/ros/{rolling,jazzy,kilted,humble}</code>)</li>
<li>Bundled assets (built-in message definitions in ros-z-codegen)</li>
</ol>
<p>This fallback mechanism enables builds without ROS 2 installed.</p>
<h3 id="common-development-commands"><a class="header" href="#common-development-commands">Common Development Commands</a></h3>
<pre><code class="language-bash"># Fast iterative development
cargo check                # Quick compile check
cargo build                # Debug build
cargo build --release      # Optimized build
cargo test                 # Run tests
cargo clippy              # Lint checks

# Clean builds
cargo clean                # Remove all build artifacts
cargo clean -p ros-z-msgs  # Clean specific package
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/building.html#admonition-warning"></a>
</div>
<div>
<p>After changing feature flags or updating ROS 2, run <code>cargo clean -p ros-z-msgs</code> to force message regeneration.</p>
</div>
</div>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><strong><a href="chapters/./distro_compatibility.html">ROS 2 Distribution Compatibility</a></strong> - Target Jazzy, Humble, or other distributions</li>
<li><strong><a href="chapters/./examples.html">Running Examples</a></strong> - Try out the included examples</li>
<li><strong><a href="chapters/./networking.html">Networking</a></strong> - Set up Zenoh router and session config</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - Understand how messages work</li>
<li><strong><a href="chapters/./troubleshooting.html">Troubleshooting</a></strong> - Solutions to common build issues</li>
</ul>
<p><strong>Start with the simplest build and add dependencies incrementally as your project grows.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-2-distribution-compatibility-1"><a class="header" href="#ros-2-distribution-compatibility-1">ROS 2 Distribution Compatibility</a></h1>
<p>ros-z supports multiple ROS 2 distributions through compile-time feature flags. This chapter explains the differences between distributions and how to target specific ROS 2 versions.</p>
<blockquote>
<p><strong>Important</strong>: Different ros-z components have different ROS 2 version requirements:</p>
<ul>
<li><strong>ros-z core library</strong>: Supports Humble, Jazzy, Kilted, Rolling</li>
<li><strong>rmw-zenoh-rs</strong>: Requires Jazzy or later (see <a href="chapters/./rmw_zenoh_rs.html#ros-2-version-requirements">rmw-zenoh-rs chapter</a>)</li>
</ul>
</blockquote>
<h2 id="supported-distributions"><a class="header" href="#supported-distributions">Supported Distributions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Distribution</th><th>Core Library</th><th>rmw-zenoh-rs</th><th>Type Hash Support</th><th>Default</th></tr></thead><tbody>
<tr><td><strong>Kilted Kaiju</strong></td><td>✅ Supported</td><td>✅ Supported</td><td>✅ Yes</td><td>No</td></tr>
<tr><td><strong>Jazzy Jalisco</strong></td><td>✅ Supported</td><td>✅ Supported</td><td>✅ Yes</td><td><strong>Yes</strong></td></tr>
<tr><td><strong>Humble Hawksbill</strong></td><td>✅ Supported</td><td>❌ <strong>Not Supported</strong></td><td>❌ Placeholder</td><td>No</td></tr>
<tr><td>Rolling Ridley</td><td>✅ Supported</td><td>✅ Supported</td><td>✅ Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Default</strong>: ros-z defaults to <strong>Jazzy</strong> compatibility, which is the recommended distribution for new projects.</p>
<h2 id="distribution-differences"><a class="header" href="#distribution-differences">Distribution Differences</a></h2>
<h3 id="type-hash-support"><a class="header" href="#type-hash-support">Type Hash Support</a></h3>
<p>The most significant difference between distributions is <strong>type hash support</strong>:</p>
<p><strong>Jazzy/Kilted/Rolling</strong> (Modern):</p>
<ul>
<li>Supports real type hashes computed from message definitions</li>
<li>Format: <code>RIHS01_&lt;64-hex-chars&gt;</code> (ROS IDL Hash Standard version 1)</li>
<li>Enables type safety checks during pub/sub matching</li>
<li>Type hashes are embedded in Zenoh key expressions for discovery</li>
</ul>
<p><strong>Humble</strong> (Legacy):</p>
<ul>
<li>Does not support real type hashes</li>
<li>Uses constant placeholder: <code>"TypeHashNotSupported"</code></li>
<li>No type safety validation during discovery</li>
<li>Compatible with rmw_zenoh_cpp v0.1.8</li>
</ul>
<h3 id="example-key-expressions"><a class="header" href="#example-key-expressions">Example Key Expressions</a></h3>
<p><strong>Jazzy:</strong></p>
<pre><code class="language-text">@ros2_lv/0/&lt;zid&gt;/&lt;nid&gt;/&lt;eid&gt;/MP/%/&lt;namespace&gt;/&lt;node&gt;/chatter/std_msgs%msg%String/RIHS01_1234567890abcdef.../...
</code></pre>
<p><strong>Humble:</strong></p>
<pre><code class="language-text">@ros2_lv/0/&lt;zid&gt;/&lt;nid&gt;/&lt;eid&gt;/MP/%/&lt;namespace&gt;/&lt;node&gt;/chatter/std_msgs%msg%String/TypeHashNotSupported/...
</code></pre>
<h2 id="building-for-different-distributions"><a class="header" href="#building-for-different-distributions">Building for Different Distributions</a></h2>
<h3 id="using-jazzy-default"><a class="header" href="#using-jazzy-default">Using Jazzy (Default)</a></h3>
<p>By default, ros-z builds with Jazzy compatibility. No special flags needed:</p>
<pre><code class="language-bash"># Build with default (Jazzy)
cargo build

# Run examples
cargo run --example demo_nodes_talker

# Run tests
cargo nextest run
</code></pre>
<h3 id="using-humble"><a class="header" href="#using-humble">Using Humble</a></h3>
<p>To build for Humble, use <code>--no-default-features --features humble</code>:</p>
<pre><code class="language-bash"># Build for Humble
cargo build --no-default-features --features humble

# Run examples for Humble
cargo run --no-default-features --features humble --example demo_nodes_talker

# Run tests for Humble
cargo nextest run --no-default-features --features humble
</code></pre>
<h3 id="using-other-distributions"><a class="header" href="#using-other-distributions">Using Other Distributions</a></h3>
<p>For Rolling or Kilted, simply specify the distro feature:</p>
<pre><code class="language-bash"># Build for Rolling
cargo build --features rolling

# Build for Kilted
cargo build --features kilted
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/examples.html#admonition-note"></a>
</div>
<div>
<p>The examples described here are part of the ros-z repository. To run them, you must first clone the repository.</p>
</div>
</div>
<pre><code class="language-bash">git clone https://github.com/ZettaScaleLabs/ros-z.git
cd ros-z
</code></pre>
<h2 id="start-the-zenoh-router-1"><a class="header" href="#start-the-zenoh-router-1">Start the Zenoh Router</a></h2>
<p>All examples require a Zenoh router to be running first (see <a href="chapters/./networking.html">Networking</a> for why ros-z uses router-based architecture by default).</p>
<h2 id="from-the-ros-z-repository"><a class="header" href="#from-the-ros-z-repository">From the ros-z Repository</a></h2>
<p>If you're working in the ros-z repository, use the included router example:</p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
<h2 id="from-your-own-project"><a class="header" href="#from-your-own-project">From Your Own Project</a></h2>
<p>If you're working on your own project, you need to install a Zenoh router. Quick options:</p>
<pre><code class="language-bash"># Using cargo
cargo install zenohd

# Using Docker
docker run --init --net host eclipse/zenoh:latest

# Using apt (Ubuntu/Debian)
echo "deb [trusted=yes] https://download.eclipse.org/zenoh/debian-repo/ /" | sudo tee /etc/apt/sources.list.d/zenoh.list
sudo apt update &amp;&amp; sudo apt install zenoh
</code></pre>
<p>Then run:</p>
<pre><code class="language-bash">zenohd
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/examples.html#admonition-tip"></a>
</div>
<div>
<p>See the comprehensive <a href="chapters/./networking.html#running-the-zenoh-router">Zenoh Router Installation Guide</a> for all installation methods including pre-built binaries, package managers, and more.</p>
</div>
</div>
<hr />
<h2 id="available-examples"><a class="header" href="#available-examples">Available Examples</a></h2>
<p>Leave the router running in a separate terminal, then run any example in another terminal from the ros-z repository root:</p>
<pre><code class="language-bash"># Pure Rust example with custom messages (no ros-z-msgs needed)
cargo run --example z_custom_message -- --mode status-pub

# Examples using bundled messages (requires ros-z-msgs)
cargo run --example z_pubsub          # Publisher/Subscriber with std_msgs
cargo run --example twist_pub         # Publishing geometry_msgs
cargo run --example battery_state_sub # Receiving sensor_msgs
cargo run --example z_srvcli          # Service example with example_interfaces
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/examples.html#admonition-tip-1"></a>
</div>
<div>
<p>For a detailed walkthrough of creating your own project with ros-z (not using the repository examples), see the <a href="chapters/./quick_start.html#option-2-create-your-own-project">Quick Start</a> guide.</p>
</div>
</div>
<hr />
<h2 id="demo-nodes"><a class="header" href="#demo-nodes">Demo Nodes</a></h2>
<p>The <code>demo_nodes</code> examples are basic ROS 2 patterns referenced from <a href="https://github.com/ros2/demos/tree/rolling/demo_nodes_cpp">ROS 2 demo_nodes_cpp</a>. These demonstrate fundamental pub/sub and service patterns.</p>
<h3 id="talker-publisher"><a class="header" href="#talker-publisher">Talker (Publisher)</a></h3>
<p>A simple publisher node that publishes "Hello World" messages to the <code>/chatter</code> topic.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Publishes <code>std_msgs/String</code> messages</li>
<li>Uses async API for non-blocking publishing</li>
<li>Publishes at 1 Hz (configurable)</li>
<li>Uses QoS history depth of 7 (KeepLast)</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Default settings (topic: chatter, period: 1.0s)
cargo run --example demo_nodes_talker

# Custom topic and faster publishing
cargo run --example demo_nodes_talker -- --topic /my_topic --period 0.5

# Connect to specific Zenoh router
cargo run --example demo_nodes_talker -- --endpoint tcp/localhost:7447
</code></pre>
<p><strong>Command-line Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>-t, --topic &lt;TOPIC&gt;</code></td><td>Topic name to publish to</td><td><code>chatter</code></td></tr>
<tr><td><code>-p, --period &lt;PERIOD&gt;</code></td><td>Publishing period in seconds</td><td><code>1.0</code></td></tr>
<tr><td><code>-m, --mode &lt;MODE&gt;</code></td><td>Zenoh session mode (peer/client/router)</td><td><code>peer</code></td></tr>
<tr><td><code>-e, --endpoint &lt;ENDPOINT&gt;</code></td><td>Zenoh router endpoint to connect to</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="listener-subscriber"><a class="header" href="#listener-subscriber">Listener (Subscriber)</a></h3>
<p>A simple subscriber node that listens to messages on a topic.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Subscribes to <code>std_msgs/String</code> messages</li>
<li>Uses async API for receiving messages</li>
<li>Uses QoS history depth of 10 (KeepLast)</li>
<li>Prints received messages to console</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Default settings (topic: chatter)
cargo run --example demo_nodes_listener

# Custom topic
cargo run --example demo_nodes_listener -- --topic /my_topic

# Connect to specific Zenoh router
cargo run --example demo_nodes_listener -- --endpoint tcp/localhost:7447
</code></pre>
<p><strong>Command-line Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>-t, --topic &lt;TOPIC&gt;</code></td><td>Topic name to subscribe to</td><td><code>chatter</code></td></tr>
<tr><td><code>-m, --mode &lt;MODE&gt;</code></td><td>Zenoh session mode (peer/client/router)</td><td><code>peer</code></td></tr>
<tr><td><code>-e, --endpoint &lt;ENDPOINT&gt;</code></td><td>Zenoh router endpoint to connect to</td><td>-</td></tr>
</tbody></table>
</div>
<p><strong>Test the pub/sub pattern:</strong></p>
<p>Terminal 1:</p>
<pre><code class="language-bash">cargo run --example demo_nodes_talker
</code></pre>
<p>Terminal 2:</p>
<pre><code class="language-bash">cargo run --example demo_nodes_listener
</code></pre>
<p>Expected output in Terminal 2:</p>
<pre><code class="language-text">I heard: [Hello World: 1]
I heard: [Hello World: 2]
I heard: [Hello World: 3]
...
</code></pre>
<h3 id="add-two-ints-server"><a class="header" href="#add-two-ints-server">Add Two Ints Server</a></h3>
<p>A simple service server that adds two integers and returns the result.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Provides <code>example_interfaces/AddTwoInts</code> service</li>
<li>Handles addition requests synchronously</li>
<li>Uses async API for service handling</li>
<li>Prints received requests and sent responses</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Default settings (handles unlimited requests)
cargo run --example demo_nodes_add_two_ints_server

# Handle only one request and exit
cargo run --example demo_nodes_add_two_ints_server -- --count 1

# Connect to specific Zenoh router
cargo run --example demo_nodes_add_two_ints_server -- --endpoint tcp/localhost:7447
</code></pre>
<p><strong>Command-line Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>-c, --count &lt;COUNT&gt;</code></td><td>Number of requests to handle before exiting (0 for unlimited)</td><td><code>0</code></td></tr>
<tr><td><code>-m, --mode &lt;MODE&gt;</code></td><td>Zenoh session mode (peer/client/router)</td><td><code>peer</code></td></tr>
<tr><td><code>-e, --endpoint &lt;ENDPOINT&gt;</code></td><td>Zenoh router endpoint to connect to</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="add-two-ints-client"><a class="header" href="#add-two-ints-client">Add Two Ints Client</a></h3>
<p>A simple service client that sends addition requests to the server.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Calls <code>example_interfaces/AddTwoInts</code> service</li>
<li>Supports both synchronous and asynchronous response waiting</li>
<li>Uses async API for client operations</li>
<li>Configurable numbers to add</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Default settings (sync mode, adds 2 + 3)
cargo run --example demo_nodes_add_two_ints_client

# Async mode
cargo run --example demo_nodes_add_two_ints_client -- --async-mode

# Custom numbers
cargo run --example demo_nodes_add_two_ints_client -- --a 10 --b 20

# Async mode with custom numbers
cargo run --example demo_nodes_add_two_ints_client -- --a 10 --b 20 --async-mode

# Connect to specific Zenoh router
cargo run --example demo_nodes_add_two_ints_client -- --endpoint tcp/localhost:7447
</code></pre>
<p><strong>Command-line Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>-a, --a &lt;A&gt;</code></td><td>First number to add</td><td><code>2</code></td></tr>
<tr><td><code>-b, --b &lt;B&gt;</code></td><td>Second number to add</td><td><code>3</code></td></tr>
<tr><td><code>--async-mode</code></td><td>Use asynchronous response waiting</td><td><code>false</code></td></tr>
<tr><td><code>-m, --mode &lt;MODE&gt;</code></td><td>Zenoh session mode (peer/client/router)</td><td><code>peer</code></td></tr>
<tr><td><code>-e, --endpoint &lt;ENDPOINT&gt;</code></td><td>Zenoh router endpoint to connect to</td><td>-</td></tr>
</tbody></table>
</div>
<p><strong>Test the service pattern:</strong></p>
<p>Terminal 1 (Server):</p>
<pre><code class="language-bash">cargo run --example demo_nodes_add_two_ints_server -- --count 1
</code></pre>
<p>Terminal 2 (Client - sync mode):</p>
<pre><code class="language-bash">cargo run --example demo_nodes_add_two_ints_client
</code></pre>
<p>Or Terminal 2 (Client - async mode):</p>
<pre><code class="language-bash">cargo run --example demo_nodes_add_two_ints_client -- --async-mode
</code></pre>
<p><strong>Expected output (Client):</strong></p>
<pre><code class="language-text">AddTwoInts service client started (mode: sync/async)
Sending request: 2 + 3
Received response: 5
Result: 5
</code></pre>
<p><strong>Expected output (Server):</strong></p>
<pre><code class="language-text">AddTwoInts service server started
Received request: 2 + 3
Sending response: 5
</code></pre>
<hr />
<h2 id="custom-messages-demo"><a class="header" href="#custom-messages-demo">Custom Messages Demo</a></h2>
<p>This example demonstrates how to generate Rust types from user-defined ROS 2 message definitions. See the <a href="chapters/./custom_messages.html">Custom Messages</a> chapter for comprehensive documentation.</p>
<p><strong>Quick start:</strong></p>
<pre><code class="language-bash">cd crates/ros-z/examples/custom_msgs_demo
ROS_Z_MSG_PATH="./my_robot_msgs" cargo build
</code></pre>
<hr />
<h2 id="protobuf-demo"><a class="header" href="#protobuf-demo">Protobuf Demo</a></h2>
<p>This example demonstrates using protobuf serialization with ros-z, both for ROS messages and custom protobuf messages. See the <a href="chapters/./protobuf.html">Protobuf Serialization</a> chapter for comprehensive documentation.</p>
<p><strong>Quick start:</strong></p>
<pre><code class="language-bash">cd crates/ros-z/examples/protobuf_demo
cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<p><strong>Configure ros-z's Zenoh transport layer for optimal performance in your deployment environment.</strong> ros-z uses router-based architecture by default, matching ROS 2's official <code>rmw_zenoh_cpp</code> middleware for production-ready scalability.</p>
<div align="center">
<pre class="mermaid">graph TB
    Router[&quot;zenohd &lt;br&gt; (router)&quot;]

    Talker[&quot;Talker node &lt;br&gt; (peer)&quot;]
    Listener[&quot;Listener node &lt;br&gt; (peer)&quot;]

    Router &lt;--&gt;|Discovery| Talker
    Router &lt;--&gt;|Discovery| Listener
    Talker &lt;-.-&gt;|P2P Communication| Listener
</pre>
</div>
<h2 id="router-based-architecture"><a class="header" href="#router-based-architecture">Router-Based Architecture</a></h2>
<p>ros-z uses a centralized Zenoh router for node discovery and communication, providing:</p>
<div class="table-wrapper"><table><thead><tr><th>Benefit</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Scalability</strong></td><td>Centralized discovery handles large deployments efficiently</td></tr>
<tr><td><strong>Lower Network Overhead</strong></td><td>TCP-based discovery instead of multicast broadcasts</td></tr>
<tr><td><strong>ROS 2 Compatibility</strong></td><td>Matches <code>rmw_zenoh_cpp</code> behavior for seamless interoperability</td></tr>
<tr><td><strong>Production Ready</strong></td><td>Battle-tested configuration used in real robotics systems</td></tr>
</tbody></table>
</div>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>The default ros-z configuration connects to a Zenoh router on <code>tcp/localhost:7447</code>:</p>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z::Builder;

// Uses default ROS session config (connects to tcp/localhost:7447)
let ctx = ZContextBuilder::default().build()?;
let node = ctx.create_node("my_node").build()?;</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/networking.html#admonition-success"></a>
</div>
<div>
<p>That's it! The default configuration automatically connects to the router. Now you just need to run one.</p>
</div>
</div>
<h2 id="running-the-zenoh-router"><a class="header" href="#running-the-zenoh-router">Running the Zenoh Router</a></h2>
<p>ros-z applications require a Zenoh router to be running. There are several ways to get one - choose based on your environment and requirements.</p>
<h3 id="quick-comparison"><a class="header" href="#quick-comparison">Quick Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Best For</th><th>Requires</th><th>Setup Speed</th></tr></thead><tbody>
<tr><td><a href="chapters/networking.html#method-1-cargo-install">Cargo Install</a></td><td>Rust developers</td><td>Rust toolchain</td><td>Slower (build from source)</td></tr>
<tr><td><a href="chapters/networking.html#method-2-pre-built-binary">Pre-built Binary</a></td><td>Quick setup, no Rust</td><td>None</td><td>Fast</td></tr>
<tr><td><a href="chapters/networking.html#method-3-docker">Docker</a></td><td>Containers, CI/CD</td><td>Docker</td><td>Fast</td></tr>
<tr><td><a href="chapters/networking.html#method-4-package-manager-apt-brew">Package Manager</a></td><td>System-wide install</td><td>apt/brew/etc</td><td>Fast</td></tr>
<tr><td><a href="chapters/networking.html#method-5-ros-z-example-router">ros-z Example</a></td><td>ros-z repo developers</td><td>ros-z repository</td><td>Very Fast</td></tr>
<tr><td><a href="chapters/networking.html#method-6-ros-2-rmw_zenoh">ROS 2 rmw_zenoh</a></td><td>ROS 2 interop testing</td><td>ROS 2 installed</td><td>Already installed</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="method-1-cargo-install"><a class="header" href="#method-1-cargo-install">Method 1: Cargo Install</a></h3>
<p><strong>Recommended for Rust developers building standalone projects.</strong></p>
<p>Install the official Zenoh router using Cargo:</p>
<pre><code class="language-bash">cargo install zenohd
</code></pre>
<p>Run the router:</p>
<pre><code class="language-bash">zenohd
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Always up-to-date with latest Zenoh</li>
<li>Builds optimized for your system</li>
<li>Easy to update: <code>cargo install zenohd --force</code></li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires Rust toolchain</li>
<li>Takes 2-5 minutes to compile</li>
</ul>
<hr />
<h3 id="method-2-pre-built-binary"><a class="header" href="#method-2-pre-built-binary">Method 2: Pre-built Binary</a></h3>
<p><strong>Fastest way to get started without Rust installed.</strong></p>
<p><strong>Download:</strong> Go to the <a href="https://github.com/eclipse-zenoh/zenoh/releases">Zenoh Releases page</a> and download the appropriate archive for your platform:</p>
<ul>
<li>Linux (x86_64): <code>zenoh-*-x86_64-unknown-linux-gnu-standalone.zip</code></li>
<li>macOS (Apple Silicon): <code>zenoh-*-aarch64-apple-darwin-standalone.zip</code></li>
<li>macOS (Intel): <code>zenoh-*-x86_64-apple-darwin-standalone.zip</code></li>
<li>Windows: <code>zenoh-*-x86_64-pc-windows-msvc-standalone.zip</code></li>
</ul>
<p><strong>Extract and run:</strong></p>
<p>Linux/macOS:</p>
<pre><code class="language-bash">unzip zenoh-*.zip
chmod +x zenohd
./zenohd
</code></pre>
<p>Windows (PowerShell):</p>
<pre><code class="language-powershell">Expand-Archive zenoh-*.zip
.\zenoh\zenohd.exe
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>No build tools required</li>
<li>Instant startup</li>
<li>Portable - can run from any directory</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Manual download and extraction</li>
<li>Need to track updates yourself</li>
</ul>
<p><strong>More info:</strong> <a href="https://zenoh.io/docs/getting-started/installation/">https://zenoh.io/docs/getting-started/installation/</a></p>
<hr />
<h3 id="method-3-docker"><a class="header" href="#method-3-docker">Method 3: Docker</a></h3>
<p><strong>Perfect for containerized deployments and CI/CD pipelines.</strong></p>
<p>Pull and run the official Zenoh router image:</p>
<pre><code class="language-bash">docker run --init --net host eclipse/zenoh:latest
</code></pre>
<p><strong>For production with persistent config:</strong></p>
<pre><code class="language-bash">docker run -d \
  --name zenoh-router \
  --net host \
  -v /path/to/config:/zenoh/config \
  eclipse/zenoh:latest \
  --config /zenoh/config/zenoh.json5
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Isolated from host system</li>
<li>Easy to deploy and scale</li>
<li>Works great in Kubernetes/Docker Compose</li>
<li>Consistent across environments</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires Docker installed</li>
<li>Network setup can be tricky (use <code>--net host</code> for simplicity)</li>
</ul>
<p><strong>Docker Hub:</strong> <a href="https://hub.docker.com/r/eclipse/zenoh/tags">https://hub.docker.com/r/eclipse/zenoh/tags</a></p>
<hr />
<h3 id="method-4-package-manager-apt-brew"><a class="header" href="#method-4-package-manager-apt-brew">Method 4: Package Manager (apt, brew)</a></h3>
<p><strong>Best for system-wide installation on Linux/macOS.</strong></p>
<p><strong>Ubuntu/Debian (via apt):</strong></p>
<pre><code class="language-bash">echo "deb [trusted=yes] https://download.eclipse.org/zenoh/debian-repo/ /" | sudo tee /etc/apt/sources.list.d/zenoh.list
sudo apt update
sudo apt install zenoh
</code></pre>
<p>Run as a service:</p>
<pre><code class="language-bash">sudo systemctl enable zenoh
sudo systemctl start zenoh
</code></pre>
<p>Or run manually:</p>
<pre><code class="language-bash">zenohd
</code></pre>
<p><strong>macOS (via Homebrew):</strong></p>
<pre><code class="language-bash">brew tap eclipse-zenoh/homebrew-zenoh
brew install zenoh
zenohd
</code></pre>
<p><strong>Arch Linux (via AUR):</strong></p>
<pre><code class="language-bash">yay -S zenoh
zenohd
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>System-wide installation</li>
<li>Easy updates via package manager</li>
<li>Can run as systemd service (Linux)</li>
<li>Integrates with OS security/firewall settings</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>May not have the absolute latest version</li>
<li>Requires sudo/admin privileges</li>
</ul>
<hr />
<h3 id="method-5-ros-z-example-router"><a class="header" href="#method-5-ros-z-example-router">Method 5: ros-z Example Router</a></h3>
<p><strong>Only available when working in the ros-z repository - perfect for quick development/testing.</strong></p>
<p>If you've cloned the ros-z repository:</p>
<pre><code class="language-bash">cd /path/to/ros-z
cargo run --example zenoh_router
</code></pre>
<p>This runs a pre-configured router that matches ros-z defaults exactly.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>No installation needed</li>
<li>Already configured for ros-z</li>
<li>Useful for debugging ros-z itself</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Only available in the ros-z repository</li>
<li>Not suitable for standalone projects</li>
<li>Slower startup (rebuilds if code changes)</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/networking.html#admonition-warning"></a>
</div>
<div>
<p>This method is for ros-z repository development only. If you're building your own project with ros-z as a dependency, use one of the other methods instead.</p>
</div>
</div>
<hr />
<h3 id="method-6-ros-2-rmw_zenoh"><a class="header" href="#method-6-ros-2-rmw_zenoh">Method 6: ROS 2 rmw_zenoh</a></h3>
<p><strong>Use this if you have ROS 2 installed and want to test interoperability with ROS 2 nodes.</strong></p>
<p>If you have ROS 2 Jazzy or newer with the Zenoh middleware:</p>
<pre><code class="language-bash">ros2 run rmw_zenoh_cpp rmw_zenohd
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Already installed with ROS 2 Jazzy+</li>
<li>Guaranteed compatibility with ROS 2 nodes</li>
<li>Can interoperate ros-z nodes with C++/Python ROS 2 nodes</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires full ROS 2 installation</li>
<li>Overkill if you only want to use ros-z</li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/networking.html#admonition-tip"></a>
</div>
<div>
<p>This is excellent for testing interoperability - run ros-z nodes alongside standard ROS 2 nodes using the same router.</p>
</div>
</div>
<hr />
<h2 id="verifying-the-router-is-running"><a class="header" href="#verifying-the-router-is-running">Verifying the Router is Running</a></h2>
<p>After starting a router with any method above, verify it's working:</p>
<p><strong>Check the router is listening on port 7447:</strong></p>
<pre><code class="language-bash"># Linux/macOS
netstat -an | grep 7447

# Or use lsof
lsof -i :7447
</code></pre>
<p><strong>Test with a ros-z application:</strong></p>
<pre><code class="language-bash"># In another terminal, try running a ros-z node
# If it connects successfully, the router is working
</code></pre>
<p>You should see log output from the router showing connections when your ros-z nodes start.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Choose the configuration approach that fits your needs:</p>
<ul>
<li><strong><a href="chapters/./config_options.html">Configuration Options</a></strong> - Six ways to configure Zenoh (from simple to complex)</li>
<li><strong><a href="chapters/./config_advanced.html">Advanced Configuration</a></strong> - Generate config files, run routers, configuration reference</li>
<li><strong><a href="chapters/./troubleshooting.html">Troubleshooting</a></strong> - Solutions to connectivity issues</li>
</ul>
<p><strong>Ready to optimize your deployment? Experiment with different configurations and measure performance impact.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h1>
<p>ros-z provides multiple ways to configure Zenoh, from simple to advanced.</p>
<h2 id="option-1-default-configuration-recommended"><a class="header" href="#option-1-default-configuration-recommended">Option 1: Default Configuration (Recommended)</a></h2>
<p>Use the built-in ROS session config for standard deployments:</p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default().build()?;</code></pre>
<p><strong>What it does:</strong></p>
<ul>
<li>Connects to router at <code>tcp/localhost:7447</code></li>
<li>Uses ROS-compatible timeouts and buffer sizes</li>
<li>Disables multicast discovery (uses router instead)</li>
</ul>
<h2 id="option-2-custom-router-endpoint"><a class="header" href="#option-2-custom-router-endpoint">Option 2: Custom Router Endpoint</a></h2>
<p>Connect to a router on a different host or port:</p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .with_router_endpoint("tcp/192.168.1.100:7447")
    .build()?;</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Distributed systems with remote router</li>
<li>Custom port configurations</li>
<li>Multiple isolated networks</li>
</ul>
<h2 id="option-3-environment-variable-overrides"><a class="header" href="#option-3-environment-variable-overrides">Option 3: Environment Variable Overrides</a></h2>
<p>Override any Zenoh configuration setting using the <code>ROSZ_CONFIG_OVERRIDE</code> environment variable without changing code:</p>
<pre><code class="language-bash"># Override mode and endpoint
export ROSZ_CONFIG_OVERRIDE='mode="client";connect/endpoints=["tcp/192.168.1.100:7447"]'

# Run your application
cargo run --example my_app
</code></pre>
<pre><code class="language-rust ignore">// No code changes needed - overrides are applied automatically
let ctx = ZContextBuilder::default().build()?;</code></pre>
<p><strong>Format:</strong></p>
<ul>
<li>Semicolon-separated <code>key=value</code> pairs</li>
<li>Values use JSON5 syntax</li>
<li>Keys use slash-separated paths (e.g., <code>connect/endpoints</code>, <code>scouting/multicast/enabled</code>)</li>
</ul>
<p><strong>Common examples:</strong></p>
<pre><code class="language-bash"># Connect to remote router
export ROSZ_CONFIG_OVERRIDE='connect/endpoints=["tcp/10.0.0.5:7447"]'

# Enable multicast scouting explicitly
export ROSZ_CONFIG_OVERRIDE='scouting/multicast/enabled=true'

# Multiple overrides
export ROSZ_CONFIG_OVERRIDE='mode="client";connect/timeout_ms=5000;scouting/multicast/enabled=false'
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/config_options.html#admonition-tip"></a>
</div>
<div>
<p>Environment variable overrides have the highest priority and will override any programmatic configuration or config file settings.</p>
</div>
</div>
<h2 id="option-4-advanced-configuration-builders"><a class="header" href="#option-4-advanced-configuration-builders">Option 4: Advanced Configuration Builders</a></h2>
<p>Fine-tune session or router settings programmatically:</p>
<pre><code class="language-rust ignore">use ros_z::config::{SessionConfigBuilder, RouterConfigBuilder};

// Customize session config
let session_config = SessionConfigBuilder::new()
    .with_router_endpoint("tcp/192.168.1.100:7447")
    .build()?;

let ctx = ZContextBuilder::default()
    .with_zenoh_config(session_config)
    .build()?;

// Or build a custom router config
let router_config = RouterConfigBuilder::new()
    .with_listen_port(7448)  // Custom port
    .build()?;

zenoh::open(router_config).await?;</code></pre>
<p><strong>Key builder methods:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Builder</th><th>Methods</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>SessionConfigBuilder</code></td><td><code>with_router_endpoint(endpoint)</code></td><td>Connect to custom router</td></tr>
<tr><td><code>RouterConfigBuilder</code></td><td><code>with_listen_port(port)</code></td><td>Set custom router port</td></tr>
</tbody></table>
</div>
<h2 id="option-5-peer-mode-using-multicast-discovery-no-router-required"><a class="header" href="#option-5-peer-mode-using-multicast-discovery-no-router-required">Option 5: Peer Mode Using Multicast Discovery (No Router Required)</a></h2>
<p>Revert to multicast peer discovery for simple setups:</p>
<pre><code class="language-rust ignore">// Use vanilla Zenoh config (peer mode with multicast)
let ctx = ZContextBuilder::default()
    .with_zenoh_config(zenoh::Config::default())
    .build()?;</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/config_options.html#admonition-warning"></a>
</div>
<div>
<p>Multicast scouting discovery is convenient for quick testing but doesn't scale well and won't work with ROS 2 nodes using <code>rmw_zenoh_cpp</code> (which expects a zenoh router).</p>
</div>
</div>
<h2 id="option-6-load-from-config-file"><a class="header" href="#option-6-load-from-config-file">Option 6: Load from Config File</a></h2>
<p>Use JSON5 config files for complex deployments:</p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .with_config_file("/etc/zenoh/session_config.json5")
    .build()?;</code></pre>
<p><strong>When to use:</strong></p>
<ul>
<li>Deploying across multiple machines</li>
<li>Environment-specific configurations</li>
<li>Version-controlled infrastructure</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h1>
<h2 id="generating-config-files"><a class="header" href="#generating-config-files">Generating Config Files</a></h2>
<p>ros-z can generate JSON5 config files matching <code>rmw_zenoh_cpp</code> defaults. This is opt-in via the <code>generate-configs</code> feature flag.</p>
<h3 id="basic-generation"><a class="header" href="#basic-generation">Basic Generation</a></h3>
<pre><code class="language-bash">cargo build --features generate-configs
</code></pre>
<p><strong>Output location:</strong></p>
<pre><code class="language-console">target/debug/build/ros-z-*/out/ros_z_config/
  ├── DEFAULT_ROSZ_ROUTER_CONFIG.json5
  └── DEFAULT_ROSZ_SESSION_CONFIG.json5
</code></pre>
<h3 id="custom-output-directory"><a class="header" href="#custom-output-directory">Custom Output Directory</a></h3>
<p>Specify a custom directory using the <code>ROS_Z_CONFIG_OUTPUT_DIR</code> environment variable:</p>
<p><strong>Absolute path:</strong></p>
<pre><code class="language-bash">ROS_Z_CONFIG_OUTPUT_DIR=/etc/zenoh cargo build --features generate-configs
</code></pre>
<p><strong>Relative path (from package root):</strong></p>
<pre><code class="language-bash">ROS_Z_CONFIG_OUTPUT_DIR=./config cargo build --features generate-configs
</code></pre>
<p><strong>From workspace root:</strong></p>
<pre><code class="language-bash">ROS_Z_CONFIG_OUTPUT_DIR=$PWD/config cargo build -p ros-z --features generate-configs
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/config_advanced.html#admonition-tip"></a>
</div>
<div>
<p>Generated files include inline comments explaining each setting, making them perfect documentation references.</p>
</div>
</div>
<h3 id="using-generated-files"><a class="header" href="#using-generated-files">Using Generated Files</a></h3>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .with_config_file("./config/DEFAULT_ROSZ_SESSION_CONFIG.json5")
    .build()?;</code></pre>
<h2 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h2>
<h3 id="key-settings-explained"><a class="header" href="#key-settings-explained">Key Settings Explained</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Router</th><th>Session</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Mode</strong></td><td><code>router</code></td><td><code>peer</code></td><td>Router relays messages, peers connect directly</td></tr>
<tr><td><strong>Listen Endpoint</strong></td><td><code>tcp/[::]:7447</code></td><td>-</td><td>Router accepts connections</td></tr>
<tr><td><strong>Connect Endpoint</strong></td><td>-</td><td><code>tcp/localhost:7447</code></td><td>Session connects to router</td></tr>
<tr><td><strong>Multicast</strong></td><td>Disabled</td><td>Disabled</td><td>Uses TCP gossip for discovery</td></tr>
<tr><td><strong>Unicast Timeout</strong></td><td>60s</td><td>60s</td><td>Handles slow networks/large deployments</td></tr>
<tr><td><strong>Query Timeout</strong></td><td>10min</td><td>10min</td><td>Long-running service calls</td></tr>
<tr><td><strong>Max Sessions</strong></td><td>10,000</td><td>-</td><td>Supports concurrent node startup</td></tr>
<tr><td><strong>Keep-Alive</strong></td><td>2s</td><td>2s</td><td>Optimized for loopback</td></tr>
</tbody></table>
</div><div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/config_advanced.html#admonition-note"></a>
</div>
<div>
<p>These defaults are tuned for ROS 2 deployments and match <code>rmw_zenoh_cpp</code> exactly. Only modify them if you have specific performance requirements.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-generation"><a class="header" href="#message-generation">Message Generation</a></h1>
<p><strong>Automatic Rust type generation from ROS 2 message definitions at build time.</strong> The code generation system converts <code>.msg</code>, <code>.srv</code>, and <code>.action</code> files into type-safe Rust structs with full serialization support and ROS 2 compatibility.</p>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-success"></a>
</div>
<div>
<p>Message generation happens automatically during builds. You write ROS 2 message definitions, ros-z generates idiomatic Rust code.</p>
</div>
</div>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<pre class="mermaid">graph LR
    A[.msg/.srv files] --&gt; B[ros-z-codegen]
    B --&gt; C[Parse &amp; Resolve]
    C --&gt; D[Type Hashing]
    D --&gt; E[Code Generation]
    E --&gt; F[Rust Generator]
    E --&gt; G[Protobuf Generator]
    F --&gt; H[Rust Structs + Traits]
    G --&gt; I[Proto Files + Rust]
    H --&gt; J[ros-z-msgs]
    I --&gt; J
</pre>
<h2 id="key-features-2"><a class="header" href="#key-features-2">Key Features</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Build-time generation</strong></td><td>Runs during <code>cargo build</code></td><td>No manual steps</td></tr>
<tr><td><strong>Bundled definitions</strong></td><td>Includes common ROS types</td><td>Works without ROS 2</td></tr>
<tr><td><strong>Type safety</strong></td><td>Full Rust type system</td><td>Compile-time validation</td></tr>
<tr><td><strong>CDR compatible</strong></td><td>ROS 2 DDS serialization</td><td>Full interoperability</td></tr>
<tr><td><strong>Optional protobuf</strong></td><td>Additional serialization</td><td>Cross-language support</td></tr>
</tbody></table>
</div>
<h2 id="component-stack"><a class="header" href="#component-stack">Component Stack</a></h2>
<h3 id="ros-z-codegen"><a class="header" href="#ros-z-codegen">ros-z-codegen</a></h3>
<p>Internal message generation library for ros-z:</p>
<ul>
<li>Parses <code>.msg</code>, <code>.srv</code>, and <code>.action</code> file syntax</li>
<li>Resolves message dependencies across packages</li>
<li>Calculates ROS 2 type hashes (RIHS algorithm)</li>
<li>Generates Rust structs with serde</li>
<li>Bundles common message definitions</li>
</ul>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-info"></a>
</div>
<div>
<p>ros-z-codegen provides bundled messages for <code>std_msgs</code>, <code>geometry_msgs</code>, <code>sensor_msgs</code>, and <code>nav_msgs</code>. These work without ROS 2 installation.</p>
</div>
</div>
<h3 id="orchestration-layer"><a class="header" href="#orchestration-layer">Orchestration Layer</a></h3>
<p>ros-z-codegen's orchestration capabilities:</p>
<ul>
<li>Coordinates message discovery across sources</li>
<li>Manages build-time code generation</li>
<li>Provides code generators for different serialization formats</li>
<li>Generates ros-z-specific traits</li>
</ul>
<p><strong>Discovery workflow:</strong></p>
<pre class="mermaid">sequenceDiagram
    participant B as build.rs
    participant D as Discovery
    participant S as Sources

    B-&gt;&gt;D: Find packages
    D-&gt;&gt;S: Check AMENT_PREFIX_PATH
    alt Found in system
        S--&gt;&gt;D: System messages
    else Not found
        D-&gt;&gt;S: Check /opt/ros/*
        alt Found in standard path
            S--&gt;&gt;D: System messages
        else Not found
            D-&gt;&gt;S: Check bundled assets
            S--&gt;&gt;D: Bundled messages
        end
    end
    D--&gt;&gt;B: Package paths
    B-&gt;&gt;B: Generate Rust code
</pre>
<h3 id="code-generators"><a class="header" href="#code-generators">Code Generators</a></h3>
<p><strong>Rust Generator (default):</strong></p>
<ul>
<li>Generates structs with serde</li>
<li>CDR-compatible serialization via ros-z-cdr</li>
<li>Full ROS 2 DDS interoperability</li>
<li>No additional dependencies</li>
</ul>
<p><strong>Protobuf Generator (optional):</strong></p>
<ul>
<li>Generates <code>.proto</code> files</li>
<li>Protobuf-compatible types</li>
<li>Cross-language data exchange</li>
<li>Requires protobuf feature</li>
</ul>
<h2 id="generated-code"><a class="header" href="#generated-code">Generated Code</a></h2>
<p>For each ROS 2 message, ros-z generates:</p>
<h3 id="message-struct"><a class="header" href="#message-struct">Message Struct</a></h3>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct String {
    pub data: std::string::String,
}</code></pre>
<h3 id="type-information-traits"><a class="header" href="#type-information-traits">Type Information Traits</a></h3>
<pre><code class="language-rust ignore">impl MessageTypeInfo for std_msgs::String {
    fn type_name() -&gt; &amp;'static str {
        "std_msgs::msg::dds_::String_"
    }

    fn type_hash() -&gt; TypeHash {
        TypeHash::from_rihs_string("RIHS01_abc123...")
            .expect("Invalid hash")
    }
}

impl WithTypeInfo for std_msgs::String {
    fn type_info() -&gt; TypeInfo {
        TypeInfo::new(Self::type_name(), Self::type_hash())
    }
}</code></pre>
<p><strong>These traits enable:</strong></p>
<ul>
<li>Runtime type identification</li>
<li>ROS 2 compatibility validation</li>
<li>Proper DDS topic naming</li>
<li>Type-safe message passing</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-note"></a>
</div>
<div>
<p>Type hashes are critical for ROS 2 interoperability. They ensure nodes agree on message structure before exchanging data.</p>
</div>
</div>
<h2 id="build-process"><a class="header" href="#build-process">Build Process</a></h2>
<h3 id="ros-z-msgs-build-script"><a class="header" href="#ros-z-msgs-build-script">ros-z-msgs Build Script</a></h3>
<p>The generation happens in <code>build.rs</code>:</p>
<pre class="mermaid">flowchart TD
    A[Start build.rs] --&gt; B[Read enabled features]
    B --&gt; C[Discover package paths]
    C --&gt; D{Messages found?}
    D --&gt;|Yes| E[Parse message definitions]
    D --&gt;|No| F[Build error]
    E --&gt; G[Resolve dependencies]
    G --&gt; H[Generate Rust code]
    H --&gt; I[Write to OUT_DIR]
    I --&gt; J[Compile completes]
</pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-rust ignore">let config = GeneratorConfig {
    generate_cdr: true,        // CDR-compatible types
    generate_protobuf: false,  // Optional protobuf
    generate_type_info: true,  // Trait implementations
    output_dir: out_dir,
};</code></pre>
<h3 id="package-discovery-order"><a class="header" href="#package-discovery-order">Package Discovery Order</a></h3>
<pre class="mermaid">flowchart LR
    A[Feature Flags] --&gt; B{System ROS?}
    B --&gt;|Found| C[AMENT_PREFIX_PATH]
    B --&gt;|Not Found| D{/opt/ros/distro?}
    D --&gt;|Found| E[Standard paths]
    D --&gt;|Not Found| F[Bundled assets]

    C --&gt; G[Generate from system]
    E --&gt; G
    F --&gt; H[Generate from bundled]
</pre>
<ol>
<li><strong>System ROS:</strong> <code>$AMENT_PREFIX_PATH</code>, <code>$CMAKE_PREFIX_PATH</code></li>
<li><strong>Standard paths:</strong> <code>/opt/ros/{rolling,jazzy,kilted,humble}</code></li>
<li><strong>Bundled assets:</strong> Built-in message definitions in ros-z-codegen</li>
</ol>
<p>This fallback enables development without ROS 2 installation.</p>
<h2 id="using-generated-messages"><a class="header" href="#using-generated-messages">Using Generated Messages</a></h2>
<h3 id="import-pattern"><a class="header" href="#import-pattern">Import Pattern</a></h3>
<pre><code class="language-rust ignore">use ros_z_msgs::ros::std_msgs::String as RosString;
use ros_z_msgs::ros::geometry_msgs::Twist;
use ros_z_msgs::ros::sensor_msgs::LaserScan;</code></pre>
<h3 id="namespace-structure"><a class="header" href="#namespace-structure">Namespace Structure</a></h3>
<pre><code class="language-text">ros_z_msgs::ros::{package}::{MessageName}
</code></pre>
<p><strong>Examples:</strong></p>
<ul>
<li><code>ros_z_msgs::ros::std_msgs::String</code></li>
<li><code>ros_z_msgs::ros::geometry_msgs::Point</code></li>
<li><code>ros_z_msgs::ros::sensor_msgs::Image</code></li>
</ul>
<h3 id="service-types"><a class="header" href="#service-types">Service Types</a></h3>
<p>Services generate three types:</p>
<pre><code class="language-rust ignore">// Service definition
use ros_z_msgs::ros::example_interfaces::AddTwoInts;

// Request type
use ros_z_msgs::ros::example_interfaces::AddTwoIntsRequest;

// Response type
use ros_z_msgs::ros::example_interfaces::AddTwoIntsResponse;</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-tip"></a>
</div>
<div>
<p>Import the service type for creation, then use the request/response types when handling calls.</p>
</div>
</div>
<h2 id="message-packages"><a class="header" href="#message-packages">Message Packages</a></h2>
<h3 id="bundled-packages"><a class="header" href="#bundled-packages">Bundled Packages</a></h3>
<p>Available without ROS 2:</p>
<div class="table-wrapper"><table><thead><tr><th>Package</th><th>Messages</th><th>Use Cases</th></tr></thead><tbody>
<tr><td><strong>std_msgs</strong></td><td>String, Int32, Float64, etc.</td><td>Basic data types</td></tr>
<tr><td><strong>geometry_msgs</strong></td><td>Point, Pose, Twist, Transform</td><td>Spatial data</td></tr>
<tr><td><strong>sensor_msgs</strong></td><td>LaserScan, Image, Imu, PointCloud2</td><td>Sensor readings</td></tr>
<tr><td><strong>nav_msgs</strong></td><td>Path, Odometry, OccupancyGrid</td><td>Navigation</td></tr>
</tbody></table>
</div>
<pre><code class="language-bash"># Build with bundled messages
cargo build -p ros-z-msgs --features bundled_msgs
</code></pre>
<h3 id="additional-packages"><a class="header" href="#additional-packages">Additional Packages</a></h3>
<p>These packages are bundled and available without ROS 2 installation:</p>
<div class="table-wrapper"><table><thead><tr><th>Package</th><th>Messages</th><th>Use Cases</th></tr></thead><tbody>
<tr><td><strong>example_interfaces</strong></td><td>AddTwoInts, Fibonacci</td><td>Tutorials</td></tr>
<tr><td><strong>action_tutorials_interfaces</strong></td><td>Fibonacci action</td><td>Action tutorials</td></tr>
<tr><td><strong>test_msgs</strong></td><td>Test types</td><td>Testing</td></tr>
</tbody></table>
</div>
<pre><code class="language-bash"># All packages are bundled by default
cargo build -p ros-z-msgs --features all_msgs
</code></pre>
<h2 id="manual-custom-messages"><a class="header" href="#manual-custom-messages">Manual Custom Messages</a></h2>
<p>For rapid prototyping without <code>.msg</code> files:</p>
<h3 id="define-the-struct"><a class="header" href="#define-the-struct">Define the Struct</a></h3>
<pre><code class="language-rust ignore">use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RobotStatus {
    pub robot_id: String,
    pub battery_percentage: f64,
    pub position: [f64; 2],
    pub is_moving: bool,
}</code></pre>
<h3 id="implement-required-traits"><a class="header" href="#implement-required-traits">Implement Required Traits</a></h3>
<pre><code class="language-rust ignore">use ros_z::{MessageTypeInfo, WithTypeInfo, entity::TypeHash};

impl MessageTypeInfo for RobotStatus {
    fn type_name() -&gt; &amp;'static str {
        "custom_msgs::msg::dds_::RobotStatus_"
    }

    fn type_hash() -&gt; TypeHash {
        // For ros-z-to-ros-z only
        TypeHash::zero()
    }
}

impl WithTypeInfo for RobotStatus {}</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-warning"></a>
</div>
<div>
<p>Manual messages with <code>TypeHash::zero()</code> work only between ros-z nodes. For ROS 2 interoperability, use generated messages with proper type hashes.</p>
</div>
</div>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to Use Each Approach</a></h3>
<pre class="mermaid">flowchart TD
    A[Need Custom Message?] --&gt; B{Prototyping?}
    B --&gt;|Yes| C[Manual Implementation]
    B --&gt;|No| D{ROS 2 Interop?}
    D --&gt;|Required| E[Generate from .msg]
    D --&gt;|Not Required| F{Want Type Safety?}
    F --&gt;|Yes| E
    F --&gt;|No| C
</pre>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Pros</th><th>Cons</th><th>Use When</th></tr></thead><tbody>
<tr><td><strong>Manual</strong></td><td>Fast, flexible</td><td>No ROS 2 interop</td><td>Prototyping, internal only</td></tr>
<tr><td><strong>Generated</strong></td><td>Type hashes, portable</td><td>Requires .msg files</td><td>Production, ROS 2 systems</td></tr>
</tbody></table>
</div>
<h2 id="serialization-formats"><a class="header" href="#serialization-formats">Serialization Formats</a></h2>
<h3 id="cdr-default"><a class="header" href="#cdr-default">CDR (Default)</a></h3>
<p>Common Data Representation - ROS 2 standard:</p>
<ul>
<li>Full DDS compatibility</li>
<li>Efficient binary encoding</li>
<li>Used by all ROS 2 implementations</li>
<li>Automatic via serde</li>
</ul>
<pre><code class="language-rust ignore">// Generated with CDR support
#[derive(Serialize, Deserialize)]
pub struct String {
    pub data: std::string::String,
}</code></pre>
<h3 id="protobuf-optional"><a class="header" href="#protobuf-optional">Protobuf (Optional)</a></h3>
<p>Protocol Buffers alternative:</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features protobuf
cargo build -p ros-z --features protobuf
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Schema evolution</li>
<li>Cross-language compatibility</li>
<li>Familiar ecosystem</li>
<li>Efficient encoding</li>
</ul>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>Not ROS 2 standard format</li>
<li>Additional dependencies</li>
<li>Requires feature flag</li>
</ul>
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/message_generation.html#admonition-info-1"></a>
</div>
<div>
<p>Use protobuf when you need schema evolution or cross-language data exchange beyond ROS 2 ecosystem. See <a href="chapters/./protobuf.html">Protobuf Serialization</a> for detailed usage guide.</p>
</div>
</div>
<h2 id="extending-message-packages"><a class="header" href="#extending-message-packages">Extending Message Packages</a></h2>
<p>Add new packages to ros-z-msgs:</p>
<h3 id="1-add-feature-flag"><a class="header" href="#1-add-feature-flag">1. Add Feature Flag</a></h3>
<p>Edit <code>ros-z-msgs/Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
bundled_msgs = ["std_msgs", "geometry_msgs", "your_package"]
your_package = []
</code></pre>
<h3 id="2-update-build-script"><a class="header" href="#2-update-build-script">2. Update Build Script</a></h3>
<p>Edit <code>ros-z-msgs/build.rs</code>:</p>
<pre><code class="language-rust ignore">fn get_bundled_packages() -&gt; Vec&lt;&amp;'static str&gt; {
    let mut names = vec!["builtin_interfaces"];

    #[cfg(feature = "your_package")]
    names.push("your_package");

    names
}</code></pre>
<h3 id="3-rebuild"><a class="header" href="#3-rebuild">3. Rebuild</a></h3>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features your_package
</code></pre>
<p>The build system automatically:</p>
<ul>
<li>Searches for the package</li>
<li>Parses all message definitions</li>
<li>Generates Rust types with traits</li>
<li>Outputs to generated module</li>
</ul>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="message-filtering"><a class="header" href="#message-filtering">Message Filtering</a></h3>
<p>The generator automatically filters:</p>
<ul>
<li><strong>Deprecated actionlib messages</strong> - Old ROS 1 format</li>
<li><strong>wstring fields</strong> - Poor Rust support</li>
<li><strong>Duplicate definitions</strong> - Keeps first occurrence</li>
</ul>
<h3 id="type-hash-calculation"><a class="header" href="#type-hash-calculation">Type Hash Calculation</a></h3>
<p>ros-z uses the RIHS (ROS IDL Hash) algorithm:</p>
<pre class="mermaid">flowchart LR
    A[Message Definition] --&gt; B[Parse Structure]
    B --&gt; C[Include Dependencies]
    C --&gt; D[Calculate Hash]
    D --&gt; E[RIHS String]
    E --&gt; F[TypeHash Object]
</pre>
<p><strong>Properties:</strong></p>
<ul>
<li>Includes message structure and field types</li>
<li>Incorporates dependency hashes</li>
<li>Changes when definition changes</li>
<li>Ensures type safety across network</li>
</ul>
<p><strong>In generated code:</strong></p>
<pre><code class="language-rust ignore">TypeHash::from_rihs_string("RIHS01_1234567890abcdef...")
    .expect("Invalid RIHS hash string")</code></pre>
<h3 id="custom-code-generation"><a class="header" href="#custom-code-generation">Custom Code Generation</a></h3>
<p>For custom build scripts:</p>
<pre><code class="language-rust ignore">use ros_z_codegen::{MessageGenerator, GeneratorConfig};

let config = GeneratorConfig {
    generate_cdr: true,
    generate_protobuf: false,
    generate_type_info: true,
    output_dir: out_dir.clone(),
};

let generator = MessageGenerator::new(config);
generator.generate_from_msg_files(&amp;package_paths)?;</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="package-not-found"><a class="header" href="#package-not-found">Package Not Found</a></h3>
<pre><code class="language-bash"># Check ROS 2 is sourced
echo $AMENT_PREFIX_PATH

# Verify package exists
ros2 pkg list | grep your_package

# Install if missing
sudo apt install ros-jazzy-your-package

# Bundled packages are built into ros-z-codegen
cargo build -p ros-z-msgs --features bundled_msgs
</code></pre>
<h3 id="build-failures"><a class="header" href="#build-failures">Build Failures</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Cause</th><th>Solution</th></tr></thead><tbody>
<tr><td>"Cannot find package"</td><td>Missing dependency</td><td>Enable feature or install ROS 2 package</td></tr>
<tr><td>"Type conflict"</td><td>Duplicate definition</td><td>Remove manual implementation</td></tr>
<tr><td>"Hash error"</td><td>Version mismatch</td><td>Update ros-z-codegen dependency</td></tr>
</tbody></table>
</div>
<p>See <a href="chapters/./troubleshooting.html">Troubleshooting Guide</a> for detailed solutions.</p>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./feature_flags.html">Feature Flags</a></strong> - Available message packages</li>
<li><strong><a href="chapters/./building.html">Building</a></strong> - Build configuration</li>
<li><strong><a href="chapters/./custom_messages.html">Custom Messages</a></strong> - Manual implementation</li>
<li><strong><a href="chapters/./protobuf.html">Protobuf Serialization</a></strong> - Alternative serialization format</li>
</ul>
<p><strong>Message generation is transparent. Focus on writing ROS 2 message definitions and let ros-z handle the Rust code generation.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h1>
<p>ros-z supports two approaches for defining custom message types:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Definition</th><th>Best For</th></tr></thead><tbody>
<tr><td><strong>Rust-Native</strong></td><td>Write Rust structs directly</td><td>Prototyping, ros-z-only systems</td></tr>
<tr><td><strong>Schema-Generated</strong></td><td>Write <code>.msg</code>/<code>.srv</code> files, generate Rust</td><td>Production, ROS 2 interop</td></tr>
</tbody></table>
</div><pre class="mermaid">flowchart TD
    A[Need Custom Messages?] --&gt;|Yes| B{ROS 2 Interop Needed?}
    B --&gt;|Yes| C[Schema-Generated]
    B --&gt;|No| D{Quick Prototype?}
    D --&gt;|Yes| E[Rust-Native]
    D --&gt;|No| C
    A --&gt;|No| F[Use Standard Messages]
</pre>
<hr />
<h2 id="rust-native-messages"><a class="header" href="#rust-native-messages">Rust-Native Messages</a></h2>
<p><strong>Define messages directly in Rust by implementing required traits.</strong> This approach is fast for prototyping but only works between ros-z nodes.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/custom_messages.html#admonition-warning"></a>
</div>
<div>
<p>Rust-Native messages use <code>TypeHash::zero()</code> and won't interoperate with ROS 2 C++/Python nodes.</p>
</div>
</div>
<h3 id="workflow-of-rust-native-messages"><a class="header" href="#workflow-of-rust-native-messages">Workflow of Rust-Native Messages</a></h3>
<pre class="mermaid">graph LR
    A[Define Struct] --&gt; B[Impl MessageTypeInfo]
    B --&gt; C[Add Serde Traits]
    C --&gt; D[Impl WithTypeInfo]
    D --&gt; E[Use in Pub/Sub]
</pre>
<h3 id="required-traits"><a class="header" href="#required-traits">Required Traits</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Trait</th><th>Purpose</th><th>Key Method</th></tr></thead><tbody>
<tr><td><strong>MessageTypeInfo</strong></td><td>Type identification</td><td><code>type_name()</code>, <code>type_hash()</code></td></tr>
<tr><td><strong>WithTypeInfo</strong></td><td>ros-z integration</td><td><code>type_info()</code></td></tr>
<tr><td><strong>Serialize/Deserialize</strong></td><td>Data encoding</td><td>From <code>serde</code></td></tr>
</tbody></table>
</div>
<h3 id="message-example"><a class="header" href="#message-example">Message Example</a></h3>
<pre><code class="language-rust ignore">use ros_z::{MessageTypeInfo, entity::{TypeHash, TypeInfo}};
use ros_z::ros_msg::WithTypeInfo;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct RobotStatus {
    battery_level: f32,
    position_x: f32,
    position_y: f32,
    is_moving: bool,
}

impl MessageTypeInfo for RobotStatus {
    fn type_name() -&gt; &amp;'static str {
        "my_msgs::msg::dds_::RobotStatus_"
    }

    fn type_hash() -&gt; TypeHash {
        TypeHash::zero()  // ros-z-to-ros-z only
    }
}

impl WithTypeInfo for RobotStatus {
    fn type_info() -&gt; TypeInfo {
        TypeInfo::new(Self::type_name(), Self::type_hash())
    }
}</code></pre>
<h3 id="service-example"><a class="header" href="#service-example">Service Example</a></h3>
<pre><code class="language-rust ignore">use ros_z::{ServiceTypeInfo, msg::ZService};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct NavigateToRequest {
    target_x: f32,
    target_y: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct NavigateToResponse {
    success: bool,
}

struct NavigateTo;

impl ServiceTypeInfo for NavigateTo {
    fn service_type_info() -&gt; TypeInfo {
        TypeInfo::new("my_msgs::srv::dds_::NavigateTo_", TypeHash::zero())
    }
}

impl ZService for NavigateTo {
    type Request = NavigateToRequest;
    type Response = NavigateToResponse;
}</code></pre>
<p>See the <code>z_custom_message</code> example:</p>
<pre><code class="language-bash"># Terminal 1: Router
cargo run --example zenoh_router

# Terminal 2: Subscriber
cargo run --example z_custom_message -- --mode status-sub

# Terminal 3: Publisher
cargo run --example z_custom_message -- --mode status-pub
</code></pre>
<hr />
<h2 id="schema-generated-messages"><a class="header" href="#schema-generated-messages">Schema-Generated Messages</a></h2>
<p><strong>Define messages in <code>.msg</code>/<code>.srv</code> files and generate Rust code using <code>ros-z-codegen</code>.</strong> This approach provides proper type hashes and can reference standard ROS 2 types.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/custom_messages.html#admonition-tip"></a>
</div>
<div>
<p>Schema-Generated messages get proper RIHS01 type hashes and can reference types from <code>ros_z_msgs</code> like <code>geometry_msgs/Point</code>.</p>
</div>
</div>
<h3 id="workflow-of-schema-generated-messages"><a class="header" href="#workflow-of-schema-generated-messages">Workflow of Schema-Generated Messages</a></h3>
<pre class="mermaid">graph LR
    A[Write .msg files] --&gt; B[Create Rust crate]
    B --&gt; C[Add build.rs]
    C --&gt; D[Set ROS_Z_MSG_PATH]
    D --&gt; E[cargo build]
    E --&gt; F[Use generated types]
</pre>
<h3 id="step-1-create-message-package"><a class="header" href="#step-1-create-message-package">Step 1: Create Message Package</a></h3>
<p>Create a ROS 2 style directory structure:</p>
<pre><code class="language-text">my_robot_msgs/
├── msg/
│   ├── RobotStatus.msg
│   └── SensorReading.msg
└── srv/
    └── NavigateTo.srv
</code></pre>
<h3 id="step-2-define-messages"><a class="header" href="#step-2-define-messages">Step 2: Define Messages</a></h3>
<p>Messages can reference standard ROS 2 types:</p>
<pre><code class="language-text"># RobotStatus.msg
string robot_id
geometry_msgs/Point position
bool is_moving
</code></pre>
<pre><code class="language-text"># SensorReading.msg
builtin_interfaces/Time timestamp
float64[] values
string sensor_id
</code></pre>
<pre><code class="language-text"># NavigateTo.srv
geometry_msgs/Point target
float64 max_speed
---
bool success
string message
</code></pre>
<h3 id="step-3-create-rust-crate"><a class="header" href="#step-3-create-rust-crate">Step 3: Create Rust Crate</a></h3>
<p><strong>Cargo.toml:</strong></p>
<pre><code class="language-toml">[package]
name = "my-robot-msgs"
version = "0.1.0"
edition = "2021"

# Standalone package (not part of parent workspace)
[workspace]

[dependencies]
ros-z-msgs = { version = "0.1" }
ros-z = { version = "0.1", default-features = false }
serde = { version = "1", features = ["derive"] }
smart-default = "0.7"
zenoh-buffers = "1"

[build-dependencies]
ros-z-codegen = { version = "0.1" }
anyhow = "1"
</code></pre>
<p><strong>build.rs:</strong></p>
<pre><code class="language-rust ignore">use std::path::PathBuf;
use std::env;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    ros_z_codegen::generate_user_messages(&amp;out_dir, false)?;
    println!("cargo:rerun-if-env-changed=ROS_Z_MSG_PATH");
    Ok(())
}</code></pre>
<p><strong>src/lib.rs:</strong></p>
<pre><code class="language-rust ignore">// Re-export standard types from ros-z-msgs
pub use ros_z_msgs::*;

// Include generated user messages
include!(concat!(env!("OUT_DIR"), "/generated.rs"));</code></pre>
<h3 id="step-4-build"><a class="header" href="#step-4-build">Step 4: Build</a></h3>
<p>Set <code>ROS_Z_MSG_PATH</code> and build:</p>
<pre><code class="language-bash">ROS_Z_MSG_PATH="./my_robot_msgs" cargo build
</code></pre>
<p>For multiple packages, use colon-separated paths:</p>
<pre><code class="language-bash">ROS_Z_MSG_PATH="./my_msgs:./other_msgs" cargo build
</code></pre>
<h3 id="step-5-use-generated-types"><a class="header" href="#step-5-use-generated-types">Step 5: Use Generated Types</a></h3>
<pre><code class="language-rust ignore">use my_robot_msgs::ros::my_robot_msgs::{RobotStatus, SensorReading};
use my_robot_msgs::ros::my_robot_msgs::srv::NavigateTo;
use ros_z_msgs::ros::geometry_msgs::Point;
use ros_z_msgs::ros::builtin_interfaces::Time;

let status = RobotStatus {
    robot_id: "robot_1".to_string(),
    position: Point { x: 1.0, y: 2.0, z: 0.0 },
    is_moving: true,
};

let reading = SensorReading {
    timestamp: Time { sec: 1234, nanosec: 0 },
    values: vec![1.0, 2.0, 3.0],
    sensor_id: "lidar_1".to_string(),
};</code></pre>
<p>See <code>ros-z/examples/custom_msgs_demo/</code> for a working example:</p>
<pre><code class="language-bash">cd ros-z/examples/custom_msgs_demo
ROS_Z_MSG_PATH="./my_robot_msgs" cargo build
</code></pre>
<hr />
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Rust-Native</th><th>Schema-Generated</th></tr></thead><tbody>
<tr><td><strong>Definition</strong></td><td>Rust structs</td><td><code>.msg</code>/<code>.srv</code> files</td></tr>
<tr><td><strong>Type Hashes</strong></td><td><code>TypeHash::zero()</code></td><td>Proper RIHS01 hashes</td></tr>
<tr><td><strong>Standard Type Refs</strong></td><td>Manual</td><td>Automatic (<code>geometry_msgs</code>, etc.)</td></tr>
<tr><td><strong>ROS 2 Interop</strong></td><td>No</td><td>Partial (messages yes, services limited)</td></tr>
<tr><td><strong>Setup Complexity</strong></td><td>Low</td><td>Medium (build.rs required)</td></tr>
<tr><td><strong>Best For</strong></td><td>Prototyping</td><td>Production</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="type-naming-convention"><a class="header" href="#type-naming-convention">Type Naming Convention</a></h2>
<p>Both approaches should follow ROS 2 DDS naming:</p>
<pre><code class="language-text"># Messages
package::msg::dds_::MessageName_

# Services
package::srv::dds_::ServiceName_
</code></pre>
<p>The trailing underscore and <code>dds_</code> infix match ROS 2's internal naming scheme.</p>
<hr />
<h2 id="resources-4"><a class="header" href="#resources-4">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - How ros-z-msgs generates standard types</li>
<li><strong><a href="chapters/./protobuf.html">Protobuf Serialization</a></strong> - Alternative serialization format</li>
<li><strong><a href="chapters/./pubsub.html">Publishers &amp; Subscribers</a></strong> - Using messages in pub-sub</li>
<li><strong><a href="chapters/./services.html">Services</a></strong> - Using messages in services</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protobuf-serialization"><a class="header" href="#protobuf-serialization">Protobuf Serialization</a></h1>
<p><strong>Use Protocol Buffers as an alternative serialization format for ros-z messages.</strong> While CDR is the default ROS 2-compatible format, protobuf offers schema evolution, cross-language compatibility, and familiar tooling for teams already using the protobuf ecosystem.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-info"></a>
</div>
<div>
<p>Protobuf support in ros-z enables two powerful use cases:</p>
<ol>
<li><strong>ROS messages with protobuf encoding</strong> - Use standard ROS message types serialized via protobuf</li>
<li><strong>Pure protobuf messages</strong> - Send custom <code>.proto</code> messages directly through ros-z</li>
</ol>
</div>
</div>
<h2 id="when-to-use-protobuf"><a class="header" href="#when-to-use-protobuf">When to Use Protobuf</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Use Case</th><th>Recommendation</th></tr></thead><tbody>
<tr><td><strong>ROS 2 interoperability</strong></td><td>Use CDR (default)</td></tr>
<tr><td><strong>Schema evolution</strong></td><td>Use Protobuf</td></tr>
<tr><td><strong>Cross-language data exchange</strong></td><td>Use Protobuf</td></tr>
<tr><td><strong>Existing protobuf infrastructure</strong></td><td>Use Protobuf</td></tr>
<tr><td><strong>Performance critical</strong></td><td>Benchmark both (typically similar)</td></tr>
</tbody></table>
</div><div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-warning"></a>
</div>
<div>
<p>Protobuf-serialized messages are <strong>not</strong> compatible with standard ROS 2 nodes using CDR. Use protobuf when you control both ends of the communication or need its specific features.</p>
</div>
</div>
<h2 id="enabling-protobuf-support"><a class="header" href="#enabling-protobuf-support">Enabling Protobuf Support</a></h2>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<p>Enable protobuf in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ros-z = { version = "0.1", features = ["protobuf"] }
ros-z-msgs = { version = "0.1", features = ["geometry_msgs", "protobuf"] }
prost = "0.13"

[build-dependencies]
prost-build = "0.13"
</code></pre>
<h3 id="build-configuration"><a class="header" href="#build-configuration">Build Configuration</a></h3>
<p>For custom <code>.proto</code> files, add a <code>build.rs</code>:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut config = prost_build::Config::new();
    // Enable serde support for ros-z compatibility
    config.type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]");
    config.compile_protos(&amp;["proto/sensor_data.proto"], &amp;["proto/"])?;
    println!("cargo:rerun-if-changed=proto/sensor_data.proto");
    Ok(())
}</code></pre>
<h2 id="approach-1-ros-messages-with-protobuf"><a class="header" href="#approach-1-ros-messages-with-protobuf">Approach 1: ROS Messages with Protobuf</a></h2>
<p>Use auto-generated ROS message types with protobuf serialization:</p>
<pre><code class="language-rust ignore">use ros_z::msg::ProtobufSerdes;
use ros_z_msgs::proto::geometry_msgs::Vector3 as Vector3Proto;

let ctx = ros_z::context::ZContextBuilder::default().build()?;
let node = ctx.create_node("protobuf_node").build()?;

// Create publisher with protobuf serialization
let pub = node
    .create_pub::&lt;Vector3Proto&gt;("/vector_proto")
    .with_serdes::&lt;ProtobufSerdes&lt;Vector3Proto&gt;&gt;()
    .build()?;

// Publish messages
let msg = Vector3Proto {
    x: 1.0,
    y: 2.0,
    z: 3.0,
};
pub.publish(&amp;msg)?;</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Import from <code>ros_z_msgs::proto::*</code> namespace (not <code>ros_z_msgs::ros::*</code>)</li>
<li>Use <code>.with_serdes::&lt;ProtobufSerdes&lt;T&gt;&gt;()</code> to select protobuf encoding</li>
<li>Message types automatically implement <code>MessageTypeInfo</code> trait</li>
<li>Full type safety and compile-time checking</li>
</ul>
<h2 id="approach-2-custom-protobuf-messages"><a class="header" href="#approach-2-custom-protobuf-messages">Approach 2: Custom Protobuf Messages</a></h2>
<p>Send arbitrary protobuf messages defined in <code>.proto</code> files:</p>
<h3 id="step-1-define-your-message"><a class="header" href="#step-1-define-your-message">Step 1: Define Your Message</a></h3>
<p>Create <code>proto/sensor_data.proto</code>:</p>
<pre><code class="language-protobuf">syntax = "proto3";

package examples;

message SensorData {
    string sensor_id = 1;
    double temperature = 2;
    double humidity = 3;
    int64 timestamp = 4;
}
</code></pre>
<h3 id="step-2-generate-rust-code"><a class="header" href="#step-2-generate-rust-code">Step 2: Generate Rust Code</a></h3>
<p>Configure <code>build.rs</code> as shown above. The build script generates Rust structs at compile time.</p>
<h3 id="step-3-include-generated-code"><a class="header" href="#step-3-include-generated-code">Step 3: Include Generated Code</a></h3>
<pre><code class="language-rust ignore">pub mod sensor_data {
    include!(concat!(env!("OUT_DIR"), "/examples.rs"));
}

use sensor_data::SensorData;</code></pre>
<h3 id="step-4-implement-required-traits"><a class="header" href="#step-4-implement-required-traits">Step 4: Implement Required Traits</a></h3>
<pre><code class="language-rust ignore">use ros_z::{MessageTypeInfo, WithTypeInfo, entity::TypeHash};

impl MessageTypeInfo for SensorData {
    fn type_name() -&gt; &amp;'static str {
        "examples::msg::dds_::SensorData_"
    }

    fn type_hash() -&gt; TypeHash {
        TypeHash::zero()  // For custom protobuf messages
    }
}

impl WithTypeInfo for SensorData {}</code></pre>
<h3 id="step-5-use-in-ros-z"><a class="header" href="#step-5-use-in-ros-z">Step 5: Use in ros-z</a></h3>
<pre><code class="language-rust ignore">let pub = node
    .create_pub::&lt;SensorData&gt;("/sensor_data")
    .with_serdes::&lt;ProtobufSerdes&lt;SensorData&gt;&gt;()
    .build()?;

let msg = SensorData {
    sensor_id: "sensor_01".to_string(),
    temperature: 23.5,
    humidity: 45.0,
    timestamp: 1234567890,
};

pub.publish(&amp;msg)?;</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>The <code>protobuf_demo</code> example demonstrates both approaches:</p>
<pre><code class="language-rust ignore">use clap::Parser;
use protobuf_demo::{run_pubsub_demo, run_service_client, run_service_server};
use ros_z::{Builder, Result, context::ZContextBuilder};

#[derive(Debug, Parser)]
#[command(
    name = "protobuf_demo",
    about = "Protobuf demonstration for ros-z - pub/sub and services"
)]
struct Args {
    /// Mode to run: pubsub, service-server, service-client, or combined
    #[arg(short, long, default_value = "pubsub")]
    mode: String,

    /// Service name (for service modes)
    #[arg(long, default_value = "/calculator")]
    service: String,

    /// Maximum number of messages/requests (0 for unlimited)
    #[arg(short = 'n', long, default_value = "3")]
    count: usize,

    /// Zenoh session mode (peer, client, router)
    #[arg(long, default_value = "peer")]
    zenoh_mode: String,

    /// Zenoh router endpoint to connect to
    #[arg(short, long)]
    endpoint: Option&lt;String&gt;,
}

fn main() -&gt; Result&lt;()&gt; {
    let args = Args::parse();

    // Initialize logging
    zenoh::init_log_from_env_or("info");

    // Create the ROS-Z context
    let ctx = if let Some(ref e) = args.endpoint {
        ZContextBuilder::default()
            .with_mode(&amp;args.zenoh_mode)
            .with_connect_endpoints([e.clone()])
            .build()?
    } else {
        ZContextBuilder::default()
            .with_mode(&amp;args.zenoh_mode)
            .build()?
    };

    let max_count = if args.count == 0 {
        None
    } else {
        Some(args.count)
    };

    match args.mode.as_str() {
        "pubsub" =&gt; {
            run_pubsub_demo(ctx, max_count)?;
        }
        "service-server" =&gt; {
            run_service_server(ctx, &amp;args.service, max_count)?;
        }
        "service-client" =&gt; {
            let operations = vec![
                ("add", 10.0, 5.0),
                ("subtract", 10.0, 5.0),
                ("multiply", 10.0, 5.0),
                ("divide", 10.0, 5.0),
                ("divide", 10.0, 0.0), // This will fail
            ];
            run_service_client(ctx, &amp;args.service, operations)?;
        }
        "combined" =&gt; {
            println!("\n=== Running Combined Demo ===\n");

            // Create separate contexts for server and client
            let server_ctx = if let Some(e) = args.endpoint.clone() {
                ZContextBuilder::default()
                    .with_mode(&amp;args.zenoh_mode)
                    .with_connect_endpoints([e])
                    .build()?
            } else {
                ZContextBuilder::default()
                    .with_mode(&amp;args.zenoh_mode)
                    .build()?
            };

            let service_name = args.service.clone();

            // Run server in background thread
            let _server_handle =
                std::thread::spawn(move || run_service_server(server_ctx, &amp;service_name, Some(5)));

            // Give server time to start
            std::thread::sleep(std::time::Duration::from_millis(500));

            // Run client
            let operations = vec![
                ("add", 10.0, 5.0),
                ("subtract", 10.0, 5.0),
                ("multiply", 10.0, 5.0),
                ("divide", 10.0, 5.0),
                ("divide", 10.0, 0.0),
            ];
            run_service_client(ctx, &amp;args.service, operations)?;
        }
        _ =&gt; {
            eprintln!("Unknown mode: {}", args.mode);
            eprintln!("Valid modes: pubsub, service-server, service-client, combined");
            std::process::exit(1);
        }
    }

    Ok(())
}</code></pre>
<h3 id="running-the-demo"><a class="header" href="#running-the-demo">Running the Demo</a></h3>
<pre><code class="language-bash"># Navigate to the demo directory
cd ros-z/examples/protobuf_demo

# Run the example
cargo run
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code class="language-text">=== Protobuf Serialization Demo ===
This demonstrates two ways to use protobuf with ros-z:
1. ROS messages with protobuf serialization (from ros-z-msgs)
2. Custom protobuf messages (from .proto files)
=====================================================

--- Part 1: ROS geometry_msgs/Vector3 with Protobuf ---
Publishing ROS Vector3 messages...

  Published Vector3: x=0, y=0, z=0
  Published Vector3: x=1, y=2, z=3
  Published Vector3: x=2, y=4, z=6

--- Part 2: Custom SensorData message (pure protobuf) ---
Publishing custom SensorData messages...

  Published SensorData: id=sensor_0, temp=20.0°C, humidity=45.0%, ts=1234567890
  Published SensorData: id=sensor_1, temp=20.5°C, humidity=47.0%, ts=1234567891
  Published SensorData: id=sensor_2, temp=21.0°C, humidity=49.0%, ts=1234567892

Successfully demonstrated both protobuf approaches!
</code></pre>
<h2 id="subscribers-with-protobuf"><a class="header" href="#subscribers-with-protobuf">Subscribers with Protobuf</a></h2>
<p>Receive protobuf-encoded messages:</p>
<pre><code class="language-rust ignore">use ros_z::msg::ProtobufSerdes;

let sub = node
    .create_sub::&lt;Vector3Proto&gt;("/vector_proto")
    .with_serdes::&lt;ProtobufSerdes&lt;Vector3Proto&gt;&gt;()
    .build()?;

loop {
    let msg = sub.recv()?;
    println!("Received: x={}, y={}, z={}", msg.x, msg.y, msg.z);
}</code></pre>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-important"></a>
</div>
<div>
<p>Publishers and subscribers must use the <strong>same serialization format</strong>. A protobuf publisher requires a protobuf subscriber.</p>
</div>
</div>
<h2 id="services-with-protobuf"><a class="header" href="#services-with-protobuf">Services with Protobuf</a></h2>
<p>Both request and response use protobuf encoding:</p>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<pre><code class="language-rust ignore">let service = node
    .create_service::&lt;MyService&gt;("/my_service")
    .with_serdes::&lt;ProtobufSerdes&lt;MyServiceRequest&gt;, ProtobufSerdes&lt;MyServiceResponse&gt;&gt;()
    .build()?;

loop {
    let (key, request) = service.take_request()?;
    let response = process_request(&amp;request);
    service.send_response(&amp;response, &amp;key)?;
}</code></pre>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<pre><code class="language-rust ignore">let client = node
    .create_client::&lt;MyService&gt;("/my_service")
    .with_serdes::&lt;ProtobufSerdes&lt;MyServiceRequest&gt;, ProtobufSerdes&lt;MyServiceResponse&gt;&gt;()
    .build()?;

client.send_request(&amp;request)?;
let response = client.take_response()?;</code></pre>
<h2 id="available-ros-messages"><a class="header" href="#available-ros-messages">Available ROS Messages</a></h2>
<p>When ros-z-msgs is built with <code>protobuf</code> feature, it generates protobuf versions of ROS messages:</p>
<pre><code class="language-rust ignore">// Import from proto namespace
use ros_z_msgs::proto::std_msgs::String as StringProto;
use ros_z_msgs::proto::geometry_msgs::{Point, Pose, Twist};
use ros_z_msgs::proto::sensor_msgs::{LaserScan, Image};</code></pre>
<p><strong>Namespace mapping:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Namespace</th><th>Use</th></tr></thead><tbody>
<tr><td><strong>CDR</strong></td><td><code>ros_z_msgs::ros::*</code></td><td>ROS 2 interop</td></tr>
<tr><td><strong>Protobuf</strong></td><td><code>ros_z_msgs::proto::*</code></td><td>Protobuf encoding</td></tr>
</tbody></table>
</div>
<h2 id="type-information"><a class="header" href="#type-information">Type Information</a></h2>
<h3 id="ros-messages"><a class="header" href="#ros-messages">ROS Messages</a></h3>
<p>Auto-generated messages from ros-z-msgs include <code>MessageTypeInfo</code>:</p>
<pre><code class="language-rust ignore">// No manual implementation needed
use ros_z_msgs::proto::geometry_msgs::Vector3;
// Vector3 already implements MessageTypeInfo</code></pre>
<h3 id="custom-protobuf-messages"><a class="header" href="#custom-protobuf-messages">Custom Protobuf Messages</a></h3>
<p>Manual implementation required:</p>
<pre><code class="language-rust ignore">impl MessageTypeInfo for MyProtoMessage {
    fn type_name() -&gt; &amp;'static str {
        // Follow ROS naming convention
        "my_package::msg::dds_::MyProtoMessage_"
    }

    fn type_hash() -&gt; TypeHash {
        // Use zero for custom protobuf messages
        TypeHash::zero()
    }
}

impl WithTypeInfo for MyProtoMessage {}</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-note"></a>
</div>
<div>
<p><code>TypeHash::zero()</code> indicates the message doesn't have ROS 2 type compatibility. This is fine for ros-z-to-ros-z communication.</p>
</div>
</div>
<h2 id="protobuf-vs-cdr-comparison"><a class="header" href="#protobuf-vs-cdr-comparison">Protobuf vs CDR Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>CDR</th><th>Protobuf</th></tr></thead><tbody>
<tr><td><strong>ROS 2 Compatibility</strong></td><td>✅ Full</td><td>❌ None</td></tr>
<tr><td><strong>Schema Evolution</strong></td><td>❌ Limited</td><td>✅ Excellent</td></tr>
<tr><td><strong>Cross-language</strong></td><td>ROS 2 only</td><td>✅ Universal</td></tr>
<tr><td><strong>Tooling</strong></td><td>ROS ecosystem</td><td>✅ Protobuf ecosystem</td></tr>
<tr><td><strong>Message Size</strong></td><td>Efficient</td><td>Efficient</td></tr>
<tr><td><strong>Setup Complexity</strong></td><td>Simple</td><td>Moderate</td></tr>
<tr><td><strong>ros-z Support</strong></td><td>Default</td><td>Requires feature flag</td></tr>
</tbody></table>
</div>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="mixed-serialization"><a class="header" href="#mixed-serialization">Mixed Serialization</a></h3>
<p>Different topics can use different formats:</p>
<pre><code class="language-rust ignore">// CDR for ROS 2 compatibility
let ros_pub = node
    .create_pub::&lt;RosString&gt;("/ros_topic")
    .build()?;  // CDR is default

// Protobuf for schema evolution
let proto_pub = node
    .create_pub::&lt;ProtoString&gt;("/proto_topic")
    .with_serdes::&lt;ProtobufSerdes&lt;ProtoString&gt;&gt;()
    .build()?;</code></pre>
<h3 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h3>
<p>Gradual migration from CDR to protobuf:</p>
<ol>
<li>Add protobuf feature to dependencies</li>
<li>Create protobuf topics with new names</li>
<li>Run both CDR and protobuf publishers temporarily</li>
<li>Migrate subscribers to protobuf</li>
<li>Deprecate CDR topics</li>
</ol>
<h2 id="build-integration"><a class="header" href="#build-integration">Build Integration</a></h2>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code class="language-text">my_ros_project/
├── proto/
│   ├── sensor_data.proto
│   └── robot_status.proto
├── src/
│   └── main.rs
├── build.rs
└── Cargo.toml
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = "my_ros_project"
version = "0.1.0"
edition = "2021"

[dependencies]
ros-z = { version = "0.1", features = ["protobuf"] }
ros-z-msgs = { version = "0.1", features = ["geometry_msgs", "protobuf"] }
prost = "0.13"
serde = { version = "1.0", features = ["derive"] }

[build-dependencies]
prost-build = "0.13"
</code></pre>
<h3 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h3>
<pre><code class="language-rust ignore">use std::io::Result;

fn main() -&gt; Result&lt;()&gt; {
    let mut config = prost_build::Config::new();

    // Enable serde for ros-z compatibility
    config.type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]");

    // Compile all proto files
    config.compile_protos(
        &amp;[
            "proto/sensor_data.proto",
            "proto/robot_status.proto",
        ],
        &amp;["proto/"]
    )?;

    // Rebuild if proto files change
    println!("cargo:rerun-if-changed=proto/");

    Ok(())
}</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<details id="admonition-error-protobuf-feature-not-enabled" class="admonition admonish-question" role="note" aria-labelledby="admonition-error-protobuf-feature-not-enabled-title">
<summary class="admonition-title">
<div id="admonition-error-protobuf-feature-not-enabled-title">
<p>Error: protobuf feature not enabled</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-error-protobuf-feature-not-enabled"></a>
</summary>
<div>
<p>This error occurs when you try to use protobuf serialization without enabling the feature flag.</p>
<p><strong>Solution:</strong></p>
<p>Enable the protobuf feature in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ros-z = { version = "0.1", features = ["protobuf"] }
ros-z-msgs = { version = "0.1", features = ["geometry_msgs", "protobuf"] }
</code></pre>
</div>
</details>
<details id="admonition-error-messagetypeinfo-not-implemented" class="admonition admonish-question" role="note" aria-labelledby="admonition-error-messagetypeinfo-not-implemented-title">
<summary class="admonition-title">
<div id="admonition-error-messagetypeinfo-not-implemented-title">
<p>Error: MessageTypeInfo not implemented</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-error-messagetypeinfo-not-implemented"></a>
</summary>
<div>
<p>Custom protobuf messages need to implement required ros-z traits.</p>
<p><strong>Solution:</strong></p>
<p>Implement the required traits for your custom message:</p>
<pre><code class="language-rust ignore">use ros_z::{MessageTypeInfo, WithTypeInfo, entity::TypeHash};

impl MessageTypeInfo for MyMessage {
    fn type_name() -&gt; &amp;'static str {
        "package::msg::dds_::MyMessage_"
    }

    fn type_hash() -&gt; TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for MyMessage {}</code></pre>
</div>
</details>
<details id="admonition-build-fails-with-prost-errors" class="admonition admonish-question" role="note" aria-labelledby="admonition-build-fails-with-prost-errors-title">
<summary class="admonition-title">
<div id="admonition-build-fails-with-prost-errors-title">
<p>Build fails with prost errors</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-build-fails-with-prost-errors"></a>
</summary>
<div>
<p>Version mismatches between prost dependencies can cause build failures.</p>
<p><strong>Solution:</strong></p>
<p>Ensure prost versions match in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
prost = "0.13"

[build-dependencies]
prost-build = "0.13"
</code></pre>
<p>If issues persist, try:</p>
<pre><code class="language-bash">cargo clean
cargo build
</code></pre>
</div>
</details>
<details id="admonition-messages-not-receiving" class="admonition admonish-question" role="note" aria-labelledby="admonition-messages-not-receiving-title">
<summary class="admonition-title">
<div id="admonition-messages-not-receiving-title">
<p>Messages not receiving</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-messages-not-receiving"></a>
</summary>
<div>
<p>Publisher and subscriber must use the same serialization format.</p>
<p><strong>Solution:</strong></p>
<p>Verify both sides use protobuf serialization:</p>
<pre><code class="language-rust ignore">// Publisher
let pub = node
    .create_pub::&lt;MyMessage&gt;("/topic")
    .with_serdes::&lt;ProtobufSerdes&lt;MyMessage&gt;&gt;()
    .build()?;

// Subscriber
let sub = node
    .create_sub::&lt;MyMessage&gt;("/topic")
    .with_serdes::&lt;ProtobufSerdes&lt;MyMessage&gt;&gt;()
    .build()?;</code></pre>
<p><strong>Note:</strong> A protobuf publisher cannot communicate with a CDR subscriber and vice versa.</p>
</div>
</details>
<details id="admonition-proto-file-not-found-during-build" class="admonition admonish-question" role="note" aria-labelledby="admonition-proto-file-not-found-during-build-title">
<summary class="admonition-title">
<div id="admonition-proto-file-not-found-during-build-title">
<p>Proto file not found during build</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-proto-file-not-found-during-build"></a>
</summary>
<div>
<p>The build script cannot locate your <code>.proto</code> files.</p>
<p><strong>Solution:</strong></p>
<p>Verify the path in your <code>build.rs</code>:</p>
<pre><code class="language-rust ignore">config.compile_protos(
    &amp;["proto/sensor_data.proto"],  // Check this path
    &amp;["proto/"]                     // Check include directory
)?;</code></pre>
<p>Ensure the proto directory exists:</p>
<pre><code class="language-bash">ls proto/sensor_data.proto
</code></pre>
</div>
</details>
<details id="admonition-generated-code-not-found" class="admonition admonish-question" role="note" aria-labelledby="admonition-generated-code-not-found-title">
<summary class="admonition-title">
<div id="admonition-generated-code-not-found-title">
<p>Generated code not found</p>
</div>
<a class="admonition-anchor-link" href="chapters/protobuf.html#admonition-generated-code-not-found"></a>
</summary>
<div>
<p>The build script generated code but you can't import it.</p>
<p><strong>Solution:</strong></p>
<p>Ensure you're including from the correct location:</p>
<pre><code class="language-rust ignore">pub mod sensor_data {
    include!(concat!(env!("OUT_DIR"), "/examples.rs"));
}</code></pre>
<p>The filename after <code>OUT_DIR</code> should match your package name in the <code>.proto</code> file:</p>
<pre><code class="language-protobuf">package examples;  // Generates examples.rs
</code></pre>
</div>
</details>
<h2 id="resources-5"><a class="header" href="#resources-5">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - Understanding message architecture</li>
<li><strong><a href="chapters/./custom_messages.html">Custom Messages</a></strong> - Manual message implementation</li>
<li><strong><a href="https://protobuf.dev/">Protobuf Documentation</a></strong> - Official protobuf guide</li>
<li><strong><a href="https://docs.rs/prost/">prost Crate</a></strong> - Rust protobuf library</li>
</ul>
<p><strong>Use protobuf when you need schema evolution or cross-language compatibility beyond the ROS 2 ecosystem. Stick with CDR for standard ROS 2 interoperability.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros-z-console"><a class="header" href="#ros-z-console">ros-z-console</a></h1>
<p><strong>ros-z-console</strong> is a monitoring tool for ROS 2 systems built on Zenoh.
It provides real-time graph inspection, dataflow monitoring, and metrics
collection through two interfaces: an interactive TUI (Terminal User Interface)
and a headless JSON streaming mode.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-tip"></a>
</div>
<div>
<p>ros-z-console uses zero-interference monitoring via pure Zenoh subscribers -
it never pollutes the ROS graph with its own presence.</p>
</div>
</div>
<h2 id="network-topology"><a class="header" href="#network-topology">Network Topology</a></h2>
<p>ros-z-console connects to the ROS 2 graph via a Zenoh router. All ROS 2 nodes
using <code>rmw_zenoh_cpp</code> communicate through the same router, enabling
ros-z-console to observe the entire system.</p>
<pre class="mermaid">graph LR
    subgraph &quot;ROS 2 System&quot;
        T[talker&lt;br/&gt;rmw_zenoh_cpp]
        L[listener&lt;br/&gt;rmw_zenoh_cpp]
    end

    R[Zenoh Router&lt;br/&gt;rmw_zenohd]
    C[ros-z-console]

    T &lt;--&gt; R
    L &lt;--&gt; R
    C --&gt; R

    style C fill:#2ecc71,color:#fff
    style R fill:#3498db,color:#fff
</pre>
<h2 id="quick-start-monitoring-demo_nodes_cpp"><a class="header" href="#quick-start-monitoring-demo_nodes_cpp">Quick Start: Monitoring demo_nodes_cpp</a></h2>
<p>This example shows ros-z-console monitoring the classic talker/listener demo from <code>demo_nodes_cpp</code>.</p>
<p><strong>Terminal 1 - Start the Zenoh router:</strong></p>
<pre><code class="language-bash">ros2 run rmw_zenoh_cpp rmw_zenohd
</code></pre>
<p><strong>Terminal 2 - Start the talker:</strong></p>
<pre><code class="language-bash">export RMW_IMPLEMENTATION=rmw_zenoh_cpp
ros2 run demo_nodes_cpp talker
</code></pre>
<p><strong>Terminal 3 - Start the listener:</strong></p>
<pre><code class="language-bash">export RMW_IMPLEMENTATION=rmw_zenoh_cpp
ros2 run demo_nodes_cpp listener
</code></pre>
<p><strong>Terminal 4 - Monitor with ros-z-console:</strong></p>
<pre><code class="language-bash">ros-z-console tcp/127.0.0.1:7447 0
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-success"></a>
</div>
<div>
<p>You should see the <code>/chatter</code> topic, the <code>talker</code> and <code>listener</code> nodes, and
their services appear in ros-z-console. Use the TUI to browse topics, check
message rates, and inspect QoS settings.</p>
</div>
</div>
<h2 id="building-and-running"><a class="header" href="#building-and-running">Building and Running</a></h2>
<pre><code class="language-bash"># Build the console
cargo build -p ros-z-console --release

# Run with default settings (TUI mode)
ros-z-console tcp/127.0.0.1:7447 0

# Headless JSON streaming
ros-z-console --headless --json tcp/127.0.0.1:7447 0

# Echo messages from a topic
ros-z-console --headless --echo /chatter tcp/127.0.0.1:7447 0

# Echo multiple topics with JSON output
ros-z-console --headless --json --echo /chatter --echo /cmd_vel tcp/127.0.0.1:7447 0

# Export graph snapshot and exit
ros-z-console --export graph.json tcp/127.0.0.1:7447 0
</code></pre>
<h2 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h2>
<pre><code class="language-bash">ros-z-console [OPTIONS] [ROUTER] [DOMAIN]
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ROUTER</code></td><td><code>tcp/127.0.0.1:7447</code></td><td>Zenoh router address</td></tr>
<tr><td><code>DOMAIN</code></td><td><code>0</code></td><td>ROS domain ID</td></tr>
</tbody></table>
</div>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--tui</code></td><td>Enable TUI interface (default if no other mode specified)</td></tr>
<tr><td><code>--headless</code></td><td>Headless mode: stream events to stdout</td></tr>
<tr><td><code>--json</code></td><td>Output structured JSON logs</td></tr>
<tr><td><code>--debug</code></td><td>Enable debug logging</td></tr>
<tr><td><code>--echo &lt;TOPIC&gt;</code></td><td>Subscribe to and display messages from topic (can be used multiple times)</td></tr>
<tr><td><code>--export &lt;PATH&gt;</code></td><td>Export current state and exit (supports .json, .dot, .csv)</td></tr>
</tbody></table>
</div>
<h2 id="modes"><a class="header" href="#modes">Modes</a></h2>
<h3 id="tui-mode-default"><a class="header" href="#tui-mode-default">TUI Mode (Default)</a></h3>
<p>The interactive terminal interface provides:</p>
<ul>
<li><strong>Panel Navigation</strong> - Browse Topics, Services, Nodes, and Measurements</li>
<li><strong>Filter Mode</strong> - Press <code>/</code> to activate type-ahead search with highlighting</li>
<li><strong>Rate Monitoring</strong> - Quick rate check with <code>r</code> key (cached for 30s)</li>
<li><strong>Measurement Panel</strong> - Press <code>m</code> for detailed measurements with:
<ul>
<li>Real-time metrics (msg/s, KB/s, average payload)</li>
<li>60-second time-series chart</li>
<li>SQLite storage (<code>ros-z-metrics.db</code>)</li>
</ul>
</li>
<li><strong>Detail Drilling</strong> - Press <code>Enter</code> to expand sections with QoS profiles</li>
<li><strong>Export</strong> - Press <code>e</code> to export metrics to CSV</li>
<li><strong>Help Overlay</strong> - Press <code>?</code> to toggle help</li>
</ul>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-note"></a>
</div>
<div>
<p>TUI mode requires a terminal that supports ANSI escape codes. Most modern terminals work out of the box.</p>
</div>
</div>
<h3 id="headless-mode"><a class="header" href="#headless-mode">Headless Mode</a></h3>
<p>Headless mode streams events to stdout, making it ideal for:</p>
<ul>
<li>CI/CD pipelines</li>
<li>Log aggregation systems</li>
<li>AI-powered analysis</li>
<li>Scripted monitoring</li>
</ul>
<p><strong>Human-readable output:</strong></p>
<pre><code class="language-bash">ros-z-console --headless tcp/127.0.0.1:7447 0
</code></pre>
<pre><code class="language-console">Discovered Topics:
  /chatter (std_msgs/msg/String)
  /cmd_vel (geometry_msgs/msg/Twist)
Discovered Nodes:
  /talker
  /listener
[2026-01-21 10:30:00] Topic discovered: /rosout (rcl_interfaces/msg/Log)
</code></pre>
<p><strong>JSON streaming output:</strong></p>
<pre><code class="language-bash">ros-z-console --headless --json tcp/127.0.0.1:7447 0
</code></pre>
<pre><code class="language-json">{"timestamp":"...","event":"initial_state","domain_id":0,"topics":[...],"nodes":[...],"services":[...]}
{"TopicDiscovered":{"topic":"/chatter","type_name":"std_msgs/msg/String","timestamp":"..."}}
{"NodeDiscovered":{"namespace":"/","name":"talker","timestamp":"..."}}
</code></pre>
<h2 id="dynamic-topic-echo"><a class="header" href="#dynamic-topic-echo">Dynamic Topic Echo</a></h2>
<p>ros-z-console can subscribe to and display messages from <strong>any ROS 2 topic</strong>
without compile-time knowledge of message types. This is powered by dynamic
schema discovery using the ROS 2 Type Description service (REP-2016).</p>
<div id="admonition-universal-message-support" class="admonition admonish-success" role="note" aria-labelledby="admonition-universal-message-support-title">
<div class="admonition-title">
<div id="admonition-universal-message-support-title">
<p>Universal Message Support</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-universal-message-support"></a>
</div>
<div>
<p>Echo works with all ROS 2 message types: primitives, nested messages, arrays, and custom types. No recompilation needed!</p>
</div>
</div>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>When you echo a topic, ros-z-console:</p>
<ol>
<li><strong>Discovers publishers</strong> on the topic using graph monitoring</li>
<li><strong>Queries the Type Description service</strong> from the publisher's node</li>
<li><strong>Retrieves the message schema</strong> (field names, types, and layout)</li>
<li><strong>Creates a dynamic subscriber</strong> using the discovered schema</li>
<li><strong>Deserializes and displays messages</strong> in real-time</li>
</ol>
<pre class="mermaid">sequenceDiagram
    participant C as ros-z-console
    participant G as Graph
    participant P as Publisher Node
    participant Z as Zenoh

    C-&gt;&gt;G: Find publishers for /chatter
    G--&gt;&gt;C: Publisher: talker node
    C-&gt;&gt;P: GetTypeDescription(std_msgs/msg/String)
    P--&gt;&gt;C: Schema + Type Hash
    C-&gt;&gt;Z: Subscribe with dynamic schema
    Z--&gt;&gt;C: Message data (CDR)
    C-&gt;&gt;C: Deserialize &amp; display
</pre>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<p><strong>Echo a single topic:</strong></p>
<pre><code class="language-bash">ros-z-console --headless --echo /chatter
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">=== Subscribed to /chatter ===
Type: std_msgs/msg/String
Hash: RIHS01_df668c740482bbd48fb39d76a70dfd4bd59db1288021743503259e948f6b1a18
Fields: ["data"]

=== /chatter ===
data: "Hello World: 0"

=== /chatter ===
data: "Hello World: 1"
</code></pre>
<p><strong>JSON output mode:</strong></p>
<pre><code class="language-bash">ros-z-console --headless --json --echo /chatter
</code></pre>
<pre><code class="language-json">{"event":"topic_subscribed","topic":"/chatter","type_name":"std_msgs/msg/String","type_hash":"RIHS01_df668...","fields":["data"]}
{"event":"message_received","topic":"/chatter","type":"std_msgs/msg/String","data":{"data":"Hello World: 0"}}
{"event":"message_received","topic":"/chatter","type":"std_msgs/msg/String","data":{"data":"Hello World: 1"}}
</code></pre>
<h3 id="multiple-topics"><a class="header" href="#multiple-topics">Multiple Topics</a></h3>
<p>Echo multiple topics simultaneously:</p>
<pre><code class="language-bash">ros-z-console --headless --echo /chatter --echo /cmd_vel --echo /odom
</code></pre>
<p>Each topic is independently discovered and subscribed with its own dynamic schema.</p>
<h3 id="supported-message-types"><a class="header" href="#supported-message-types">Supported Message Types</a></h3>
<h4 id="primitives"><a class="header" href="#primitives">Primitives</a></h4>
<pre><code class="language-bash"># String messages
ros-z-console --headless --echo /chatter

# Numeric types
ros-z-console --headless --echo /count      # Int32
ros-z-console --headless --echo /sensor     # Float64
</code></pre>
<h4 id="nested-messages"><a class="header" href="#nested-messages">Nested Messages</a></h4>
<pre><code class="language-bash"># Twist (linear + angular vectors)
ros-z-console --headless --echo /cmd_vel
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">=== /cmd_vel ===
linear:
  x: 1.0
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.5
</code></pre>
<h4 id="arrays-and-sequences"><a class="header" href="#arrays-and-sequences">Arrays and Sequences</a></h4>
<pre><code class="language-bash"># Point cloud or array messages
ros-z-console --headless --echo /scan
</code></pre>
<h3 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h3>
<h4 id="debugging-message-content"><a class="header" href="#debugging-message-content">Debugging Message Content</a></h4>
<p>Quickly inspect what's actually being published:</p>
<pre><code class="language-bash">ros-z-console --headless --echo /diagnostics
</code></pre>
<h4 id="data-analysis"><a class="header" href="#data-analysis">Data Analysis</a></h4>
<p>Pipe JSON output to analysis tools:</p>
<pre><code class="language-bash">ros-z-console --headless --json --echo /pose | \
  jq -r 'select(.event=="message_received") | .data.position.x'
</code></pre>
<h4 id="recording-specific-fields"><a class="header" href="#recording-specific-fields">Recording Specific Fields</a></h4>
<p>Extract and log specific data:</p>
<pre><code class="language-bash">ros-z-console --headless --json --echo /sensor_data | \
  jq '.data.temperature' &gt;&gt; temps.log
</code></pre>
<h4 id="message-validation"><a class="header" href="#message-validation">Message Validation</a></h4>
<p>Verify message structure and content during development:</p>
<pre><code class="language-bash"># Check if messages match expected schema
ros-z-console --headless --json --echo /my_custom_topic | \
  jq '.data | keys'
</code></pre>
<h3 id="example-monitoring-robot-telemetry"><a class="header" href="#example-monitoring-robot-telemetry">Example: Monitoring Robot Telemetry</a></h3>
<p>Monitor multiple robot topics simultaneously:</p>
<pre><code class="language-bash">#!/bin/bash
# Monitor robot state
ros-z-console --headless \
  --echo /cmd_vel \
  --echo /odom \
  --echo /battery_state \
  --echo /diagnostics \
  &gt; robot_state.log
</code></pre>
<h3 id="integration-with-standard-ros-2"><a class="header" href="#integration-with-standard-ros-2">Integration with Standard ROS 2</a></h3>
<p>ros-z-console echo works seamlessly with standard ROS 2 nodes:</p>
<pre><code class="language-bash"># Terminal 1: Standard ROS 2 publisher
ros2 run demo_nodes_cpp talker

# Terminal 2: ros-z-console subscriber
ros-z-console --headless --echo /chatter
</code></pre>
<div id="admonition-type-hash-matching" class="admonition admonish-info" role="note" aria-labelledby="admonition-type-hash-matching-title">
<div class="admonition-title">
<div id="admonition-type-hash-matching-title">
<p>Type Hash Matching</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-type-hash-matching"></a>
</div>
<div>
<p>ros-z-console uses RIHS01 type hashes to ensure message compatibility. If type hashes don't match, the subscription will fail with a clear error message.</p>
</div>
</div>
<h3 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h3>
<h4 id="with-debug-logging"><a class="header" href="#with-debug-logging">With Debug Logging</a></h4>
<p>Enable detailed logging to troubleshoot discovery issues:</p>
<pre><code class="language-bash">RUST_LOG=ros_z=debug ros-z-console --headless --echo /chatter
</code></pre>
<p><strong>Debug output shows:</strong></p>
<ul>
<li>Publisher discovery attempts</li>
<li>Type description service queries</li>
<li>Schema parsing details</li>
<li>Type hash validation</li>
</ul>
<h4 id="custom-timeout"><a class="header" href="#custom-timeout">Custom Timeout</a></h4>
<p>If schema discovery is slow, you can adjust timeouts in the code (default: 5 seconds).</p>
<h3 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h3>
<p><strong>No publishers found:</strong></p>
<pre><code class="language-text">Failed to subscribe to /my_topic: Schema discovery failed: No publishers found for topic: /my_topic
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Verify the topic exists: <code>ros2 topic list</code></li>
<li>Check the topic is being published: <code>ros2 topic hz /my_topic</code></li>
<li>Ensure rmw_zenohd is running</li>
<li>Wait for publisher to fully start (may take a few seconds)</li>
</ul>
<p><strong>Type hash mismatch:</strong></p>
<pre><code class="language-text">Failed to subscribe to /chatter: Type hash mismatch
</code></pre>
<p>This occurs when the publisher and subscriber have different message definitions. Ensure both are using the same ROS 2 distribution and package versions.</p>
<h3 id="comparison-with-ros2-topic-echo"><a class="header" href="#comparison-with-ros2-topic-echo">Comparison with ros2 topic echo</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>ros-z-console</th><th>ros2 topic echo</th></tr></thead><tbody>
<tr><td><strong>Compilation</strong></td><td>No recompilation needed</td><td>Requires message packages installed</td></tr>
<tr><td><strong>Custom types</strong></td><td>Automatic discovery</td><td>Must have .msg files available</td></tr>
<tr><td><strong>Multiple topics</strong></td><td>Single command</td><td>Need multiple processes</td></tr>
<tr><td><strong>JSON output</strong></td><td>Built-in structured format</td><td>Requires additional parsing</td></tr>
<tr><td><strong>Performance</strong></td><td>Zenoh pub/sub (very fast)</td><td>DDS overhead</td></tr>
<tr><td><strong>Filtering</strong></td><td>Easy with jq on JSON</td><td>Manual parsing needed</td></tr>
</tbody></table>
</div>
<h3 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h3>
<ul>
<li><strong>Latency:</strong> Sub-millisecond after initial discovery (~5 seconds)</li>
<li><strong>Throughput:</strong> Handles 1000+ messages/second per topic</li>
<li><strong>Memory:</strong> ~1KB per unique message schema (cached globally)</li>
<li><strong>CPU:</strong> Minimal - only active when messages arrive</li>
</ul>
<div id="admonition-schema-caching" class="admonition admonish-tip" role="note" aria-labelledby="admonition-schema-caching-title">
<div class="admonition-title">
<div id="admonition-schema-caching-title">
<p>Schema Caching</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-schema-caching"></a>
</div>
<div>
<p>Message schemas are cached in a global registry. Once a type is discovered, subsequent subscriptions to topics with the same type are instant.</p>
</div>
</div>
<h2 id="export-formats"><a class="header" href="#export-formats">Export Formats</a></h2>
<p>Export the current graph state with the <code>--export</code> flag:</p>
<h3 id="json-export"><a class="header" href="#json-export">JSON Export</a></h3>
<pre><code class="language-bash">ros-z-console --export graph.json tcp/127.0.0.1:7447 0
</code></pre>
<p>Produces a structured JSON file with topics, nodes, services, and their relationships:</p>
<pre><code class="language-json">{
  "timestamp": "2026-01-21T10:30:00Z",
  "domain_id": 0,
  "topics": [
    {"name": "/chatter", "type": "std_msgs/msg/String", "publishers": 1, "subscribers": 1}
  ],
  "nodes": [
    {"name": "talker", "namespace": "/"}
  ],
  "services": []
}
</code></pre>
<h3 id="graphviz-dot-export"><a class="header" href="#graphviz-dot-export">GraphViz DOT Export</a></h3>
<pre><code class="language-bash">ros-z-console --export graph.dot tcp/127.0.0.1:7447 0
dot -Tpng graph.dot -o graph.png
</code></pre>
<p>Generates a visual graph representation with:</p>
<ul>
<li>Nodes as blue boxes</li>
<li>Topics as green ellipses</li>
<li>Publisher edges in blue</li>
<li>Subscriber edges in green</li>
</ul>
<h3 id="csv-export"><a class="header" href="#csv-export">CSV Export</a></h3>
<pre><code class="language-bash">ros-z-console --export metrics.csv tcp/127.0.0.1:7447 0
</code></pre>
<p>Exports collected metrics history:</p>
<pre><code class="language-csv">timestamp,topic,rate_hz,bandwidth_kbps,avg_payload_bytes
2026-01-21T10:30:00Z,/chatter,10.5,2.3,220
</code></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<p>ros-z-console tracks these system events:</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody>
<tr><td><code>TopicDiscovered</code></td><td>New topic detected in the graph</td></tr>
<tr><td><code>TopicRemoved</code></td><td>Topic no longer present</td></tr>
<tr><td><code>NodeDiscovered</code></td><td>New node joined the graph</td></tr>
<tr><td><code>NodeRemoved</code></td><td>Node left the graph</td></tr>
<tr><td><code>ServiceDiscovered</code></td><td>New service available</td></tr>
<tr><td><code>RateMeasured</code></td><td>Rate measurement completed</td></tr>
<tr><td><code>MetricsSnapshot</code></td><td>Periodic summary of graph state</td></tr>
</tbody></table>
</div>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Create a <code>ros-z-console.json</code> or <code>.ros-z-console.json</code> file:</p>
<pre><code class="language-json">{
  "cache_ttl_seconds": 30,
  "rate_cache_ttl_seconds": 30,
  "graph_cache_update_ms": 100
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cache_ttl_seconds</code></td><td>30</td><td>General cache time-to-live</td></tr>
<tr><td><code>rate_cache_ttl_seconds</code></td><td>30</td><td>How long rate measurements are cached</td></tr>
<tr><td><code>graph_cache_update_ms</code></td><td>100</td><td>Graph refresh interval in milliseconds</td></tr>
</tbody></table>
</div>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="pipe-to-jq-for-filtering"><a class="header" href="#pipe-to-jq-for-filtering">Pipe to jq for filtering</a></h3>
<pre><code class="language-bash"># Filter for topic discovery events
ros-z-console --headless --json | jq 'select(.TopicDiscovered != null)'

# Extract specific message fields
ros-z-console --headless --json --echo /pose | \
  jq -r 'select(.event=="message_received") | .data.position'
</code></pre>
<h3 id="monitor-specific-topics"><a class="header" href="#monitor-specific-topics">Monitor specific topics</a></h3>
<pre><code class="language-bash"># Watch for messages on specific topic
ros-z-console --headless --json | grep -E '"topic":"/cmd_vel"'

# Echo and filter by field value
ros-z-console --headless --json --echo /sensor | \
  jq 'select(.data.temperature &gt; 50)'
</code></pre>
<h3 id="continuous-logging"><a class="header" href="#continuous-logging">Continuous logging</a></h3>
<pre><code class="language-bash"># Log all graph events
ros-z-console --headless --json &gt;&gt; ros-events.jsonl &amp;

# Log all messages from a topic
ros-z-console --headless --json --echo /diagnostics &gt;&gt; diagnostics.jsonl &amp;
</code></pre>
<h3 id="real-time-data-extraction"><a class="header" href="#real-time-data-extraction">Real-time data extraction</a></h3>
<pre><code class="language-bash"># Extract velocity commands
ros-z-console --headless --json --echo /cmd_vel | \
  jq -r '.data.linear.x' | \
  tee -a velocity.log

# Monitor temperature sensor
ros-z-console --headless --json --echo /temperature | \
  jq -r '[.timestamp, .data.value] | @csv' &gt;&gt; temp.csv
</code></pre>
<h3 id="database-analysis"><a class="header" href="#database-analysis">Database analysis</a></h3>
<pre><code class="language-bash"># After running TUI mode with measurements
sqlite3 ros-z-metrics.db "SELECT topic, AVG(msgs_sec) FROM metrics GROUP BY topic"
</code></pre>
<div id="admonition-interoperability" class="admonition admonish-tip" role="note" aria-labelledby="admonition-interoperability-title">
<div class="admonition-title">
<div id="admonition-interoperability-title">
<p>Interoperability</p>
</div>
<a class="admonition-anchor-link" href="chapters/console.html#admonition-interoperability"></a>
</div>
<div>
<p>Both ros-z and rmw_zenoh_cpp use the same Zenoh-based discovery protocol. ros-z-console subscribes to the graph liveliness tokens that rmw_zenoh_cpp nodes publish, enabling seamless interoperability without any configuration changes.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-memory-shm"><a class="header" href="#shared-memory-shm">Shared Memory (SHM)</a></h1>
<p>Shared Memory (SHM) enables zero-copy publishing of large messages by serializing directly into shared memory buffers, eliminating the need to copy data between processes.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>When publishing large messages (e.g., point clouds, images), copying data multiple times can significantly impact performance. ROS-Z's SHM support leverages Zenoh's shared memory capabilities to achieve true zero-copy publishing.</p>
<h3 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h3>
<ul>
<li><strong>Zero-copy serialization</strong>: Messages are serialized directly into shared memory</li>
<li><strong>Automatic activation</strong>: Configurable threshold-based switching</li>
<li><strong>Accurate buffer sizing</strong>: Auto-generated size estimation prevents waste</li>
<li><strong>High performance</strong>: Sub-millisecond serialization for 1MB messages</li>
<li><strong>Full compatibility</strong>: Works seamlessly with <code>rmw_zenoh_cpp</code></li>
</ul>
<h2 id="how-shm-works-in-ros-2"><a class="header" href="#how-shm-works-in-ros-2">How SHM Works in ROS 2</a></h2>
<p>The following diagram illustrates how a PointCloud2 message is published using shared memory in ROS-Z:</p>
<pre class="mermaid">sequenceDiagram
    participant App as Application
    participant Pub as ROS-Z Publisher
    participant SHM as SHM Provider
    participant Zenoh as Zenoh Network
    participant Sub as ROS-Z Subscriber
    participant RemoteApp as Remote Application

    Note over App,RemoteApp: Publishing Large PointCloud2 (1MB)

    App-&gt;&gt;App: Generate PointCloud2 data
    App-&gt;&gt;SHM: Allocate SHM buffer (1MB)
    SHM--&gt;&gt;App: SHM buffer reference

    App-&gt;&gt;App: Write point data directly to SHM
    Note over App: Zero-copy: data stays in SHM

    App-&gt;&gt;Pub: publish(pointcloud2)
    Pub-&gt;&gt;Pub: Estimate serialized size
    Pub-&gt;&gt;SHM: Allocate buffer for metadata
    Pub-&gt;&gt;Pub: Serialize header + metadata to SHM
    Note over Pub: Data field already in SHM!

    Pub-&gt;&gt;Zenoh: Publish SHM-backed ZBuf
    Note over Zenoh: Network transfer (zero-copy)

    Zenoh-&gt;&gt;Sub: Receive SHM reference
    Sub-&gt;&gt;Sub: Deserialize metadata
    Sub-&gt;&gt;RemoteApp: PointCloud2 with SHM data

    Note over RemoteApp: Direct access to SHM data
    RemoteApp-&gt;&gt;RemoteApp: Process points (zero-copy read)
</pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Point data is written <strong>once</strong> directly into shared memory</li>
<li>No intermediate copies between publisher and subscriber</li>
<li>Both processes access the same physical memory</li>
<li>Network only transfers SHM references, not actual data (on same machine)</li>
<li>Automatic fallback to regular serialization for remote nodes</li>
</ul>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<h3 id="default-behavior-shm-is-off"><a class="header" href="#default-behavior-shm-is-off">Default Behavior: SHM is OFF</a></h3>
<p><strong>By default, SHM is disabled.</strong> Messages are serialized using regular memory allocation. You must explicitly enable SHM to use zero-copy publishing.</p>
<h3 id="enable-shm-globally"><a class="header" href="#enable-shm-globally">Enable SHM Globally</a></h3>
<p>The simplest way to enable SHM is at the context level:</p>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z::Builder;
use ros_z_msgs::sensor_msgs::PointCloud2;

fn main() -&gt; zenoh::Result&lt;()&gt; {
    let ctx = ZContextBuilder::default()
        .with_shm_enabled()?  // Enable with defaults: 10MB pool, 512B threshold
        .build()?;

    // All publishers automatically use SHM for messages &gt;= 512 bytes
    let node = ctx.create_node("my_node").build()?;
    let publisher = node.create_pub::&lt;PointCloud2&gt;("cloud").build()?;

    // Zero-copy publishing for large messages!
    let large_pointcloud = PointCloud2::default();
    publisher.publish(&amp;large_pointcloud)?;
    Ok(())
}</code></pre>
<h3 id="custom-configuration"><a class="header" href="#custom-configuration">Custom Configuration</a></h3>
<p>Adjust pool size and threshold based on your needs:</p>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z::Builder;

fn main() -&gt; zenoh::Result&lt;()&gt; {
    let ctx = ZContextBuilder::default()
        .with_shm_pool_size(100 * 1024 * 1024)?  // 100MB pool
        .with_shm_threshold(50_000)?              // 50KB threshold
        .build()?;
    Ok(())
}</code></pre>
<h3 id="per-publisher-control"><a class="header" href="#per-publisher-control">Per-Publisher Control</a></h3>
<p>Override SHM settings for specific publishers:</p>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z::shm::{ShmConfig, ShmProviderBuilder};
use ros_z::Builder;
use ros_z_msgs::sensor_msgs::PointCloud2;
use std::sync::Arc;

fn main() -&gt; zenoh::Result&lt;()&gt; {
    let ctx = ZContextBuilder::default().build()?;
    let node = ctx.create_node("test").build()?;
    let provider = Arc::new(ShmProviderBuilder::new(10_000_000).build()?);
    let custom_config = ShmConfig::new(provider);

    // Custom configuration for this publisher
    let publisher = node.create_pub::&lt;PointCloud2&gt;("cloud")
        .with_shm_config(custom_config)
        .build()?;

    // Explicitly disable SHM (even if context has it enabled)
    let text_pub = node.create_pub::&lt;ros_z_msgs::std_msgs::String&gt;("text")
        .without_shm()
        .build()?;
    Ok(())
}</code></pre>
<h3 id="toggle-shm-onoff"><a class="header" href="#toggle-shm-onoff">Toggle SHM On/Off</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Method</th></tr></thead><tbody>
<tr><td><strong>Enable (default config)</strong></td><td><code>.with_shm_enabled()</code></td></tr>
<tr><td><strong>Enable (custom pool)</strong></td><td><code>.with_shm_pool_size(bytes)</code></td></tr>
<tr><td><strong>Adjust threshold</strong></td><td><code>.with_shm_threshold(bytes)</code></td></tr>
<tr><td><strong>Disable (default)</strong></td><td>Don't call any SHM methods</td></tr>
<tr><td><strong>Disable per-publisher</strong></td><td><code>.without_shm()</code></td></tr>
</tbody></table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="default-shm-disabled"><a class="header" href="#default-shm-disabled">Default: SHM Disabled</a></h3>
<p><strong>SHM is disabled by default.</strong> To enable it, you must explicitly configure it at the context, node, or publisher level.</p>
<h3 id="hierarchical-configuration"><a class="header" href="#hierarchical-configuration">Hierarchical Configuration</a></h3>
<p>SHM configuration follows a three-level hierarchy:</p>
<ol>
<li><strong>Context level</strong>: Default for all nodes/publishers</li>
<li><strong>Node level</strong>: Override for node's publishers (inherits from context if not set)</li>
<li><strong>Publisher level</strong>: Most specific override (can disable even if context has SHM)</li>
</ol>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z::shm::{ShmConfig, ShmProviderBuilder};
use ros_z::Builder;
use ros_z_msgs::sensor_msgs::{Image, PointCloud2};
use std::sync::Arc;

fn main() -&gt; zenoh::Result&lt;()&gt; {
    // Context: 10MB pool, 512B threshold
    let ctx = ZContextBuilder::default()
        .with_shm_enabled()?
        .build()?;

    // Node: inherit from context
    let node = ctx.create_node("my_node").build()?;

    // Publisher 1: use context defaults
    let pub1 = node.create_pub::&lt;Image&gt;("camera/image").build()?;

    // Publisher 2: custom threshold
    let provider = Arc::new(ShmProviderBuilder::new(10 * 1024 * 1024).build()?);
    let config = ShmConfig::new(provider).with_threshold(100_000);
    let pub2 = node.create_pub::&lt;PointCloud2&gt;("lidar/cloud")
        .with_shm_config(config)
        .build()?;

    // Publisher 3: disable SHM
    let pub3 = node.create_pub::&lt;ros_z_msgs::std_msgs::String&gt;("status")
        .without_shm()
        .build()?;
    Ok(())
}</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>For compatibility with <code>rmw_zenoh_cpp</code>, you can enable and configure SHM via environment variables:</p>
<pre><code class="language-bash">export ZENOH_SHM_ALLOC_SIZE=52428800        # Enable SHM with 50MB pool
export ZENOH_SHM_MESSAGE_SIZE_THRESHOLD=10000  # Set 10KB threshold
</code></pre>
<p><strong>Note</strong>: Setting either environment variable will enable SHM. If only one is set, the other uses the default value (10MB pool or 512B threshold).</p>
<p>To use environment variables in your code:</p>
<pre><code class="language-rust ignore">use ros_z::shm::ShmConfig;
use ros_z::context::ZContextBuilder;
use ros_z::Builder;

fn main() -&gt; zenoh::Result&lt;()&gt; {
    let ctx = if let Some(shm_config) = ShmConfig::from_env()? {
        // SHM configured from environment variables
        ZContextBuilder::default()
            .with_shm_config(shm_config)
            .build()?
    } else {
        // No SHM (default)
        ZContextBuilder::default().build()?
    };
    Ok(())
}</code></pre>
<h3 id="configuration-defaults-when-enabled"><a class="header" href="#configuration-defaults-when-enabled">Configuration Defaults (When Enabled)</a></h3>
<p>When you enable SHM using <code>.with_shm_enabled()</code> or <code>.with_shm_pool_size()</code>, the following defaults apply:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>SHM State</strong></td><td><strong>Disabled</strong></td><td>SHM must be explicitly enabled</td></tr>
<tr><td>Pool Size</td><td>10 MB</td><td>Total SHM pool size (when enabled)</td></tr>
<tr><td>Threshold</td><td>512 bytes</td><td>Min message size for SHM usage</td></tr>
<tr><td>Policy</td><td><code>BlockOn&lt;GarbageCollect&gt;</code></td><td>Wait for GC if pool exhausted</td></tr>
</tbody></table>
</div>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<h3 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h3>
<pre><code class="language-text">Message with dynamic fields
    ↓
estimated_serialized_size() [auto-generated by codegen]
    ↓
Pre-allocate SHM buffer (exact size)
    ↓
Serialize directly to SHM (zero-copy!)
    ↓
ZBuf (SHM-backed)
    ↓
Zenoh publish
</code></pre>
<h3 id="size-estimation"><a class="header" href="#size-estimation">Size Estimation</a></h3>
<p>ROS-Z automatically generates accurate size estimation for all message types during code generation:</p>
<pre><code class="language-rust ignore">// Auto-generated implementation for PointCloud2
impl SizeEstimation for PointCloud2 {
    fn estimated_serialized_size(&amp;self) -&gt; usize {
        4 + // encapsulation header
        self.header.estimated_cdr_size() +
        4 + // height
        4 + // width
        4 + self.fields.iter().map(|f| f.estimated_cdr_size()).sum::&lt;usize&gt;() +
        1 + // is_bigendian
        4 + // point_step
        4 + // row_step
        4 + self.data.len() +  // data buffer
        1   // is_dense
    }
}</code></pre>
<p>This ensures:</p>
<ul>
<li>No buffer overflows</li>
<li>Minimal memory waste (&lt;1% over-allocation)</li>
<li>Single allocation per message</li>
</ul>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>The following complete example demonstrates three patterns for using SHM with PointCloud2 messages. This code is from <code>ros-z/examples/shm_pointcloud2.rs</code>:</p>
<pre><code class="language-rust ignore">//! PointCloud2 example demonstrating user-managed SHM for zero-copy point clouds.
//!
//! This example shows how to create large sensor messages with data stored directly
//! in shared memory, avoiding any intermediate copies.
//!
//! # Three SHM Patterns Demonstrated:
//!
//! 1. **User-Managed SHM** (Primary): Allocate SHM buffer, write points, create message
//! 2. **Automatic SHM** (Context-level): Enable SHM globally, automatic threshold-based usage
//! 3. **Per-Publisher SHM**: Override SHM config for specific publisher
//!
//! # Usage:
//! ```bash
//! cargo run --example shm_pointcloud2
//! ```

use std::{sync::Arc, time::Instant};

use ros_z::{
    Builder,
    context::ZContextBuilder,
    shm::{ShmConfig, ShmProviderBuilder},
};
use ros_z_msgs::{
    sensor_msgs::{PointCloud2, PointField},
    std_msgs::Header,
};
use zenoh::{
    Wait,
    shm::{BlockOn, GarbageCollect, ShmProvider},
};
use zenoh_buffers::{ZBuf, buffer::Buffer};

fn main() -&gt; zenoh::Result&lt;()&gt; {
    println!("=== PointCloud2 with SHM Example ===\n");

    // Pattern 1: User-managed SHM (maximum performance, full control)
    println!("1. User-Managed SHM Pattern:");
    demo_user_managed_shm()?;

    println!("\n2. Automatic SHM Pattern (Context-level):");
    demo_automatic_shm()?;

    println!("\n3. Per-Publisher SHM Override:");
    demo_publisher_shm_override()?;

    println!("\n=== All patterns completed successfully ===");
    Ok(())
}

/// Pattern 1: User creates SHM buffer, writes points, constructs PointCloud2
fn demo_user_managed_shm() -&gt; zenoh::Result&lt;()&gt; {
    // Step 1: Initialize SHM provider
    let provider = ShmProviderBuilder::new(50 * 1024 * 1024).build()?;
    println!("  ✓ Created SHM provider with 50MB pool");

    // Step 2: Generate point cloud with SHM-backed data
    let start = Instant::now();
    let cloud = generate_pointcloud_with_shm(100_000, &amp;provider)?;
    let gen_time = start.elapsed();

    println!(
        "  ✓ Generated 100k point cloud ({} KB) in {:?}",
        cloud.data.len() / 1024,
        gen_time
    );
    println!("    Points stored directly in SHM (zero-copy!)");

    // Step 3: Create node and publisher
    let ctx = ZContextBuilder::default().build()?;
    let node = ctx.create_node("pointcloud_publisher").build()?;
    let publisher = node
        .create_pub::&lt;PointCloud2&gt;("cloud/user_managed")
        .build()?;

    // Step 4: Publish (data field is already in SHM)
    let start = Instant::now();
    publisher.publish(&amp;cloud)?;
    let pub_time = start.elapsed();

    println!(
        "  ✓ Published in {:?} (data already in SHM, only metadata serialized)",
        pub_time
    );

    Ok(())
}

/// Pattern 2: Enable SHM at context level, automatic for large messages
fn demo_automatic_shm() -&gt; zenoh::Result&lt;()&gt; {
    // Enable SHM globally
    let ctx = ZContextBuilder::default()
        .with_shm_pool_size(50 * 1024 * 1024)?
        .with_shm_threshold(10_000) // 10KB threshold
        .build()?;
    println!("  ✓ Context configured with automatic SHM (threshold: 10KB)");

    let node = ctx.create_node("pointcloud_publisher").build()?;
    let publisher = node.create_pub::&lt;PointCloud2&gt;("cloud/automatic").build()?;

    // Generate point cloud normally (using Vec&lt;u8&gt;)
    let start = Instant::now();
    let cloud = generate_pointcloud_normal(50_000);
    let gen_time = start.elapsed();

    println!(
        "  ✓ Generated 50k point cloud ({} KB) in {:?}",
        cloud.data.len() / 1024,
        gen_time
    );

    // Publish - automatically uses SHM because message &gt; threshold
    let start = Instant::now();
    publisher.publish(&amp;cloud)?;
    let pub_time = start.elapsed();

    println!(
        "  ✓ Published in {:?} (serialized ~600KB &gt; 10KB, automatically used SHM)",
        pub_time
    );

    Ok(())
}

/// Pattern 3: Per-publisher SHM configuration
fn demo_publisher_shm_override() -&gt; zenoh::Result&lt;()&gt; {
    // Context has no SHM, but publisher has its own config
    let ctx = ZContextBuilder::default().build()?;
    let node = ctx.create_node("pointcloud_publisher").build()?;

    // Create SHM provider for this publisher only
    let provider = Arc::new(ShmProviderBuilder::new(30 * 1024 * 1024).build()?);
    let shm_config = ShmConfig::new(provider).with_threshold(5_000); // 5KB threshold

    let publisher = node
        .create_pub::&lt;PointCloud2&gt;("cloud/per_publisher")
        .with_shm_config(shm_config)
        .build()?;

    println!("  ✓ Publisher configured with custom SHM (threshold: 5KB)");

    let cloud = generate_pointcloud_normal(30_000);
    println!(
        "  ✓ Generated 30k point cloud ({} KB)",
        cloud.data.len() / 1024
    );

    let start = Instant::now();
    publisher.publish(&amp;cloud)?;
    let pub_time = start.elapsed();

    println!(
        "  ✓ Published in {:?} (used publisher's SHM config)",
        pub_time
    );

    Ok(())
}

/// Generate point cloud with user-managed SHM (Pattern 1: zero-copy)
fn generate_pointcloud_with_shm(
    num_points: usize,
    provider: &amp;ShmProvider&lt;zenoh::shm::PosixShmProviderBackend&gt;,
) -&gt; zenoh::Result&lt;PointCloud2&gt; {
    let point_step = 12; // x, y, z as f32 (4 bytes each)
    let data_size = num_points * point_step;

    // Allocate SHM buffer for point data
    let mut shm_buf = provider
        .alloc(data_size)
        .with_policy::&lt;BlockOn&lt;GarbageCollect&gt;&gt;()
        .wait()?;

    // Write point coordinates directly into SHM buffer
    for i in 0..num_points {
        let offset = i * point_step;
        let angle = (i as f32) * 0.01;
        let radius = 5.0 + (angle * 0.1).sin();

        // Calculate x, y, z
        let x = radius * angle.cos();
        let y = radius * angle.sin();
        let z = (i as f32) * 0.001;

        // Write directly to SHM (no intermediate Vec&lt;u8&gt;)
        shm_buf[offset..offset + 4].copy_from_slice(&amp;x.to_le_bytes());
        shm_buf[offset + 4..offset + 8].copy_from_slice(&amp;y.to_le_bytes());
        shm_buf[offset + 8..offset + 12].copy_from_slice(&amp;z.to_le_bytes());
    }

    // Create ZBuf from SHM buffer (zero-copy conversion!)
    let data_zbuf = ZBuf::from(shm_buf);

    // Construct PointCloud2 with SHM-backed ZBuf
    Ok(PointCloud2 {
        header: Header {
            frame_id: "map".into(),
            ..Default::default()
        },
        height: 1,
        width: num_points as u32,
        fields: vec![
            PointField {
                name: "x".into(),
                offset: 0,
                datatype: 7, // FLOAT32
                count: 1,
            },
            PointField {
                name: "y".into(),
                offset: 4,
                datatype: 7,
                count: 1,
            },
            PointField {
                name: "z".into(),
                offset: 8,
                datatype: 7,
                count: 1,
            },
        ],
        is_bigendian: false,
        point_step: point_step as u32,
        row_step: (num_points * point_step) as u32,
        data: data_zbuf, // SHM-backed data!
        is_dense: true,
    })
}

/// Generate point cloud normally (Pattern 2 &amp; 3: uses Vec&lt;u8&gt;, then automatic SHM)
fn generate_pointcloud_normal(num_points: usize) -&gt; PointCloud2 {
    let point_step = 12;
    let mut data = Vec::with_capacity(num_points * point_step);

    for i in 0..num_points {
        let angle = (i as f32) * 0.01;
        let radius = 5.0 + (angle * 0.1).sin();

        let x = radius * angle.cos();
        let y = radius * angle.sin();
        let z = (i as f32) * 0.001;

        data.extend_from_slice(&amp;x.to_le_bytes());
        data.extend_from_slice(&amp;y.to_le_bytes());
        data.extend_from_slice(&amp;z.to_le_bytes());
    }

    PointCloud2 {
        header: Header {
            frame_id: "map".into(),
            ..Default::default()
        },
        height: 1,
        width: num_points as u32,
        fields: vec![
            PointField {
                name: "x".into(),
                offset: 0,
                datatype: 7,
                count: 1,
            },
            PointField {
                name: "y".into(),
                offset: 4,
                datatype: 7,
                count: 1,
            },
            PointField {
                name: "z".into(),
                offset: 8,
                datatype: 7,
                count: 1,
            },
        ],
        is_bigendian: false,
        point_step: point_step as u32,
        row_step: (num_points * point_step) as u32,
        data: ZBuf::from(data),
        is_dense: true,
    }
}</code></pre>
<p><strong>Run the example:</strong></p>
<pre><code class="language-bash">cargo run --example shm_pointcloud2
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code class="language-text">=== PointCloud2 with SHM Example ===

1. User-Managed SHM Pattern:
  ✓ Created SHM provider with 50MB pool
  ✓ Generated 100k point cloud (1171 KB) in 22ms
    Points stored directly in SHM (zero-copy!)
  ✓ Published in 851µs (data already in SHM, only metadata serialized)

2. Automatic SHM Pattern (Context-level):
  ✓ Context configured with automatic SHM (threshold: 10KB)
  ✓ Generated 50k point cloud (585 KB) in 11ms
  ✓ Published in 450µs (serialized ~600KB &gt; 10KB, automatically used SHM)

3. Per-Publisher SHM Override:
  ✓ Publisher configured with custom SHM (threshold: 5KB)
  ✓ Generated 30k point cloud (351 KB)
  ✓ Published in 320µs (used publisher's SHM config)

=== All patterns completed successfully ===
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="run-shm-tests"><a class="header" href="#run-shm-tests">Run SHM Tests</a></h3>
<pre><code class="language-bash"># SHM integration tests
cargo test -p ros-z --lib shm
cargo test -p ros-z --test shm

# Size estimation tests
cargo test -p ros-z-msgs --test shm_size_estimation

# Performance tests
cargo test -p ros-z-msgs --test size_estimation_performance
</code></pre>
<h3 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h3>
<ul>
<li><strong>16 total tests</strong> covering:
<ul>
<li>SHM allocation and serialization</li>
<li>Size estimation accuracy</li>
<li>Performance benchmarks</li>
<li>Multi-message scenarios</li>
<li>Error handling</li>
</ul>
</li>
</ul>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="buffer-overflow-panic"><a class="header" href="#buffer-overflow-panic">Buffer Overflow Panic</a></h3>
<p><strong>Symptom</strong>: <code>SHM buffer overflow</code> panic during serialization</p>
<p><strong>Cause</strong>: Message's <code>estimated_serialized_size()</code> is inaccurate</p>
<p><strong>Solution</strong>: This should not occur with auto-generated implementations. If it does, please report as a bug with the specific message type and data.</p>
<h3 id="shm-allocation-fails"><a class="header" href="#shm-allocation-fails">SHM Allocation Fails</a></h3>
<p><strong>Symptom</strong>: Falls back to regular memory allocation</p>
<p><strong>Possible Causes</strong>:</p>
<ol>
<li>SHM pool exhausted</li>
<li>System SHM limits reached</li>
<li>Message below threshold</li>
</ol>
<p><strong>Solutions</strong>:</p>
<pre><code class="language-bash"># Check pool usage
ipcs -m

# Increase pool size
let ctx = ZContextBuilder::default()
    .with_shm_pool_size(100 * 1024 * 1024)?
    .build()?;

# Lower threshold
let ctx = ZContextBuilder::default()
    .with_shm_threshold(256)?
    .build()?;
</code></pre>
<h3 id="poor-performance"><a class="header" href="#poor-performance">Poor Performance</a></h3>
<p><strong>Symptom</strong>: Serialization slower than expected</p>
<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-rust ignore">// Check if message uses SHM
println!("Message size: {}", msg.estimated_serialized_size());
println!("SHM threshold: {}", ctx.shm_threshold());</code></pre>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Ensure message size exceeds threshold</li>
<li>Verify SHM is enabled</li>
<li>Check for buffer reallocations (use performance tests)</li>
</ul>
<h3 id="system-shm-limits"><a class="header" href="#system-shm-limits">System SHM Limits</a></h3>
<p>On Linux, check and adjust system limits:</p>
<pre><code class="language-bash"># Current limits
cat /proc/sys/kernel/shmmax  # Max segment size
cat /proc/sys/kernel/shmall  # Total pages

# Increase limits (requires root)
sudo sysctl -w kernel.shmmax=134217728   # 128MB
sudo sysctl -w kernel.shmall=32768       # 128MB in pages
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="when-to-use-shm"><a class="header" href="#when-to-use-shm">When to Use SHM</a></h3>
<p><strong>Good candidates for SHM</strong>:</p>
<ul>
<li>Point clouds (<code>sensor_msgs/PointCloud2</code>)</li>
<li>Camera images (<code>sensor_msgs/Image</code>)</li>
<li>Large arrays (<code>std_msgs/ByteMultiArray</code>)</li>
<li>Laser scans (<code>sensor_msgs/LaserScan</code>)</li>
</ul>
<p><strong>Not beneficial for SHM</strong>:</p>
<ul>
<li>Small messages (&lt;512 bytes)</li>
<li>High-frequency, small updates</li>
<li>Messages with mostly fixed-size fields</li>
</ul>
<h3 id="configuration-guidelines"><a class="header" href="#configuration-guidelines">Configuration Guidelines</a></h3>
<ol>
<li><strong>Start with defaults</strong>: 10MB pool, 512B threshold work well for most applications</li>
<li><strong>Adjust pool size</strong>: Based on maximum concurrent large messages</li>
<li><strong>Tune threshold</strong>: Balance between SHM overhead and copy cost</li>
<li><strong>Monitor usage</strong>: Use <code>ipcs -m</code> to check pool utilization</li>
</ol>
<h3 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h3>
<ol>
<li><strong>Pre-calculate sizes</strong>: Use <code>estimated_serialized_size()</code> to validate messages</li>
<li><strong>Reuse publishers</strong>: Creating publishers is expensive; reuse them</li>
<li><strong>Batch small messages</strong>: Don't use SHM for messages below threshold</li>
<li><strong>Profile first</strong>: Measure before optimizing SHM configuration</li>
</ol>
<h2 id="advanced-topics-1"><a class="header" href="#advanced-topics-1">Advanced Topics</a></h2>
<h3 id="custom-size-estimation"><a class="header" href="#custom-size-estimation">Custom Size Estimation</a></h3>
<p>For custom message types, implement <code>SizeEstimation</code>:</p>
<pre><code class="language-rust ignore">use ros_z_msgs::size_estimation::SizeEstimation;

impl SizeEstimation for MyCustomMessage {
    fn estimated_serialized_size(&amp;self) -&gt; usize {
        4 + // encapsulation header
        self.field1.estimated_cdr_size() +
        self.field2.estimated_cdr_size() +
        4 + self.dynamic_array.len() * std::mem::size_of::&lt;ElementType&gt;()
    }
}</code></pre>
<h3 id="allocation-policies"><a class="header" href="#allocation-policies">Allocation Policies</a></h3>
<p>Zenoh SHM supports different allocation policies:</p>
<pre><code class="language-rust ignore">use zenoh::shm::{BlockOn, GarbageCollect};

// Block until memory available (default)
let policy = BlockOn::&lt;GarbageCollect&gt;;

// Fail immediately if pool full
// (use different policy with provider.alloc().with_policy())</code></pre>
<h3 id="integration-with-rmw_zenoh_cpp"><a class="header" href="#integration-with-rmw_zenoh_cpp">Integration with rmw_zenoh_cpp</a></h3>
<p>ROS-Z's SHM implementation is fully compatible with <code>rmw_zenoh_cpp</code>. Messages published from ROS-Z using SHM can be received zero-copy by C++/Python nodes using <code>rmw_zenoh_cpp</code>, and vice versa.</p>
<pre><code class="language-bash"># ROS-Z publisher (Rust)
cargo run --example shm_pointcloud2

# Standard ROS 2 subscriber (C++ with rmw_zenoh_cpp)
ros2 run my_package cloud_subscriber
</code></pre>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="chapters/./message_generation.html">Message Generation</a> - Understanding generated code</li>
<li><a href="chapters/./networking.html">Networking</a> - Zenoh configuration</li>
<li><a href="chapters/./troubleshooting.html">Troubleshooting</a> - General debugging</li>
</ul>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>For detailed implementation information, see the branch documentation:</p>
<ul>
<li><strong>Branch</strong>: <code>dev/shm</code></li>
<li><strong>Documentation</strong>: <code>.claude/ros-z/branches/shm/CLAUDE.md</code></li>
<li><strong>Status</strong>: Production ready</li>
</ul>
<p>Key files:</p>
<ul>
<li><code>ros-z/src/shm.rs</code> - Core SHM module</li>
<li><code>ros-z/src/msg.rs</code> - Serialization with size estimation</li>
<li><code>ros-z-codegen/src/generator/rust.rs</code> - Size estimation codegen</li>
<li><code>ros-z-msgs/src/size_estimation.rs</code> - Trait definition</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-expression-formats"><a class="header" href="#key-expression-formats">Key Expression Formats</a></h1>
<p><strong>ros-z uses key expression formats to map ROS 2 entities (topics, services, actions) to Zenoh key expressions.</strong> The format is provided by the independent <code>ros-z-protocol</code> crate and determines how ROS 2 names are translated for Zenoh routing and discovery.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/keyexpr_formats.html#admonition-note"></a>
</div>
<div>
<p>Key expression format is a runtime choice that affects how ros-z maps ROS 2 entities to Zenoh key expressions. Choose the format that matches your infrastructure for proper message routing.</p>
</div>
</div>
<h2 id="available-formats"><a class="header" href="#available-formats">Available Formats</a></h2>
<p>ros-z supports multiple key expression formats for interoperability with different Zenoh-ROS bridges:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Compatibility</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>RmwZenoh</strong> (default)</td><td><code>rmw_zenoh_cpp</code></td><td>Standard ROS 2 Zenoh middleware</td></tr>
<tr><td><strong>Ros2Dds</strong></td><td><code>zenoh-bridge-ros2dds</code></td><td>DDS bridge compatibility</td></tr>
</tbody></table>
</div>
<h3 id="rmwzenoh-format-default"><a class="header" href="#rmwzenoh-format-default">RmwZenoh Format (Default)</a></h3>
<p>The RmwZenoh format is designed for compatibility with ROS 2's official Zenoh middleware implementation (<code>rmw_zenoh_cpp</code>).</p>
<p><strong>Key Expression Patterns:</strong></p>
<pre><code class="language-text">Topic keys:      &lt;domain_id&gt;/&lt;topic&gt;/&lt;type&gt;/&lt;hash&gt;
Liveliness:      @ros2_lv/&lt;domain_id&gt;/&lt;entity_kind&gt;/&lt;namespace&gt;/&lt;name&gt;/...
</code></pre>
<p><strong>Example Topic Keys:</strong></p>
<pre><code class="language-text">0/chatter/std_msgs::msg::dds_::String_/RIHS01_...
5/robot/sensors/camera/sensor_msgs::msg::dds_::Image_/RIHS01_...
</code></pre>
<p><strong>Use this format when:</strong></p>
<ul>
<li>Using <code>rmw_zenoh_cpp</code> as your ROS 2 middleware</li>
<li>Running pure ros-z deployments</li>
<li>Requiring domain isolation via Zenoh</li>
</ul>
<h3 id="ros2dds-format"><a class="header" href="#ros2dds-format">Ros2Dds Format</a></h3>
<p>The Ros2Dds format is designed for compatibility with <code>zenoh-bridge-ros2dds</code>, which bridges standard DDS-based ROS 2 nodes to Zenoh.</p>
<p><strong>Key Expression Format:</strong></p>
<pre><code class="language-text">&lt;topic&gt;/**
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-text">chatter/**                    # Topic /chatter (no domain prefix)
robot/sensors/camera/**       # Topic /robot/sensors/camera
</code></pre>
<p><strong>Use this format when:</strong></p>
<ul>
<li>Bridging existing DDS-based ROS 2 systems to Zenoh</li>
<li>Using <code>zenoh-bridge-ros2dds</code></li>
<li>Integrating with CycloneDDS or FastDDS nodes via Zenoh</li>
</ul>
<h2 id="key-expression-behavior-important"><a class="header" href="#key-expression-behavior-important">Key Expression Behavior (IMPORTANT)</a></h2>
<p>Understanding how topic names are converted to key expressions is critical for debugging:</p>
<h3 id="topic-key-expressions-for-data-routing"><a class="header" href="#topic-key-expressions-for-data-routing">Topic Key Expressions (For Data Routing)</a></h3>
<p><strong>ALL entity types</strong> (publishers, subscriptions, services, clients, actions) use <code>strip_slashes()</code> behavior:</p>
<ul>
<li>Removes <strong>leading</strong> and <strong>trailing</strong> slashes only</li>
<li><strong>Preserves internal</strong> slashes for hierarchical routing</li>
<li>Enables multi-segment topic names</li>
</ul>
<p><strong>Examples:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>ROS 2 Topic Name</th><th>Topic Key Expression</th><th>✓/✗</th></tr></thead><tbody>
<tr><td><code>/chatter</code></td><td><code>0/chatter/...</code></td><td>✅ Correct</td></tr>
<tr><td><code>/robot/sensors</code></td><td><code>0/robot/sensors/...</code></td><td>✅ Correct</td></tr>
<tr><td><code>/a/b/c</code></td><td><code>0/a/b/c/...</code></td><td>✅ Correct</td></tr>
<tr><td><code>/talker/service</code></td><td><code>0/talker/service/...</code></td><td>✅ Correct</td></tr>
</tbody></table>
</div>
<p><strong>Why preserve slashes?</strong></p>
<ul>
<li>Zenoh uses <code>/</code> for hierarchical routing</li>
<li>Enables wildcard subscriptions: <code>0/robot/**</code></li>
<li>Human-readable key expressions</li>
</ul>
<h3 id="liveliness-tokens-for-discovery"><a class="header" href="#liveliness-tokens-for-discovery">Liveliness Tokens (For Discovery)</a></h3>
<p><strong>ALL fields</strong> in liveliness tokens use <code>mangle_name()</code> behavior:</p>
<ul>
<li>Replaces <strong>all</strong> <code>/</code> with <code>%</code></li>
<li>Ensures unambiguous parsing of entity metadata</li>
<li>Machine-parsable format for discovery protocol</li>
</ul>
<p><strong>Examples:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>ROS 2 Name</th><th>Liveliness Field</th><th>✓/✗</th></tr></thead><tbody>
<tr><td><code>/chatter</code></td><td><code>%chatter</code></td><td>✅ Correct</td></tr>
<tr><td><code>/robot/sensors</code></td><td><code>%robot%sensors</code></td><td>✅ Correct</td></tr>
<tr><td><code>/my_node</code></td><td><code>%my_node</code></td><td>✅ Correct</td></tr>
</tbody></table>
</div>
<p><strong>Why mangle slashes?</strong></p>
<ul>
<li>Liveliness tokens have fixed structure: <code>@ros2_lv/&lt;domain&gt;/&lt;kind&gt;/&lt;ns&gt;/&lt;name&gt;/...</code></li>
<li>Prevents ambiguity when parsing fields</li>
<li>Ensures reliable entity discovery</li>
</ul>
<h3 id="why-two-different-behaviors"><a class="header" href="#why-two-different-behaviors">Why Two Different Behaviors?</a></h3>
<p>This is <strong>intentional design</strong> in <code>rmw_zenoh_cpp</code>, not an inconsistency:</p>
<ul>
<li><strong>Topic keys</strong>: Human-readable, hierarchical (optimized for Zenoh routing)</li>
<li><strong>Liveliness</strong>: Machine-parsable, unambiguous (optimized for discovery protocol)</li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/keyexpr_formats.html#admonition-tip"></a>
</div>
<div>
<p>If multi-segment topics like <code>/robot/sensors/camera</code> don't receive messages, check your ros-z version. Versions before 0.1.0 had a bug where publishers incorrectly mangled topic key expressions.</p>
</div>
</div>
<h2 id="api-usage"><a class="header" href="#api-usage">API Usage</a></h2>
<h3 id="specifying-format-at-context-creation"><a class="header" href="#specifying-format-at-context-creation">Specifying Format at Context Creation</a></h3>
<pre><code class="language-rust ignore">use ros_z::context::ZContextBuilder;
use ros_z_protocol::KeyExprFormat;

// Default (RmwZenoh)
let ctx = ZContextBuilder::default().build()?;

// Explicit format selection
let ctx = ZContextBuilder::default()
    .keyexpr_format(KeyExprFormat::RmwZenoh)
    .build()?;

// Ros2Dds format for DDS bridge compatibility
let ctx = ZContextBuilder::default()
    .keyexpr_format(KeyExprFormat::Ros2Dds)
    .build()?;</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Format is set at context creation time</li>
<li>All nodes and entities created from the context use the same format</li>
<li>Default format is <code>KeyExprFormat::RmwZenoh</code></li>
<li>Format choice is type-safe and explicit</li>
</ul>
<h3 id="creating-entities"><a class="header" href="#creating-entities">Creating Entities</a></h3>
<p>Once the context is created with a format, all entities inherit it:</p>
<pre><code class="language-rust ignore">use ros_z_msgs::std_msgs::String as RosString;
use ros_z::Builder;

// Create context with RmwZenoh format (default)
let ctx = ZContextBuilder::default().build()?;
let node = ctx.create_node("my_node").build()?;

// Publisher uses context's format
let pub_rmw = node
    .create_pub::&lt;RosString&gt;("chatter")
    .build()?;

// Subscriber uses same format
let sub_rmw = node
    .create_sub::&lt;RosString&gt;("chatter")
    .build()?;</code></pre>
<h3 id="mixing-formats-advanced"><a class="header" href="#mixing-formats-advanced">Mixing Formats (Advanced)</a></h3>
<p>To communicate with both RmwZenoh and Ros2Dds systems, create separate contexts:</p>
<pre><code class="language-rust ignore">// Context for rmw_zenoh_cpp nodes
let ctx_rmw = ZContextBuilder::default()
    .keyexpr_format(KeyExprFormat::RmwZenoh)
    .build()?;

// Context for zenoh-bridge-ros2dds nodes
let ctx_dds = ZContextBuilder::default()
    .keyexpr_format(KeyExprFormat::Ros2Dds)
    .build()?;

// Create nodes from each context
let node_rmw = ctx_rmw.create_node("rmw_node").build()?;
let node_dds = ctx_dds.create_node("dds_node").build()?;</code></pre>
<h2 id="architecture-diagrams"><a class="header" href="#architecture-diagrams">Architecture Diagrams</a></h2>
<h3 id="rmwzenoh-format-architecture"><a class="header" href="#rmwzenoh-format-architecture">RmwZenoh Format Architecture</a></h3>
<pre class="mermaid">graph LR
    A[ros-z Node&lt;br/&gt;RmwZenoh Format] --&gt;|&quot;0/chatter/**&quot;| B[Zenoh Router&lt;br/&gt;rmw_zenoh]
    B --&gt;|&quot;0/chatter/**&quot;| C[ROS 2 Node&lt;br/&gt;rmw_zenoh_cpp]
</pre>
<p><strong>Use case:</strong> Native Zenoh-based ROS 2 deployment</p>
<ul>
<li>All nodes use rmw_zenoh or ros-z</li>
<li>Direct Zenoh communication</li>
<li>Domain isolation via key expression prefix</li>
</ul>
<h3 id="ros2dds-format-architecture"><a class="header" href="#ros2dds-format-architecture">Ros2Dds Format Architecture</a></h3>
<pre class="mermaid">graph LR
    A[ros-z Node&lt;br/&gt;Ros2Dds Format] --&gt;|&quot;chatter/**&quot;| B[zenoh-bridge-ros2dds&lt;br/&gt;Router + Bridge]
    B --&gt;|DDS| C[ROS 2 Node&lt;br/&gt;CycloneDDS/FastDDS]
</pre>
<p><strong>Use case:</strong> Bridge existing DDS systems to Zenoh</p>
<ul>
<li>ROS 2 nodes use standard DDS middleware</li>
<li><code>zenoh-bridge-ros2dds</code> translates DDS ↔ Zenoh</li>
<li>ros-z communicates via Zenoh side of bridge</li>
</ul>
<h2 id="key-expression-generation-details"><a class="header" href="#key-expression-generation-details">Key Expression Generation Details</a></h2>
<p>Understanding how <code>ros-z-protocol</code> generates key expressions helps with debugging and monitoring.</p>
<h3 id="topic-key-expression-structure"><a class="header" href="#topic-key-expression-structure">Topic Key Expression Structure</a></h3>
<pre><code class="language-text">&lt;domain_id&gt;/&lt;topic_stripped&gt;/&lt;type&gt;/&lt;hash&gt;
</code></pre>
<p><strong>Components:</strong></p>
<ol>
<li><strong>Domain ID</strong>: ROS 2 domain (e.g., <code>0</code>, <code>5</code>)</li>
<li><strong>Topic (stripped)</strong>: Topic name with leading/trailing slashes removed, internal slashes preserved</li>
<li><strong>Type</strong>: Mangled message type (e.g., <code>std_msgs::msg::dds_::String_</code>)</li>
<li><strong>Hash</strong>: Type hash for compatibility (e.g., <code>RIHS01_...</code>)</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-text">Topic: /robot/sensors/camera
Type:  sensor_msgs/msg/Image
Hash:  RIHS01_abc123...

Key Expression:
0/robot/sensors/camera/sensor_msgs::msg::dds_::Image_/RIHS01_abc123...
</code></pre>
<h3 id="liveliness-token-structure"><a class="header" href="#liveliness-token-structure">Liveliness Token Structure</a></h3>
<pre><code class="language-text">@ros2_lv/&lt;domain&gt;/&lt;entity_kind&gt;/&lt;zid&gt;/&lt;id&gt;/&lt;namespace&gt;/&lt;name&gt;/&lt;type&gt;/&lt;hash&gt;/&lt;qos&gt;
</code></pre>
<p><strong>All name fields are mangled</strong> (/ → %):</p>
<pre><code class="language-text">Namespace: /robot/arm  →  %robot%arm
Name:      /gripper    →  %gripper
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-text">@ros2_lv/0/MP/01234567890abcdef/1/%robot%arm/%gripper/std_msgs::msg::String_/RIHS01_.../qos_string
</code></pre>
<h2 id="ros-z-protocol-crate"><a class="header" href="#ros-z-protocol-crate">ros-z-protocol Crate</a></h2>
<p>The key expression logic is provided by the independent <code>ros-z-protocol</code> crate:</p>
<p><strong>Features:</strong></p>
<ul>
<li><code>no_std</code> compatible (with <code>alloc</code>)</li>
<li>Language-agnostic protocol layer (FFI-ready)</li>
<li>Feature-gated format implementations</li>
<li>Comprehensive unit tests</li>
<li>Type-safe API</li>
</ul>
<p><strong>Cargo features:</strong></p>
<pre><code class="language-toml">[dependencies]
ros-z-protocol = { version = "0.1", features = ["rmw-zenoh", "ros2dds"] }
</code></pre>
<p><strong>Using ros-z-protocol directly:</strong></p>
<pre><code class="language-rust ignore">use ros_z_protocol::{KeyExprFormat, entity::*};

let format = KeyExprFormat::default(); // RmwZenoh

// Generate topic key expression
let topic_ke = format.topic_key_expr(&amp;entity)?;

// Generate liveliness token
let lv_ke = format.liveliness_key_expr(&amp;entity, &amp;zid)?;

// Parse liveliness token back to entity
let parsed_entity = format.parse_liveliness(&amp;lv_ke)?;</code></pre>
<p>See the <a href="https://docs.rs/ros-z-protocol">ros-z-protocol documentation</a> for details.</p>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="multi-segment-topics-not-working"><a class="header" href="#multi-segment-topics-not-working">Multi-Segment Topics Not Working?</a></h3>
<p><strong>Symptom:</strong> Publisher publishes to <code>/robot/sensors/camera</code> but subscriber never receives messages.</p>
<p><strong>Cause:</strong> Old versions of ros-z (before 0.1.0) incorrectly mangled slashes in topic key expressions.</p>
<p><strong>Fix:</strong> Update to ros-z 0.1.0+ which correctly uses <code>strip_slashes()</code> for all topic key expressions.</p>
<p><strong>Verify:</strong> Enable debug logging to check key expressions:</p>
<pre><code class="language-bash">RUST_LOG=ros_z=debug cargo run --example z_pubsub
</code></pre>
<p>Look for key expressions like:</p>
<pre><code class="language-text">✅ Correct:  0/robot/sensors/camera/sensor_msgs::msg::Image_/...
❌ Wrong:    0/robot%sensors%camera/sensor_msgs::msg::Image_/...
</code></pre>
<h3 id="no-messages-between-ros-z-and-rmw_zenoh_cpp"><a class="header" href="#no-messages-between-ros-z-and-rmw_zenoh_cpp">No Messages Between ros-z and rmw_zenoh_cpp?</a></h3>
<p><strong>Check format:</strong> Ensure ros-z uses <code>KeyExprFormat::RmwZenoh</code> (the default).</p>
<p><strong>Check type hash:</strong> Enable debug logging and compare type hashes:</p>
<pre><code class="language-bash">RUST_LOG=ros_z=debug cargo run
</code></pre>
<p>Type hashes must match between ros-z and rmw_zenoh_cpp. If they don't, you may have:</p>
<ul>
<li>Different message definitions</li>
<li>Different ROS 2 distros</li>
<li>Outdated generated messages</li>
</ul>
<h3 id="no-messages-through-zenoh-bridge-ros2dds"><a class="header" href="#no-messages-through-zenoh-bridge-ros2dds">No Messages Through zenoh-bridge-ros2dds?</a></h3>
<p><strong>Check format:</strong> Ensure ros-z uses <code>KeyExprFormat::Ros2Dds</code>:</p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .keyexpr_format(KeyExprFormat::Ros2Dds)
    .build()?;</code></pre>
<p><strong>Check bridge configuration:</strong> Verify <code>zenoh-bridge-ros2dds</code> is running and connected to the same Zenoh router as ros-z.</p>
<h2 id="format-comparison"><a class="header" href="#format-comparison">Format Comparison</a></h2>
<h3 id="when-to-use-rmwzenoh-format"><a class="header" href="#when-to-use-rmwzenoh-format">When to Use RmwZenoh Format</a></h3>
<p>✅ <strong>Use RmwZenoh when:</strong></p>
<ul>
<li>Building pure Zenoh-based ROS 2 systems</li>
<li>Using <code>rmw_zenoh_cpp</code> middleware</li>
<li>Requiring domain isolation</li>
<li>Deploying new systems with native Zenoh support</li>
<li>Maximizing Zenoh performance benefits</li>
</ul>
<h3 id="when-to-use-ros2dds-format"><a class="header" href="#when-to-use-ros2dds-format">When to Use Ros2Dds Format</a></h3>
<p>✅ <strong>Use Ros2Dds when:</strong></p>
<ul>
<li>Bridging existing DDS-based ROS 2 systems</li>
<li>Using <code>zenoh-bridge-ros2dds</code></li>
<li>Integrating with legacy ROS 2 infrastructure</li>
<li>Gradual migration from DDS to Zenoh</li>
<li>Heterogeneous deployments (DDS + Zenoh)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rmw_zenoh_rs"><a class="header" href="#rmw_zenoh_rs">rmw_zenoh_rs</a></h1>
<p><code>rmw_zenoh_rs</code> is a Rust-based ROS Middleware (RMW) implementation that enables standard ROS 2 C++/Python nodes to communicate via Zenoh. It allows you to use Zenoh as the transport layer for your existing ROS 2 applications without modifying your code. It is <strong>fully interoperable</strong> with <code>rmw_zenoh_cpp</code>, allowing seamless communication between nodes using either implementation.</p>
<h2 id="what-is-an-rmw"><a class="header" href="#what-is-an-rmw">What is an RMW?</a></h2>
<p>ROS 2 uses a middleware abstraction layer called RMW (ROS Middleware) that allows you to choose different transport implementations. By default, ROS 2 uses DDS-based middleware like Fast-DDS or CycloneDDS. With rmw_zenoh_rs, you can use Zenoh instead.</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────┐
│              ROS 2 Application                  │
│         (C++ node using rclcpp)                 │
├─────────────────────────────────────────────────┤
│                    RCL                          │
│         (ROS Client Library - C)                │
├─────────────────────────────────────────────────┤
│                    RMW                          │
│      (ROS Middleware Interface - C)             │
├─────────────────────────────────────────────────┤
│              rmw_zenoh_rs                       │  ← This package
│         (Rust implementation)                   │
│  ┌──────────────────────────────────────────┐   │
│  │  FFI Layer (bindgen + cxx)               │   │
│  ├──────────────────────────────────────────┤   │
│  │  ros-z primitives                        │   │
│  │  (pubsub, service, guard_condition)      │   │
│  ├──────────────────────────────────────────┤   │
│  │  Zenoh                                   │   │
│  └──────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘
</code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<h3 id="ros-2-version-requirements"><a class="header" href="#ros-2-version-requirements">ROS 2 Version Requirements</a></h3>
<div id="admonition-humble-not-supported" class="admonition admonish-warning" role="note" aria-labelledby="admonition-humble-not-supported-title">
<div class="admonition-title">
<div id="admonition-humble-not-supported-title">
<p>Humble Not Supported</p>
</div>
<a class="admonition-anchor-link" href="chapters/rmw_zenoh_rs.html#admonition-humble-not-supported"></a>
</div>
<div>
<p>rmw-zenoh-rs requires <strong>ROS 2 Jazzy (2023) or later</strong>.
ROS 2 Humble (2022 LTS) is <strong>not supported</strong>.</p>
</div>
</div>
<p><strong>Supported ROS 2 Distributions:</strong></p>
<ul>
<li>✅ <strong>Jazzy</strong> (2023)</li>
<li>✅ <strong>Jazzy</strong> (2024 LTS) - Recommended</li>
<li>✅ <strong>Kilted</strong> (2025)</li>
<li>✅ <strong>Rolling</strong></li>
<li>❌ <strong>Humble</strong> (2022 LTS) - See <a href="chapters/rmw_zenoh_rs.html#why-no-humble-support">Why No Humble Support?</a></li>
</ul>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<ul>
<li><strong>ROS 2 Jazzy or later</strong> (Jazzy recommended)</li>
<li><strong>Rust toolchain</strong> (1.91 or later)</li>
<li><strong>Cargo</strong> (comes with Rust)</li>
<li><strong>CMake</strong> (3.16 or later)</li>
<li><strong>Clang</strong> (for bindgen)</li>
</ul>
<h3 id="ros-2-dependencies"><a class="header" href="#ros-2-dependencies">ROS 2 Dependencies</a></h3>
<p>The following ROS 2 packages are required:</p>
<ul>
<li><code>rmw</code> - RMW interface definitions</li>
<li><code>rcutils</code> - ROS C utilities</li>
<li><code>rcpputils</code> - ROS C++ utilities</li>
<li><code>fastcdr</code> - Fast CDR serialization</li>
<li><code>rosidl_typesupport_fastrtps_c</code> - Type support for C</li>
<li><code>rosidl_typesupport_fastrtps_cpp</code> - Type support for C++</li>
</ul>
<p>These are typically installed with ROS 2:</p>
<pre><code class="language-bash"># Ubuntu/Debian with ROS 2 Jazzy
sudo apt install ros-jazzy-rmw ros-jazzy-rcutils ros-jazzy-rcpputils \
  ros-jazzy-fastcdr ros-jazzy-rosidl-typesupport-fastrtps-c \
  ros-jazzy-rosidl-typesupport-fastrtps-cpp
</code></pre>
<h2 id="building-rmw_zenoh_rs"><a class="header" href="#building-rmw_zenoh_rs">Building rmw_zenoh_rs</a></h2>
<pre><code class="language-bash"># Source your ROS 2 installation
source /opt/ros/jazzy/setup.bash

# Create a workspace
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src

# Clone ros-z repository
git clone https://github.com/ZettaScaleLabs/ros-z.git

# Build rmw_zenoh_rs
cd ~/ros2_ws
colcon build --packages-select rmw_zenoh_rs --symlink-install
</code></pre>
<h3 id="build-output"><a class="header" href="#build-output">Build Output</a></h3>
<p>After building, you'll have:</p>
<ul>
<li><strong><code>librmw_zenoh_rs.so</code></strong> - The RMW library (Linux)</li>
<li><strong>RMW plugin registration</strong> - Allows ROS 2 to discover rmw_zenoh_rs</li>
</ul>
<h2 id="using-rmw_zenoh_rs"><a class="header" href="#using-rmw_zenoh_rs">Using rmw_zenoh_rs</a></h2>
<h3 id="setting-the-rmw-implementation"><a class="header" href="#setting-the-rmw-implementation">Setting the RMW Implementation</a></h3>
<p>To use rmw_zenoh_rs, set the <code>RMW_IMPLEMENTATION</code> environment variable:</p>
<pre><code class="language-bash">export RMW_IMPLEMENTATION=rmw_zenoh_rs
</code></pre>
<p>This tells ROS 2 to use rmw_zenoh_rs instead of the default DDS implementation.</p>
<h3 id="example-running-ros-2-nodes"><a class="header" href="#example-running-ros-2-nodes">Example: Running ROS 2 Nodes</a></h3>
<p>Start a Zenoh router first, then run your nodes with the RMW implementation set:</p>
<pre><code class="language-bash"># Terminal 1: Start Zenoh router (required)
zenohd

# Terminal 2: Talker
source ~/ros2_ws/install/setup.bash
export RMW_IMPLEMENTATION=rmw_zenoh_rs
ros2 run demo_nodes_cpp talker

# Terminal 3: Listener
source ~/ros2_ws/install/setup.bash
export RMW_IMPLEMENTATION=rmw_zenoh_rs
ros2 run demo_nodes_cpp listener
</code></pre>
<p>Your nodes will now communicate via Zenoh instead of DDS!</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/rmw_zenoh_rs.html#admonition-warning"></a>
</div>
<div>
<p>Unlike multicast-based discovery, router-based architecture is <strong>required</strong> by default. Both rmw_zenoh_rs and rmw_zenoh_cpp expect a router at <code>tcp/localhost:7447</code>. Without a router, nodes will not discover each other.</p>
</div>
</div>
<p><strong>Why a Zenoh router?</strong></p>
<p>ros-z, rmw_zenoh_rs, and rmw_zenoh_cpp all use router-based discovery by default, which provides:</p>
<ul>
<li><strong>Better scalability</strong> - Handles large deployments with many nodes</li>
<li><strong>Lower network overhead</strong> - More efficient than multicast discovery</li>
<li><strong>Cross-network communication</strong> - Nodes can discover each other across network boundaries</li>
<li><strong>Production-ready architecture</strong> - Standard approach used in real ROS 2 systems</li>
<li><strong>Interoperability</strong> - Required for ros-z nodes to work with rmw_zenoh_cpp nodes</li>
</ul>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/rmw_zenoh_rs.html#admonition-info"></a>
</div>
<div>
<p>The router runs as a separate process and manages discovery and routing between all Zenoh-based nodes. You only need one router per network, regardless of how many nodes you run.</p>
</div>
</div>
<h2 id="why-no-humble-support"><a class="header" href="#why-no-humble-support">Why No Humble Support?</a></h2>
<p>ROS 2 Jazzy (May 2023) introduced <strong>breaking changes to the RMW API</strong> that are fundamental to how rmw-zenoh-rs works. These are not minor API additions - they are architectural changes defined in ROS Enhancement Proposals (REPs).</p>
<h3 id="missing-apis-in-humble"><a class="header" href="#missing-apis-in-humble">Missing APIs in Humble</a></h3>
<h4 id="1-type-introspection--hashing-rep-2011"><a class="header" href="#1-type-introspection--hashing-rep-2011">1. Type Introspection &amp; Hashing (REP 2011)</a></h4>
<p><strong>What's Missing:</strong></p>
<ul>
<li><code>rosidl_type_hash_t</code> type structure</li>
<li>Type hash computation functions</li>
<li>Type description support</li>
</ul>
<p><strong>Why It Matters:</strong></p>
<p>rmw-zenoh-rs uses type hashes as part of Zenoh key expressions for topic matching and type safety validation. This is a core architectural feature, not an optional add-on.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-text">Jazzy+ Key: /topic/String/RIHS01_&lt;64-char-hash&gt;/...
Humble:    Cannot generate proper type hash
</code></pre>
<h4 id="2-discovery-options-rep-2019"><a class="header" href="#2-discovery-options-rep-2019">2. Discovery Options (REP 2019)</a></h4>
<p><strong>What's Missing:</strong></p>
<ul>
<li><code>rmw_discovery_options_t</code> configuration</li>
<li>Discovery control functions</li>
<li>Participant filtering APIs</li>
</ul>
<p><strong>Why It Matters:</strong></p>
<p>Used for network optimization and selective discovery in distributed systems.</p>
<h4 id="3-fastcdr-api-changes"><a class="header" href="#3-fastcdr-api-changes">3. FastCDR API Changes</a></h4>
<p><strong>What's Missing:</strong></p>
<ul>
<li>Humble uses FastCDR v1.x</li>
<li>Jazzy+ uses FastCDR v2.x</li>
<li>Constructor signatures incompatible</li>
</ul>
<h4 id="4-additional-missing-features"><a class="header" href="#4-additional-missing-features">4. Additional Missing Features</a></h4>
<ul>
<li>Type hash fields in endpoint info structs</li>
<li>QoS event types (<code>rmw_incompatible_type_status_t</code>, etc.)</li>
<li>Various discovery and introspection functions</li>
</ul>
<h3 id="impact"><a class="header" href="#impact">Impact</a></h3>
<p>Supporting Humble would require:</p>
<ul>
<li>100+ conditional compilation guards throughout the codebase</li>
<li>Maintaining two different RMW API implementations</li>
<li>Stub implementations for core features</li>
<li>Ongoing maintenance burden</li>
<li>Compromised architecture</li>
</ul>
<h3 id="alternatives-for-humble-users"><a class="header" href="#alternatives-for-humble-users">Alternatives for Humble Users</a></h3>
<p>If you need ROS 2 Humble support, you have two options:</p>
<h4 id="option-1-use-ros-z-core-library-recommended"><a class="header" href="#option-1-use-ros-z-core-library-recommended">Option 1: Use ros-z Core Library (Recommended)</a></h4>
<p>The <strong>ros-z core library</strong> has full Humble support:</p>
<pre><code class="language-rust ignore">use ros_z::{Builder, ZContext};

let ctx = ZContext::default();
let node = ctx.create_node("my_node").build()?;

// Full pub/sub, services, actions support on Humble ✅
let publisher = node.create_publisher::&lt;String&gt;("topic").build()?;</code></pre>
<p>This gives you pure Rust ROS 2 functionality on Humble without needing the RMW layer.</p>
<h4 id="option-2-use-rmw_zenoh_cpp"><a class="header" href="#option-2-use-rmw_zenoh_cpp">Option 2: Use rmw_zenoh_cpp</a></h4>
<p>Use the C++ RMW implementation, which supports Humble:</p>
<pre><code class="language-bash"># Install C++ RMW for Humble
apt install ros-humble-rmw-zenoh-cpp

# Set RMW implementation
export RMW_IMPLEMENTATION=rmw_zenoh_cpp

# Your C++/Python nodes will use Zenoh
ros2 run demo_nodes_cpp talker
</code></pre>
<p><strong>Interoperability</strong>: ros-z nodes can communicate seamlessly with rmw_zenoh_cpp nodes, so you can mix Rust and C++/Python nodes.</p>
<h2 id="rmw_zenoh_rs-vs-rmw_zenoh_cpp"><a class="header" href="#rmw_zenoh_rs-vs-rmw_zenoh_cpp">rmw_zenoh_rs vs rmw_zenoh_cpp</a></h2>
<p>Both <code>rmw_zenoh_rs</code> and <code>rmw_zenoh_cpp</code> are RMW implementations using Zenoh, but with different design goals:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>rmw_zenoh_rs</th><th>rmw_zenoh_cpp</th></tr></thead><tbody>
<tr><td><strong>Implementation Language</strong></td><td>Rust (using ros-z)</td><td>C++</td></tr>
<tr><td><strong>Primary Use Case</strong></td><td>Integration with ros-z ecosystem</td><td>Standalone Zenoh RMW</td></tr>
<tr><td><strong>ROS 2 Compatibility</strong></td><td>Jazzy, Jazzy, Kilted, Rolling</td><td>Humble, Jazzy, Jazzy, Kilted, Rolling</td></tr>
<tr><td><strong>Humble Support</strong></td><td>❌ No</td><td>✅ Yes</td></tr>
<tr><td><strong>Status</strong></td><td>Experimental</td><td>Production-ready</td></tr>
<tr><td><strong>Dependencies</strong></td><td>ros-z, Zenoh Rust</td><td>Zenoh C++ binding</td></tr>
<tr><td><strong>Performance</strong></td><td>Optimized for Rust stack</td><td>Optimized for C++ stack</td></tr>
<tr><td><strong>Interoperability</strong></td><td>✅ Works with rmw_zenoh_cpp</td><td>✅ Works with rmw_zenoh_rs</td></tr>
</tbody></table>
</div>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>rmw_zenoh_rs uses the same Zenoh configuration as rmw_zenoh_cpp. See <a href="chapters/./config_options.html">Configuration Options</a> for details.</p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="https://zenoh.io/docs/">Zenoh Documentation</a></li>
<li><a href="https://docs.ros.org/en/jazzy/Concepts/Intermediate/About-Different-Middleware-Vendors.html">ROS 2 RMW Documentation</a></li>
<li><a href="https://github.com/ZettaScaleLabs/ros-z">ros-z GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-bindings"><a class="header" href="#python-bindings">Python Bindings</a></h1>
<p><strong>ros-z provides Python bindings via <code>ros-z-py</code>, enabling Python applications to communicate with Rust and ROS 2 nodes using the same Zenoh transport.</strong> The bindings use PyO3 for Rust-Python interop and msgspec for efficient message serialization.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-note"></a>
</div>
<div>
<p>Python bindings provide the same pub/sub and service patterns as Rust, with Pythonic APIs. Messages are automatically serialized/deserialized between Python objects and CDR format for ROS 2 compatibility.</p>
</div>
</div>
<h2 id="visual-flow-2"><a class="header" href="#visual-flow-2">Visual Flow</a></h2>
<pre class="mermaid">graph TD
    A[Python Code] --&gt;|import| B[ros_z_py]
    B --&gt;|PyO3| C[Rust ros-z]
    C --&gt;|Zenoh| D[Network]
    D --&gt;|Zenoh| E[ROS 2 / Rust Nodes]

    F[Python Message] --&gt;|msgspec| G[Struct]
    G --&gt;|serialize| H[CDR Bytes]
    H --&gt;|deserialize| I[Rust Struct]
</pre>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Python 3.8+</li>
<li>Rust toolchain</li>
<li>maturin (<code>pip install maturin</code>)</li>
</ul>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<pre><code class="language-bash"># Create and activate virtual environment
cd ros-z-py
python -m venv .venv
source .venv/bin/activate

# Install message types
pip install -e ../crates/ros-z-msgs/python/

# Build and install ros-z-py
maturin develop
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-tip"></a>
</div>
<div>
<p>Use <code>maturin develop --release</code> for optimized builds when benchmarking or running in production.</p>
</div>
</div>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<p>Here's a complete publisher and subscriber example from <a href="https://github.com/ZettaScaleLabs/ros-z/blob/main/ros-z-py/examples/topic_demo.py"><code>ros-z-py/examples/topic_demo.py</code></a>:</p>
<h3 id="publisher-talker"><a class="header" href="#publisher-talker">Publisher (Talker)</a></h3>
<pre><code class="language-python">def run_talker(ctx, topic: str, count: int, interval: float):
    """Run the talker (publisher)."""
    node = ctx.create_node("talker").build()
    pub = node.create_publisher(topic, std_msgs.String)

    print(f"Talker started. Publishing to {topic}...")

    i = 0
    while count == 0 or i &lt; count:
        message = f"Hello from Python {i}"
        msg = std_msgs.String(data=message)
        pub.publish(msg)
        print(f"PUB:{i}", flush=True)
        i += 1
        time.sleep(interval)

    print("PUB:DONE", flush=True)


</code></pre>
<h3 id="subscriber-listener"><a class="header" href="#subscriber-listener">Subscriber (Listener)</a></h3>
<pre><code class="language-python">def run_listener(ctx, topic: str, timeout: float):
    """Run the listener (subscriber)."""
    node = ctx.create_node("listener").build()
    sub = node.create_subscriber(topic, std_msgs.String)

    print("SUB:READY", flush=True)

    start = time.time()
    received = 0

    while timeout == 0 or (time.time() - start) &lt; timeout:
        msg = sub.recv(timeout=1.0)
        if msg is not None:
            print(f"SUB:{msg.data}", flush=True)
            received += 1

    print(f"SUB:TOTAL:{received}", flush=True)


</code></pre>
<h2 id="key-components-1"><a class="header" href="#key-components-1">Key Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Python API</th></tr></thead><tbody>
<tr><td><strong>ZContextBuilder</strong></td><td>Configure ros-z environment</td><td><code>ZContextBuilder().with_domain_id(0).build()</code></td></tr>
<tr><td><strong>ZContext</strong></td><td>Manages ROS 2 connections</td><td>Entry point for creating nodes</td></tr>
<tr><td><strong>Node</strong></td><td>Logical unit of computation</td><td><code>ctx.create_node("name").build()</code></td></tr>
<tr><td><strong>Publisher</strong></td><td>Sends messages to topics</td><td><code>node.create_publisher(topic, type)</code></td></tr>
<tr><td><strong>Subscriber</strong></td><td>Receives messages from topics</td><td><code>node.create_subscriber(topic, type)</code></td></tr>
<tr><td><strong>Client</strong></td><td>Sends service requests</td><td><code>node.create_client(service, type)</code></td></tr>
<tr><td><strong>Server</strong></td><td>Handles service requests</td><td><code>node.create_server(service, type)</code></td></tr>
</tbody></table>
</div>
<h2 id="service-patterns"><a class="header" href="#service-patterns">Service Patterns</a></h2>
<p>Examples from <a href="https://github.com/ZettaScaleLabs/ros-z/blob/main/ros-z-py/examples/service_demo.py"><code>ros-z-py/examples/service_demo.py</code></a>:</p>
<h3 id="service-server"><a class="header" href="#service-server">Service Server</a></h3>
<pre><code class="language-python">def run_server(ctx, service: str, max_requests: int):
    """Run the AddTwoInts service server."""
    node = ctx.create_node("add_two_ints_server").build()
    server = node.create_server(service, example_interfaces.AddTwoIntsRequest)

    print("SERVER:READY", flush=True)

    handled = 0
    while max_requests == 0 or handled &lt; max_requests:
        request_id, req = server.take_request()
        result = req.a + req.b
        print(f"SERVER:{req.a}+{req.b}={result}", flush=True)

        resp = example_interfaces.AddTwoIntsResponse(sum=result)
        server.send_response(resp, request_id)
        handled += 1

    print("SERVER:DONE", flush=True)


</code></pre>
<h3 id="service-client"><a class="header" href="#service-client">Service Client</a></h3>
<pre><code class="language-python">def run_client(ctx, service: str, a: int, b: int, timeout: float):
    """Run the AddTwoInts service client."""
    node = ctx.create_node("add_two_ints_client").build()
    client = node.create_client(service, example_interfaces.AddTwoIntsRequest)

    # Wait for service discovery
    time.sleep(1.0)

    print(f"CLIENT:REQUEST:{a}+{b}", flush=True)

    req = example_interfaces.AddTwoIntsRequest(a=a, b=b)
    client.send_request(req)

    resp = client.take_response(timeout=timeout)

    if resp is not None:
        print(f"CLIENT:RESPONSE:{resp.sum}", flush=True)
    else:
        print("CLIENT:ERROR:no response", flush=True)
        sys.exit(1)


</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-tip-1"></a>
</div>
<div>
<p>Service servers use a pull model: <code>take_request()</code> blocks until a request arrives. This gives you explicit control over when to process requests.</p>
</div>
</div>
<h2 id="complex-messages"><a class="header" href="#complex-messages">Complex Messages</a></h2>
<p>Python bindings support nested message types like <code>geometry_msgs/Twist</code>:</p>
<pre><code class="language-python">from ros_z_py import geometry_msgs

# Create a Twist message with nested Vector3
twist = geometry_msgs.Twist(
    linear=geometry_msgs.Vector3(x=1.0, y=0.0, z=0.0),
    angular=geometry_msgs.Vector3(x=0.0, y=0.0, z=0.5)
)

pub = node.create_publisher("/cmd_vel", "geometry_msgs/msg/Twist")
pub.publish(twist)
</code></pre>
<h2 id="context-configuration"><a class="header" href="#context-configuration">Context Configuration</a></h2>
<h3 id="connect-to-specific-endpoint"><a class="header" href="#connect-to-specific-endpoint">Connect to Specific Endpoint</a></h3>
<pre><code class="language-python">ctx = (
    ros_z_py.ZContextBuilder()
    .with_connect_endpoints(["tcp/192.168.1.100:7447"])
    .build()
)
</code></pre>
<h3 id="disable-multicast-scouting"><a class="header" href="#disable-multicast-scouting">Disable Multicast Scouting</a></h3>
<pre><code class="language-python">ctx = (
    ros_z_py.ZContextBuilder()
    .with_domain_id(0)
    .disable_multicast_scouting()
    .build()
)
</code></pre>
<h3 id="custom-namespace"><a class="header" href="#custom-namespace">Custom Namespace</a></h3>
<pre><code class="language-python">node = ctx.create_node("my_node").with_namespace("/robot1").build()
</code></pre>
<h2 id="performance-zero-copy-large-payloads"><a class="header" href="#performance-zero-copy-large-payloads">Performance: Zero-Copy Large Payloads</a></h2>
<p>When working with large byte arrays (sensor data, images, point clouds), ros-z-py minimizes memory copies using a zero-copy optimization for <code>uint8[]</code> and <code>byte[]</code> fields.</p>
<h3 id="zbufview"><a class="header" href="#zbufview">ZBufView</a></h3>
<p>When a subscriber receives a message, byte array fields are exposed as a <code>ZBufView</code> — a zero-copy view into the received network buffer. <code>ZBufView</code> implements Python's buffer protocol:</p>
<pre><code class="language-python">msg = sub.recv(timeout=1.0)
# msg.data is a ZBufView — no copy has occurred

# Zero-copy access via buffer protocol
mv = memoryview(msg.data)
header = mv[:8]  # Slice without copying the entire payload

# Only copies when explicitly converted
data = bytes(msg.data)
</code></pre>
<h3 id="echo-without-copying"><a class="header" href="#echo-without-copying">Echo Without Copying</a></h3>
<p>For relay and echo patterns, pass <code>ZBufView</code> fields directly to a new message. The derive macro detects <code>ZBufView</code> and extracts the inner buffer via reference counting — no data copy occurs:</p>
<pre><code class="language-python"># Receive and re-publish — zero-copy for byte array fields
msg = sub.recv(timeout=1.0)
echo = std_msgs.ByteMultiArray(data=msg.data)  # No copy!
pub.publish(echo)
</code></pre>
<h3 id="zbufview-api"><a class="header" href="#zbufview-api">ZBufView API</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>len(view)</code></td><td>Number of bytes</td></tr>
<tr><td><code>bool(view)</code></td><td>True if not empty</td></tr>
<tr><td><code>view[i]</code></td><td>Single byte access</td></tr>
<tr><td><code>view[start:stop]</code></td><td>Slice (returns <code>bytes</code>)</td></tr>
<tr><td><code>memoryview(view)</code></td><td>Zero-copy buffer protocol access</td></tr>
<tr><td><code>bytes(view)</code></td><td>Convert to <code>bytes</code> (copies)</td></tr>
<tr><td><code>view.is_zero_copy</code></td><td>Whether the view avoids internal copying</td></tr>
</tbody></table>
</div><div id="admonition-tip-2" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-2-title">
<div class="admonition-title">
<div id="admonition-tip-2-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-tip-2"></a>
</div>
<div>
<p>For best performance with large payloads, avoid calling <code>bytes()</code> on <code>ZBufView</code> fields. Use <code>memoryview()</code> for read access, or pass the <code>ZBufView</code> directly when re-publishing.</p>
</div>
</div>
<h3 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h3>
<p>The optimization operates at three layers:</p>
<ol>
<li>
<p><strong>Deserialization bypass</strong>: When the Python subscriber receives a message, the raw network buffer (ZBuf) is stored in a thread-local. During CDR deserialization, byte array fields create sub-views into this buffer instead of copying (<code>ZSlice::subslice()</code>).</p>
</li>
<li>
<p><strong>Buffer protocol</strong>: <code>ZBufView</code> wraps the ZBuf and exposes its bytes to Python via <code>__getbuffer__</code>/<code>__releasebuffer__</code>. For contiguous buffers (the common case), this is a direct pointer — no copy at all.</p>
</li>
<li>
<p><strong>Pass-through re-publish</strong>: The <code>FromPyMessage</code> derive macro recognizes <code>ZBufView</code> inputs and extracts the inner ZBuf via <code>clone()</code>, which only increments a reference count on the underlying memory.</p>
</li>
</ol>
<h2 id="ros-2-interoperability-2"><a class="header" href="#ros-2-interoperability-2">ROS 2 Interoperability</a></h2>
<p>Python nodes work seamlessly with Rust and ROS 2 nodes:</p>
<pre><code class="language-bash"># Terminal 1: Start Zenoh router
cargo run --example zenoh_router

# Terminal 2: Run Python publisher (using topic_demo.py)
cd ros-z-py
source .venv/bin/activate
python examples/topic_demo.py -r talker

# Terminal 3: Listen with ROS 2 CLI
ros2 topic echo /chatter std_msgs/msg/String
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-success"></a>
</div>
<div>
<p>Messages published from Python are received by ROS 2 CLI, Rust nodes, and any other ROS 2-compatible system connected via Zenoh.</p>
</div>
</div>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<pre><code class="language-bash"># Python unit tests
cd ros-z-py
source .venv/bin/activate
python -m pytest tests/ -v

# Python-Rust interop tests
cargo test --features python-interop -p ros-z-tests --test python_interop -- --test-threads=1
</code></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<details id="admonition-import-errors-when-using-ros_z_py" class="admonition admonish-question" role="note" aria-labelledby="admonition-import-errors-when-using-ros_z_py-title">
<summary class="admonition-title">
<div id="admonition-import-errors-when-using-ros_z_py-title">
<p>Import errors when using ros_z_py</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-import-errors-when-using-ros_z_py"></a>
</summary>
<div>
<p>This error occurs when the package hasn't been built or installed correctly.</p>
<p><strong>Solution:</strong></p>
<p>Rebuild and install the package:</p>
<pre><code class="language-bash">cd ros-z-py
source .venv/bin/activate
pip install -e ../crates/ros-z-msgs/python/
maturin develop
</code></pre>
</div>
</details>
<details id="admonition-message-type-not-found" class="admonition admonish-question" role="note" aria-labelledby="admonition-message-type-not-found-title">
<summary class="admonition-title">
<div id="admonition-message-type-not-found-title">
<p>Message type not found</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-message-type-not-found"></a>
</summary>
<div>
<p>This error occurs when trying to use a message type that isn't registered.</p>
<p><strong>Solution:</strong></p>
<p>Check which message types are available:</p>
<pre><code class="language-python">from ros_z_py import ros_z_msgs
print(ros_z_msgs.list_registered_types())
</code></pre>
<p>Ensure the message package is enabled in <code>ros-z-msgs/Cargo.toml</code> features.</p>
</div>
</details>
<details id="admonition-recv-always-returns-none" class="admonition admonish-question" role="note" aria-labelledby="admonition-recv-always-returns-none-title">
<summary class="admonition-title">
<div id="admonition-recv-always-returns-none-title">
<p>recv() always returns None</p>
</div>
<a class="admonition-anchor-link" href="chapters/python.html#admonition-recv-always-returns-none"></a>
</summary>
<div>
<p>This happens when no messages are being received within the timeout period.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check the topic name matches exactly (including leading <code>/</code>)</li>
<li>Verify the publisher is running and connected to the same Zenoh network</li>
<li>Increase the timeout value</li>
<li>Use <code>--nocapture</code> with pytest to see debug output: <code>python -m pytest tests/ -v --capture=no</code></li>
</ul>
</div>
</details>
<h2 id="resources-6"><a class="header" href="#resources-6">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./python_codegen.html">Code Generation Internals</a></strong> - How Python bindings are generated</li>
<li><strong><a href="chapters/./pubsub.html">Pub/Sub</a></strong> - Deep dive into pub-sub patterns</li>
<li><strong><a href="chapters/./services.html">Services</a></strong> - Request-response communication</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - How message types work</li>
<li><strong><a href="chapters/./networking.html">Networking</a></strong> - Zenoh router setup and options</li>
</ul>
<p><strong>Start with the pub/sub example to understand the basics, then explore services for request-response patterns.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-code-generation-internals"><a class="header" href="#python-code-generation-internals">Python Code Generation Internals</a></h1>
<p>This chapter explains how ros-z generates Python bindings for ROS 2 messages, including the architecture, generated code structure, and design rationale.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>ros-z uses a <strong>hybrid approach</strong>: Python classes for ergonomics, Rust for serialization performance. The architecture uses <strong>derive macros</strong> for automatic Python-Rust conversion of arbitrarily nested message types.</p>
<pre class="mermaid">graph TB
    subgraph &quot;Build Time (cargo build)&quot;
        ROS[&quot;.msg/.srv files&quot;] --&gt; Parser[&quot;ros-z-codegen&lt;br/&gt;Parser&quot;]
        Parser --&gt; Resolver[&quot;Dependency&lt;br/&gt;Resolver&quot;]
        Resolver --&gt; PyGen[&quot;Python Generator&quot;]
        Resolver --&gt; RsGen[&quot;Rust Generator&quot;]
        PyGen --&gt; PyFiles[&quot;*.py files&lt;br/&gt;(msgspec structs)&quot;]
        RsGen --&gt; RsFile[&quot;Rust structs with&lt;br/&gt;derive macros&quot;]
        RsGen --&gt; PyO3File[&quot;python_bindings.rs&lt;br/&gt;(serialize/deserialize)&quot;]
    end

    subgraph &quot;Derive Macros (ros-z-derive)&quot;
        Derive[&quot;FromPyMessage&lt;br/&gt;IntoPyMessage&quot;]
        Derive --&gt;|&quot;generates&quot;| Extract[&quot;Field extraction code&quot;]
        Derive --&gt;|&quot;generates&quot;| Construct[&quot;Object construction code&quot;]
    end

    subgraph &quot;Runtime&quot;
        PyFiles --&gt; PyObj[&quot;Python Object&quot;]
        PyObj --&gt;|&quot;FromPyMessage::from_py()&quot;| RsStruct[&quot;Rust Struct&quot;]
        RsStruct --&gt;|&quot;ros-z-cdr::to_vec()&quot;| CDR[&quot;CDR Bytes&quot;]
        CDR --&gt;|&quot;Zenoh&quot;| Network[&quot;Network&quot;]
    end
</pre>
<h3 id="key-components-2"><a class="header" href="#key-components-2">Key Components</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Location</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Python Generator</strong></td><td><code>ros-z-codegen/src/generator/python.rs</code></td><td>Generates msgspec struct classes</td></tr>
<tr><td><strong>Rust Generator</strong></td><td><code>ros-z-codegen/src/generator/rust.rs</code></td><td>Generates Rust structs with derive attributes</td></tr>
<tr><td><strong>PyO3 Generator</strong></td><td><code>ros-z-codegen/src/python_msgspec_generator.rs</code></td><td>Generates serialize/deserialize wrapper functions</td></tr>
<tr><td><strong>Derive Macros</strong></td><td><code>ros-z-derive/src/lib.rs</code></td><td><code>FromPyMessage</code> and <code>IntoPyMessage</code> derive macros</td></tr>
<tr><td><strong>Bridge Traits</strong></td><td><code>ros-z/src/python_bridge.rs</code></td><td>Core traits for Python-Rust conversion</td></tr>
<tr><td><strong>Build Script</strong></td><td><code>ros-z-msgs/build.rs</code></td><td>Orchestrates code generation at build time</td></tr>
<tr><td><strong>Generated Python</strong></td><td><code>ros-z-msgs/python/ros_z_msgs_py/types/*.py</code></td><td>One file per ROS package</td></tr>
<tr><td><strong>Generated Rust</strong></td><td><code>$OUT_DIR/python_bindings.rs</code></td><td>Compiled into <code>ros-z-msgs</code> crate</td></tr>
</tbody></table>
</div>
<h2 id="generated-code-examples"><a class="header" href="#generated-code-examples">Generated Code Examples</a></h2>
<h3 id="python-msgspec-structs"><a class="header" href="#python-msgspec-structs">Python: msgspec Structs</a></h3>
<p>For each ROS message, a frozen <code>msgspec.Struct</code> is generated:</p>
<pre><code class="language-python"># Generated from std_msgs/msg/String.msg
class String(msgspec.Struct, frozen=True, kw_only=True):
    data: str = ""

    __msgtype__: ClassVar[str] = 'std_msgs/msg/String'
    __hash__: ClassVar[str] = 'RIHS01_df668c740482bbd48fb39d76a70dfd4bd59db1288021743503259e948f6b1a18'
</code></pre>
<p>Nested messages use forward references:</p>
<pre><code class="language-python"># Generated from geometry_msgs/msg/Twist.msg
class Twist(msgspec.Struct, frozen=True, kw_only=True):
    linear: "geometry_msgs.Vector3 | None" = None
    angular: "geometry_msgs.Vector3 | None" = None

    __msgtype__: ClassVar[str] = 'geometry_msgs/msg/Twist'
    __hash__: ClassVar[str] = 'RIHS01_9c45bf16fe0983d80e3cfe750d6835843d265a9a6c46bd2e609fcddde6fb8d2a'
</code></pre>
<p>Service request/response types use the service type hash in <code>__hash__</code>:</p>
<pre><code class="language-python"># Generated from example_interfaces/srv/AddTwoInts.srv
class AddTwoIntsRequest(msgspec.Struct, frozen=True, kw_only=True):
    a: int = 0
    b: int = 0

    __msgtype__: ClassVar[str] = 'example_interfaces/msg/AddTwoIntsRequest'
    __hash__: ClassVar[str] = 'RIHS01_e118de6bf5eeb66a2491b5bda11202e7b68f198d6f67922cf30364858239c81a'

class AddTwoIntsResponse(msgspec.Struct, frozen=True, kw_only=True):
    sum: int = 0

    __msgtype__: ClassVar[str] = 'example_interfaces/msg/AddTwoIntsResponse'
    __hash__: ClassVar[str] = 'RIHS01_e118de6bf5eeb66a2491b5bda11202e7b68f198d6f67922cf30364858239c81a'
</code></pre>
<p>For service types, <code>__hash__</code> contains the service type hash (computed from the combined request/response definition). Both request and response share the same hash since they belong to the same service. This differs from regular messages where <code>__hash__</code> contains the individual message type hash.</p>
<h3 id="rust-generated-structs-with-derive-macros"><a class="header" href="#rust-generated-structs-with-derive-macros">Rust: Generated Structs with Derive Macros</a></h3>
<p>The Rust code generator adds derive attributes to message structs:</p>
<pre><code class="language-rust ignore">// Generated from std_msgs/msg/String.msg
#[derive(Debug, Clone, Default, ::serde::Serialize, ::serde::Deserialize)]
#[cfg_attr(feature = "python_registry", derive(::ros_z_derive::FromPyMessage, ::ros_z_derive::IntoPyMessage))]
#[cfg_attr(feature = "python_registry", ros_msg(module = "ros_z_msgs_py.types.std_msgs"))]
pub struct String {
    pub data: std::string::String,
}</code></pre>
<p>For nested messages with optional fields:</p>
<pre><code class="language-rust ignore">// Generated from geometry_msgs/msg/Twist.msg
#[derive(Debug, Clone, Default, ::serde::Serialize, ::serde::Deserialize)]
#[cfg_attr(feature = "python_registry", derive(::ros_z_derive::FromPyMessage, ::ros_z_derive::IntoPyMessage))]
#[cfg_attr(feature = "python_registry", ros_msg(module = "ros_z_msgs_py.types.geometry_msgs"))]
pub struct Twist {
    pub linear: Vector3,
    pub angular: Vector3,
}</code></pre>
<h3 id="derive-macros-zero-copy-byte-array-handling"><a class="header" href="#derive-macros-zero-copy-byte-array-handling">Derive Macros: Zero-Copy Byte Array Handling</a></h3>
<p>Fields annotated with <code>#[ros_msg(zbuf)]</code> (applied automatically by the code generator for <code>uint8[]</code>/<code>byte[]</code> fields) get special treatment in the derive macros:</p>
<p><strong><code>FromPyMessage</code></strong> (Python → Rust) tries three paths in order:</p>
<ol>
<li><strong>ZBufView</strong> — extracts the inner <code>ZBuf</code> via <code>clone()</code> (reference-counted, zero-copy)</li>
<li><strong><code>bytes</code>/<code>bytearray</code></strong> — copies into a new <code>ZBuf</code></li>
<li><strong><code>list[int]</code></strong> — fallback extraction</li>
</ol>
<pre><code class="language-rust ignore">// Generated by FromPyMessage derive macro for #[ros_msg(zbuf)] fields
let py_attr = obj.getattr("data")?;
if let Ok(view) = py_attr.downcast::&lt;ZBufView&gt;() {
    view.borrow().zbuf().clone()     // Arc clone — no data copy
} else if let Ok(bytes) = py_attr.downcast::&lt;PyBytes&gt;() {
    ZBuf::from(bytes.as_bytes().to_vec())
} else if let Ok(bytearray) = py_attr.downcast::&lt;PyByteArray&gt;() {
    ZBuf::from(unsafe { bytearray.as_bytes() }.to_vec())
} else {
    let bytes: Vec&lt;u8&gt; = py_attr.extract()?;
    ZBuf::from(bytes)
}</code></pre>
<p><strong><code>IntoPyMessage</code></strong> (Rust → Python) creates a <code>ZBufView</code> instead of copying into <code>PyBytes</code>:</p>
<pre><code class="language-rust ignore">// Generated by IntoPyMessage derive macro for #[ros_msg(zbuf)] fields
let zbuf_view = ZBufView::new(self.data.clone());
let py_view = Py::new(py, zbuf_view)?;
kwargs.set_item("data", py_view)?;</code></pre>
<p>This means a received message's byte array fields can be passed directly to a new message for re-publishing without any data copy.</p>
<h3 id="rust-pyo3-serializedeserialize-functions"><a class="header" href="#rust-pyo3-serializedeserialize-functions">Rust: PyO3 Serialize/Deserialize Functions</a></h3>
<p>The serialize/deserialize functions use the derive macro traits:</p>
<pre><code class="language-rust ignore">// Generated serialize function - uses FromPyMessage trait
#[pyfunction]
pub fn serialize_string(py: Python, msg: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;Vec&lt;u8&gt;&gt; {
    use ::pyo3::types::PyAnyMethods;
    use ::ros_z::python_bridge::FromPyMessage;

    // Derive macro handles all field extraction recursively
    let rust_msg = &lt;ros::std_msgs::String&gt;::from_py(msg)?;

    // CDR serialization with 4-byte encapsulation header
    let mut cdr_data = ros_z_cdr::to_vec::&lt;_, ros_z_cdr::LittleEndian&gt;(&amp;rust_msg, 256)
        .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))?;
    let mut result = vec![0x00, 0x01, 0x00, 0x00]; // CDR encapsulation header
    result.append(&amp;mut cdr_data);
    Ok(result)
}

// Generated deserialize function - uses IntoPyMessage trait
#[pyfunction]
pub fn deserialize_string(py: Python, bytes: &amp;[u8]) -&gt; PyResult&lt;PyObject&gt; {
    use ::ros_z::python_bridge::IntoPyMessage;

    // Skip 4-byte CDR encapsulation header
    let cdr_data = &amp;bytes[4..];
    let (rust_msg, _): (ros::std_msgs::String, _) = ros_z_cdr::from_bytes::&lt;_, ros_z_cdr::LittleEndian&gt;(cdr_data)
        .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))?;

    // Derive macro handles all field construction recursively
    rust_msg.into_py_message(py)
}</code></pre>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="publishing-python-to-wire"><a class="header" href="#publishing-python-to-wire">Publishing (Python to Wire)</a></h3>
<pre class="mermaid">sequenceDiagram
    participant App as Python App
    participant Msg as msgspec.Struct
    participant PyO3 as PyO3 Layer
    participant Rust as Rust Struct
    participant CDR as CDR Encoder
    participant Net as Zenoh Network

    App-&gt;&gt;Msg: Create message
    App-&gt;&gt;PyO3: publish(msg)
    PyO3-&gt;&gt;PyO3: getattr() each field
    PyO3-&gt;&gt;Rust: Construct Rust struct
    Rust-&gt;&gt;CDR: cdr::serialize()
    CDR-&gt;&gt;Net: Send bytes
</pre>
<h3 id="subscribing-wire-to-python"><a class="header" href="#subscribing-wire-to-python">Subscribing (Wire to Python)</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Net as Zenoh Network
    participant CDR as CDR Decoder
    participant Rust as Rust Struct
    participant PyO3 as PyO3 Layer
    participant Msg as msgspec.Struct
    participant App as Python App

    Net-&gt;&gt;CDR: Receive bytes
    Note over CDR: Store ZBuf in thread-local&lt;br/&gt;for zero-copy deser
    CDR-&gt;&gt;Rust: cdr::deserialize()
    Note over CDR,Rust: byte[] fields → ZSlice sub-view&lt;br/&gt;(zero-copy)
    Rust-&gt;&gt;PyO3: Build PyDict kwargs
    Note over PyO3: byte[] → ZBufView&lt;br/&gt;(buffer protocol)
    PyO3-&gt;&gt;Msg: Call class(**kwargs)
    Msg-&gt;&gt;App: Return message
</pre>
<h2 id="type-mapping"><a class="header" href="#type-mapping">Type Mapping</a></h2>
<h3 id="ros-to-python-type-mapping"><a class="header" href="#ros-to-python-type-mapping">ROS to Python Type Mapping</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ROS Type</th><th>Python Type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>byte</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code></td><td><code>int</code></td><td>Python has arbitrary precision</td></tr>
<tr><td><code>float32</code>, <code>float64</code></td><td><code>float</code></td><td></td></tr>
<tr><td><code>string</code></td><td><code>str</code></td><td></td></tr>
<tr><td><code>T[]</code> (unbounded array)</td><td><code>list[T]</code></td><td></td></tr>
<tr><td><code>T[N]</code> (fixed array)</td><td><code>list[T]</code></td><td>Size not enforced in Python</td></tr>
<tr><td><code>uint8[]</code> / <code>byte[]</code></td><td><code>ZBufView</code></td><td>Zero-copy buffer protocol (on receive); accepts <code>bytes</code>, <code>bytearray</code>, or <code>ZBufView</code> on publish</td></tr>
<tr><td>Nested message</td><td><code>"pkg.MsgName | None"</code></td><td>Forward reference string</td></tr>
</tbody></table>
</div>
<h2 id="design-hybrid-python--rust-with-derive-macros"><a class="header" href="#design-hybrid-python--rust-with-derive-macros">Design: Hybrid Python + Rust with Derive Macros</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                    Current Architecture                      │
├─────────────────────────────────────────────────────────────┤
│  Python Layer          │  Rust Layer (via PyO3)             │
│  ─────────────         │  ──────────────────────            │
│  • msgspec structs     │  • Derive macros                   │
│  • Type annotations    │  • Trait-based conversion          │
│  • IDE support         │  • CDR serialization               │
│  • User-facing API     │  • Zenoh transport                 │
│                        │  • Memory management               │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Fast serialization (Rust CDR implementation)</li>
<li>Type-safe Python classes with IDE support</li>
<li>Immutable messages (<code>frozen=True</code>)</li>
<li>Automatic type hash validation</li>
<li>Zero-copy byte array handling: <code>ZBufView</code> exposes received data via buffer protocol without copying; <code>FromPyMessage</code> detects <code>ZBufView</code> inputs and extracts the inner buffer via reference counting</li>
<li><strong>Derive macros handle arbitrary nesting depth automatically</strong></li>
<li><strong>None handling for optional nested fields</strong></li>
<li><strong>Minimal generated code (traits do the work)</strong></li>
</ul>
<h2 id="build-process-1"><a class="header" href="#build-process-1">Build Process</a></h2>
<h3 id="step-by-step-flow"><a class="header" href="#step-by-step-flow">Step-by-step Flow</a></h3>
<pre class="mermaid">flowchart TD
    A[&quot;cargo build ros-z-msgs&lt;br/&gt;--features python_registry&quot;] --&gt; B[&quot;build.rs executes&quot;]
    B --&gt; C[&quot;Discover ROS packages&lt;br/&gt;(AMENT_PREFIX_PATH or bundled)&quot;]
    C --&gt; D[&quot;Parse .msg/.srv files&quot;]
    D --&gt; E[&quot;Resolve dependencies&lt;br/&gt;(type hashes, nested types)&quot;]
    E --&gt; F[&quot;Generate Python files&quot;]
    E --&gt; G[&quot;Generate Rust PyO3 module&quot;]
    F --&gt; H[&quot;ros-z-msgs/python/&lt;br/&gt;ros_z_msgs_py/types/*.py&quot;]
    G --&gt; I[&quot;$OUT_DIR/python_bindings.rs&quot;]
    I --&gt; J[&quot;include!() in lib.rs&quot;]
    J --&gt; K[&quot;Compiled into ros-z-msgs&quot;]
</pre>
<h3 id="output-locations"><a class="header" href="#output-locations">Output Locations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Output</th><th>Path</th><th>Committed?</th></tr></thead><tbody>
<tr><td>Python msgspec classes</td><td><code>ros-z-msgs/python/ros_z_msgs_py/types/*.py</code></td><td>Yes</td></tr>
<tr><td>Rust PyO3 bindings</td><td><code>target/.../ros-z-msgs-.../out/python_bindings.rs</code></td><td>No (generated)</td></tr>
</tbody></table>
</div>
<h3 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h3>
<p>The Python codegen is gated behind the <code>python_registry</code> feature:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
#[cfg(feature = "python_registry")]
include!(concat!(env!("OUT_DIR"), "/python_bindings.rs"));
<span class="boring">}</span></code></pre></pre>
<p>The <code>ros-z-derive</code> crate provides the derive macros, and <code>ros-z/python</code> enables the <code>FromPyMessage</code> and <code>IntoPyMessage</code> traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reproducible-development-with-nix"><a class="header" href="#reproducible-development-with-nix">Reproducible Development with Nix</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/nix.html#admonition-warning"></a>
</div>
<div>
<p>This is an advanced topic for users familiar with Nix. If you're new to Nix, you can safely skip this chapter and use the standard <a href="chapters/./building.html">Building</a> instructions instead.</p>
</div>
</div>
<p>ros-z provides Nix flakes for reproducible development environments with all dependencies pre-configured.</p>
<h2 id="why-use-nix"><a class="header" href="#why-use-nix">Why Use Nix?</a></h2>
<p><strong>Reproducible Builds:</strong> Nix ensures every developer and CI system uses the exact same dependencies, eliminating "works on my machine" issues. All dependencies—from compilers to ROS 2 packages—are pinned to specific versions and cached immutably.</p>
<p><strong>Uniform CI/CD:</strong> The same Nix configuration that runs locally is used in continuous integration, ensuring build consistency across development, testing, and deployment environments. No more divergence between local builds and CI failures.</p>
<p><strong>Zero Setup:</strong> New team members can start developing with a single <code>nix develop</code> command—no manual ROS installation, no dependency hunting, no environment configuration.</p>
<h2 id="available-environments"><a class="header" href="#available-environments">Available Environments</a></h2>
<pre><code class="language-bash"># Default: ROS 2 Jazzy with full tooling
nix develop

# Specific ROS distros
nix develop .#ros-jazzy      # ROS 2 Jazzy
nix develop .#ros-rolling    # ROS 2 Rolling

# Pure Rust (no ROS)
nix develop .#pureRust       # Minimal Rust toolchain only
</code></pre>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Use Case</th><th>Environment</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Team Development</strong></td><td>All developers</td><td>Everyone has identical toolchains and dependencies</td></tr>
<tr><td><strong>CI/CD Pipelines</strong></td><td>GitHub Actions, GitLab CI</td><td>Same environment locally and in automation</td></tr>
<tr><td><strong>Cross-Platform</strong></td><td>Linux, macOS, WSL</td><td>Consistent builds regardless of host OS</td></tr>
<tr><td><strong>Multiple ROS Versions</strong></td><td>Switch environments easily</td><td>Test against different ROS distros without conflicts</td></tr>
</tbody></table>
</div><div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/nix.html#admonition-tip"></a>
</div>
<div>
<p>Use Nix for consistent development environments across team members and CI/CD pipelines. The reproducibility guarantees catch integration issues early.</p>
</div>
</div>
<h2 id="learning-more"><a class="header" href="#learning-more">Learning More</a></h2>
<ul>
<li><strong><a href="https://nixos.org/manual/nix/stable/">Nix Official Guide</a></strong> - Introduction to Nix</li>
<li><strong><a href="https://nixos.wiki/wiki/Flakes">Nix Flakes</a></strong> - Understanding flakes</li>
<li><strong><a href="https://github.com/ZettaScaleLabs/ros-z/blob/main/flake.nix">ros-z flake.nix</a></strong> - Our Nix configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags-2"><a class="header" href="#feature-flags-2">Feature Flags</a></h1>
<p><strong>Fine-grained control over dependencies and functionality through Cargo feature flags.</strong> Build exactly what you need, from zero-dependency core to full ROS 2 integration, without carrying unused code.</p>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-success"></a>
</div>
<div>
<p>Feature flags enable pay-per-use dependencies. Start minimal and enable features incrementally as requirements grow.</p>
</div>
</div>
<h2 id="feature-categories"><a class="header" href="#feature-categories">Feature Categories</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Purpose</th><th>Example Features</th></tr></thead><tbody>
<tr><td><strong>Distribution</strong></td><td>Target specific ROS 2 versions</td><td><code>humble</code>, <code>jazzy</code>, <code>rolling</code></td></tr>
<tr><td><strong>Message Packages</strong></td><td>Enable ROS 2 message types</td><td><code>std_msgs</code>, <code>geometry_msgs</code></td></tr>
<tr><td><strong>Serialization</strong></td><td>Additional encoding formats</td><td><code>protobuf</code></td></tr>
<tr><td><strong>Integration</strong></td><td>External system bindings</td><td><code>rcl-z</code></td></tr>
</tbody></table>
</div>
<h2 id="ros-z-core-features"><a class="header" href="#ros-z-core-features">ros-z Core Features</a></h2>
<h3 id="protobuf"><a class="header" href="#protobuf"><code>protobuf</code></a></h3>
<p>Enables Protocol Buffers serialization using <code>prost</code>.</p>
<pre><code class="language-bash">cargo build -p ros-z --features protobuf
</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Schema evolution support</li>
<li>Language-agnostic data exchange</li>
<li>Efficient binary encoding</li>
<li>Familiar protobuf ecosystem</li>
</ul>
<p><strong>Dependencies:</strong> <code>prost</code>, <code>prost-types</code></p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-info"></a>
</div>
<div>
<p>Protobuf is optional. CDR serialization (default) provides full ROS 2 compatibility without additional dependencies.</p>
</div>
</div>
<h2 id="distribution-compatibility-features"><a class="header" href="#distribution-compatibility-features">Distribution Compatibility Features</a></h2>
<p><strong>ros-z defaults to ROS 2 Jazzy</strong>. Use distribution features to target other ROS 2 versions.</p>
<h3 id="jazzy-default"><a class="header" href="#jazzy-default"><code>jazzy</code> (default)</a></h3>
<p>Targets ROS 2 Jazzy Jalisco with modern type hash support.</p>
<pre><code class="language-bash"># Automatically enabled (default)
cargo build

# Explicitly enable
cargo build --features jazzy
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>✅ Type hash support (RIHS01)</li>
<li>✅ Shared memory optimization</li>
<li>✅ Modern ROS 2 protocol</li>
</ul>
<h3 id="humble"><a class="header" href="#humble"><code>humble</code></a></h3>
<p>Targets ROS 2 Humble Hawksbill (LTS) with legacy compatibility.</p>
<pre><code class="language-bash"># Disable defaults and enable humble
cargo build --no-default-features --features humble
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>❌ No type hash (uses placeholder)</li>
<li>❌ No shared memory support</li>
<li>✅ LTS support until 2027</li>
<li>✅ Compatible with rmw_zenoh_cpp v0.1.8</li>
</ul>
<p><strong>Important:</strong> Humble requires <code>--no-default-features</code> to avoid conflicts with the jazzy default.</p>
<h3 id="rolling"><a class="header" href="#rolling"><code>rolling</code></a></h3>
<p>Target Rolling distribution:</p>
<pre><code class="language-bash">cargo build --features rolling
</code></pre>
<p><strong>See also:</strong> <a href="chapters/./distro_compatibility.html">ROS 2 Distribution Compatibility</a> for detailed documentation.</p>
<h3 id="rcl-z"><a class="header" href="#rcl-z"><code>rcl-z</code></a></h3>
<p>Enables RCL (ROS Client Library) integration for C/C++ interoperability.</p>
<pre><code class="language-bash">cargo build -p ros-z --features rcl-z
</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Integrating with existing RCL-based code</li>
<li>Leveraging C/C++ ROS 2 libraries</li>
<li>Hybrid Rust/C++ applications</li>
</ul>
<p><strong>Requirements:</strong> ROS 2 installation with RCL libraries</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-warning"></a>
</div>
<div>
<p>This feature requires ROS 2 to be sourced before building. See <a href="chapters/./building.html">Building Guide</a> for setup instructions.</p>
</div>
</div>
<h2 id="ros-z-msgs-features"><a class="header" href="#ros-z-msgs-features">ros-z-msgs Features</a></h2>
<h3 id="default-features"><a class="header" href="#default-features">Default Features</a></h3>
<p>The default build includes commonly used message types via <code>core_msgs</code>:</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li><code>std_msgs</code> - Basic types (String, Int32, etc.)</li>
<li><code>geometry_msgs</code> - Spatial types (Point, Pose, Transform)</li>
<li><code>sensor_msgs</code> - Sensor data (LaserScan, Image, Imu)</li>
<li><code>nav_msgs</code> - Navigation (Path, Odometry, OccupancyGrid)</li>
<li><code>example_interfaces</code> - Tutorial services (AddTwoInts)</li>
<li><code>action_tutorials_interfaces</code> - Tutorial actions (Fibonacci)</li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-tip"></a>
</div>
<div>
<p>All messages are vendored in assets - no ROS 2 installation required. Feature flags simply control which packages to include in your build.</p>
</div>
</div>
<h3 id="individual-package-features"><a class="header" href="#individual-package-features">Individual Package Features</a></h3>
<p>All packages are bundled in assets and work without ROS 2:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Package</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>std_msgs</code></td><td>Standard messages</td><td>Strings, numbers, arrays</td></tr>
<tr><td><code>geometry_msgs</code></td><td>Geometric primitives</td><td>Points, poses, transforms</td></tr>
<tr><td><code>sensor_msgs</code></td><td>Sensor data</td><td>Cameras, lidars, IMUs</td></tr>
<tr><td><code>nav_msgs</code></td><td>Navigation</td><td>Paths, maps, odometry</td></tr>
<tr><td><code>example_interfaces</code></td><td>Tutorial services</td><td>AddTwoInts, Fibonacci</td></tr>
<tr><td><code>action_tutorials_interfaces</code></td><td>Tutorial actions</td><td>Fibonacci action</td></tr>
<tr><td><code>test_msgs</code></td><td>Test types</td><td>Testing and validation</td></tr>
</tbody></table>
</div>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Single package
cargo build -p ros-z-msgs --no-default-features --features std_msgs

# Multiple packages
cargo build -p ros-z-msgs --no-default-features --features "std_msgs,geometry_msgs"

# Default (core_msgs)
cargo build -p ros-z-msgs
</code></pre>
<h3 id="convenience-aliases"><a class="header" href="#convenience-aliases">Convenience Aliases</a></h3>
<p><strong><code>core_msgs</code> (default):</strong></p>
<p>The most commonly used packages for ROS 2 development.</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs  # Uses core_msgs by default
</code></pre>
<p>Enables: <code>std_msgs</code>, <code>geometry_msgs</code>, <code>sensor_msgs</code>, <code>nav_msgs</code>, <code>example_interfaces</code>, <code>action_tutorials_interfaces</code></p>
<p><strong><code>common_interfaces</code>:</strong></p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features common_interfaces
</code></pre>
<p>Enables: <code>std_msgs</code>, <code>geometry_msgs</code>, <code>sensor_msgs</code></p>
<p><strong><code>bundled_msgs</code>:</strong></p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features bundled_msgs
</code></pre>
<p>Enables: <code>std_msgs</code>, <code>geometry_msgs</code>, <code>sensor_msgs</code>, <code>nav_msgs</code></p>
<p><strong><code>robotics</code>:</strong></p>
<p>Alias for <code>core_msgs</code>.</p>
<p><strong><code>all_msgs</code>:</strong></p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features all_msgs
</code></pre>
<p>Enables: All available packages including <code>test_msgs</code></p>
<h3 id="protobuf-types"><a class="header" href="#protobuf-types">Protobuf Types</a></h3>
<p>Generate protobuf types alongside ROS messages:</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features protobuf
</code></pre>
<p><strong>Note:</strong> Requires <code>ros-z/protobuf</code> feature enabled as well.</p>
<h2 id="ros-z-codegen-features"><a class="header" href="#ros-z-codegen-features">ros-z-codegen Features</a></h2>
<h3 id="protobuf-code-generation"><a class="header" href="#protobuf-code-generation">Protobuf Code Generation</a></h3>
<p>Enable protobuf code generation support:</p>
<pre><code class="language-bash">cargo build -p ros-z-codegen --features protobuf
</code></pre>
<p><strong>Use case:</strong> Building tools that generate protobuf code from ROS messages</p>
<h2 id="feature-dependency-graph"><a class="header" href="#feature-dependency-graph">Feature Dependency Graph</a></h2>
<pre class="mermaid">graph TD
    A[all_msgs] --&gt; B[bundled_msgs]
    A --&gt; C[example_interfaces]
    A --&gt; D[action_tutorials_interfaces]
    A --&gt; E[test_msgs]

    B --&gt; F[std_msgs]
    B --&gt; G[geometry_msgs]
    B --&gt; H[sensor_msgs]
    B --&gt; I[nav_msgs]

    J[core_msgs] --&gt; F
    J --&gt; G
    J --&gt; H
    J --&gt; I
    J --&gt; C
    J --&gt; D
</pre>
<h2 id="common-feature-combinations"><a class="header" href="#common-feature-combinations">Common Feature Combinations</a></h2>
<h3 id="minimal-development"><a class="header" href="#minimal-development">Minimal Development</a></h3>
<p>Core library only, no messages:</p>
<pre><code class="language-bash">cargo build -p ros-z
</code></pre>
<p><strong>Dependencies:</strong> Rust, Cargo
<strong>Use case:</strong> Custom messages only</p>
<h3 id="standard-development"><a class="header" href="#standard-development">Standard Development</a></h3>
<p>Core with common message types:</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs  # Uses default common_interfaces
cargo build -p ros-z
</code></pre>
<p><strong>Dependencies:</strong> Rust, Cargo
<strong>Use case:</strong> Most applications</p>
<h3 id="full-message-set"><a class="header" href="#full-message-set">Full Message Set</a></h3>
<p>All available message packages:</p>
<pre><code class="language-bash">cargo build -p ros-z-msgs --features all_msgs
</code></pre>
<p><strong>Dependencies:</strong> Rust, Cargo
<strong>Use case:</strong> Access to all bundled message types including test_msgs</p>
<h3 id="rcl-integration"><a class="header" href="#rcl-integration">RCL Integration</a></h3>
<p>For C/C++ ROS 2 interoperability:</p>
<pre><code class="language-bash">source /opt/ros/jazzy/setup.bash
cargo build -p rcl-z
</code></pre>
<p><strong>Dependencies:</strong> Rust, Cargo, ROS 2
<strong>Use case:</strong> Hybrid Rust/C++ applications</p>
<h3 id="protobuf-development"><a class="header" href="#protobuf-development">Protobuf Development</a></h3>
<p>Core with protobuf serialization:</p>
<pre><code class="language-bash">cargo build -p ros-z-codegen --features protobuf
cargo build -p ros-z-msgs --features protobuf
cargo build -p ros-z --features protobuf
</code></pre>
<p><strong>Dependencies:</strong> Rust, Cargo, Protobuf compiler
<strong>Use case:</strong> Cross-language data exchange</p>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Package</th><th>Feature</th><th>Requires ROS 2</th><th>Adds Dependencies</th></tr></thead><tbody>
<tr><td>ros-z</td><td>(none)</td><td>No</td><td>None</td></tr>
<tr><td>ros-z</td><td>jazzy (default)</td><td>No</td><td>None</td></tr>
<tr><td>ros-z</td><td>humble</td><td>No</td><td>None</td></tr>
<tr><td>ros-z</td><td>rolling</td><td>No</td><td>None</td></tr>
<tr><td>ros-z</td><td>protobuf</td><td>No</td><td>prost, prost-types</td></tr>
<tr><td>ros-z</td><td>rcl-z</td><td>Yes</td><td>RCL libraries</td></tr>
<tr><td>ros-z-msgs</td><td>core_msgs (default)</td><td>No</td><td>None (bundled)</td></tr>
<tr><td>ros-z-msgs</td><td>bundled_msgs</td><td>No</td><td>None (bundled)</td></tr>
<tr><td>ros-z-msgs</td><td>all_msgs</td><td>No</td><td>None (bundled)</td></tr>
<tr><td>ros-z-msgs</td><td>protobuf</td><td>No</td><td>prost, prost-types</td></tr>
<tr><td>ros-z-msgs</td><td>jazzy (default)</td><td>No</td><td>None</td></tr>
<tr><td>ros-z-msgs</td><td>humble</td><td>No</td><td>None</td></tr>
<tr><td>ros-z-codegen</td><td>protobuf</td><td>No</td><td>prost-build</td></tr>
</tbody></table>
</div>
<h2 id="checking-active-features"><a class="header" href="#checking-active-features">Checking Active Features</a></h2>
<p>View enabled features for a package:</p>
<pre><code class="language-bash"># Show features for ros-z-msgs
cargo tree -p ros-z-msgs -e features

# Show all workspace features
cargo tree -e features

# Build with specific features and verify
cargo build -p ros-z-msgs --features std_msgs,geometry_msgs -v
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-tip-1"></a>
</div>
<div>
<p>Use <code>cargo tree</code> to debug feature resolution issues. It shows exactly which features are active and why.</p>
</div>
</div>
<h2 id="feature-selection-strategy"><a class="header" href="#feature-selection-strategy">Feature Selection Strategy</a></h2>
<pre class="mermaid">flowchart TD
    A[Start Project] --&gt; B{Need ROS messages?}
    B --&gt;|No| C[Zero features&lt;br/&gt;Custom messages]
    B --&gt;|Yes| D{Which messages?}

    D --&gt;|Common| E[core_msgs&lt;br/&gt;default]
    D --&gt;|Minimal| F[bundled_msgs or&lt;br/&gt;individual packages]
    D --&gt;|All| G[all_msgs]

    C --&gt; H[Minimal dependencies]
    E --&gt; I[Standard dependencies]
    F --&gt; I
    G --&gt; I
</pre>
<p><strong>Decision guide:</strong></p>
<ol>
<li><strong>Most projects?</strong> → Use defaults (<code>core_msgs</code>) - includes common packages</li>
<li><strong>Minimal build?</strong> → Use <code>--no-default-features</code> with specific packages</li>
<li><strong>Custom messages only?</strong> → No message features</li>
<li><strong>Cross-language data?</strong> → Add protobuf feature</li>
<li><strong>C++ integration?</strong> → Add rcl-z feature (requires ROS 2)</li>
</ol>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-note"></a>
</div>
<div>
<p>All message packages are vendored - no ROS 2 installation required for any message feature.</p>
</div>
</div>
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="chapters/feature_flags.html#admonition-info-1"></a>
</div>
<div>
<p>First build with message generation is slow. Incremental builds are fast. Choose the minimal feature set that meets your needs.</p>
</div>
</div>
<h2 id="examples-by-feature"><a class="header" href="#examples-by-feature">Examples by Feature</a></h2>
<h3 id="bundled-messages-default"><a class="header" href="#bundled-messages-default">Bundled Messages (Default)</a></h3>
<pre><code class="language-bash">cargo run --example z_pubsub          # std_msgs
cargo run --example twist_pub         # geometry_msgs
cargo run --example battery_state_sub # sensor_msgs
cargo run --example z_pingpong        # std_msgs
cargo run --example z_srvcli          # example_interfaces (now bundled)
</code></pre>
<h3 id="custom-messages-1"><a class="header" href="#custom-messages-1">Custom Messages</a></h3>
<pre><code class="language-bash">cargo run --example z_custom_message  # No features needed
</code></pre>
<h2 id="resources-7"><a class="header" href="#resources-7">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./building.html">Building Guide</a></strong> - Build procedures for each scenario</li>
<li><strong><a href="chapters/./distro_compatibility.html">ROS 2 Distribution Compatibility</a></strong> - Target Jazzy, Humble, or other distributions</li>
<li><strong><a href="chapters/./message_generation.html">Message Generation</a></strong> - How messages are generated</li>
</ul>
<p><strong>Start with default features and add more as your project evolves. Feature flags provide flexibility without forcing early architectural decisions.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h1>
<p><strong>Quick solutions to common ros-z build and runtime issues.</strong> Click on any question to expand the answer.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-tip"></a>
</div>
<div>
<p>Most issues fall into three categories: build configuration, runtime connectivity, or ROS 2 integration.</p>
</div>
</div>
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<details id="admonition-build-fails-with-cannot-find-ros-packages-or-package-discovery-errors" class="admonition admonish-question" role="note" aria-labelledby="admonition-build-fails-with-cannot-find-ros-packages-or-package-discovery-errors-title">
<summary class="admonition-title">
<div id="admonition-build-fails-with-cannot-find-ros-packages-or-package-discovery-errors-title">
<p>Build fails with 'Cannot find ROS packages' or package discovery errors</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-build-fails-with-cannot-find-ros-packages-or-package-discovery-errors"></a>
</summary>
<div>
<p><strong>Root Cause:</strong> ROS 2 environment not sourced or packages not installed.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Source ROS 2 environment:</strong></p>
<pre><code class="language-bash">source /opt/ros/jazzy/setup.bash
# or for rolling:
source /opt/ros/rolling/setup.bash
</code></pre>
</li>
<li>
<p><strong>Verify environment variables:</strong></p>
<pre><code class="language-bash">echo $AMENT_PREFIX_PATH
echo $CMAKE_PREFIX_PATH
</code></pre>
</li>
<li>
<p><strong>Check package installation:</strong></p>
<pre><code class="language-bash">ros2 pkg prefix example_interfaces
# If fails, install:
sudo apt install ros-jazzy-example-interfaces
</code></pre>
</li>
<li>
<p><strong>Clean and rebuild:</strong></p>
<pre><code class="language-bash">cargo clean -p ros-z-msgs
cargo build -p ros-z-msgs
</code></pre>
</li>
</ol>
<p><strong>Common Error Messages:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Solution</th></tr></thead><tbody>
<tr><td>"Package X not found"</td><td>Source ROS 2 environment</td></tr>
<tr><td>"Cannot find ament_index"</td><td>Install ROS 2 or use bundled msgs</td></tr>
<tr><td>"AMENT_PREFIX_PATH not set"</td><td>Run <code>source /opt/ros/jazzy/setup.bash</code></td></tr>
</tbody></table>
</div></div>
</details>
<details id="admonition-compiler-error-cannot-find-crate-ros_z_msgs" class="admonition admonish-question" role="note" aria-labelledby="admonition-compiler-error-cannot-find-crate-ros_z_msgs-title">
<summary class="admonition-title">
<div id="admonition-compiler-error-cannot-find-crate-ros_z_msgs-title">
<p>Compiler error: cannot find crate ros_z_msgs</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-compiler-error-cannot-find-crate-ros_z_msgs"></a>
</summary>
<div>
<p><strong>Root Cause:</strong> <code>ros-z-msgs</code> is not part of default workspace members.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Build ros-z-msgs explicitly
cargo build -p ros-z-msgs

# Then build your example
cargo build --example z_srvcli
</code></pre>
<p><strong>Note:</strong> <code>ros-z-msgs</code> is excluded from default builds to avoid requiring ROS 2 for core development. Build it explicitly when needed.</p>
</div>
</details>
<details id="admonition-build-takes-too-long-to-complete" class="admonition admonish-question" role="note" aria-labelledby="admonition-build-takes-too-long-to-complete-title">
<summary class="admonition-title">
<div id="admonition-build-takes-too-long-to-complete-title">
<p>Build takes too long to complete</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-build-takes-too-long-to-complete"></a>
</summary>
<div>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Use parallel builds (automatic on most systems)
cargo build -j $(nproc)

# Build only what you need
cargo build -p ros-z-msgs --features std_msgs,geometry_msgs
</code></pre>
</div>
</details>
<details id="admonition-linker-errors-during-build-especially-with-rcl-z" class="admonition admonish-question" role="note" aria-labelledby="admonition-linker-errors-during-build-especially-with-rcl-z-title">
<summary class="admonition-title">
<div id="admonition-linker-errors-during-build-especially-with-rcl-z-title">
<p>Linker errors during build (especially with rcl-z)</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-linker-errors-during-build-especially-with-rcl-z"></a>
</summary>
<div>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Clear cache and rebuild
cargo clean
source /opt/ros/jazzy/setup.bash
cargo build -p rcl-z
</code></pre>
<p><strong>Warning:</strong> After changing feature flags or updating ROS 2, run <code>cargo clean -p ros-z-msgs</code> to force message regeneration.</p>
</div>
</details>
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<details id="admonition-publishers-and-subscribers-on-different-processes-dont-communicate" class="admonition admonish-question" role="note" aria-labelledby="admonition-publishers-and-subscribers-on-different-processes-dont-communicate-title">
<summary class="admonition-title">
<div id="admonition-publishers-and-subscribers-on-different-processes-dont-communicate-title">
<p>Publishers and subscribers on different processes don't communicate</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-publishers-and-subscribers-on-different-processes-dont-communicate"></a>
</summary>
<div>
<p><strong>Root Cause:</strong> Zenoh router not running or nodes not configured correctly.</p>
<p><strong>Solution:</strong></p>
<ol>
<li>
<p><strong>Ensure the router is running:</strong></p>
<pre><code class="language-bash">cargo run --example zenoh_router
</code></pre>
</li>
<li>
<p><strong>Verify endpoint matches in your code:</strong></p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .with_router_endpoint("tcp/localhost:7447")  // Must match router
    .build()?;</code></pre>
</li>
</ol>
</div>
</details>
<details id="admonition-router-fails-to-start-with-address-already-in-use-error" class="admonition admonish-question" role="note" aria-labelledby="admonition-router-fails-to-start-with-address-already-in-use-error-title">
<summary class="admonition-title">
<div id="admonition-router-fails-to-start-with-address-already-in-use-error-title">
<p>Router fails to start with 'Address already in use' error</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-router-fails-to-start-with-address-already-in-use-error"></a>
</summary>
<div>
<p><strong>Root Cause:</strong> Another process is using port 7447.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Stop the conflicting process</strong></p>
</li>
<li>
<p><strong>Use a custom port:</strong></p>
<pre><code class="language-rust ignore">// Custom router port
let router_config = RouterConfigBuilder::new()
    .with_listen_port(7448)
    .build()?;

// Connect sessions to custom port
let ctx = ZContextBuilder::default()
    .with_router_endpoint("tcp/localhost:7448")
    .build()?;</code></pre>
</li>
</ol>
</div>
</details>
<details id="admonition-dont-want-to-manage-a-router-for-simple-local-testing" class="admonition admonish-question" role="note" aria-labelledby="admonition-dont-want-to-manage-a-router-for-simple-local-testing-title">
<summary class="admonition-title">
<div id="admonition-dont-want-to-manage-a-router-for-simple-local-testing-title">
<p>Don't want to manage a router for simple local testing</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-dont-want-to-manage-a-router-for-simple-local-testing"></a>
</summary>
<div>
<p><strong>Solution:</strong> Use peer mode with multicast discovery:</p>
<pre><code class="language-rust ignore">let ctx = ZContextBuilder::default()
    .with_zenoh_config(zenoh::Config::default())
    .build()?;</code></pre>
<p><strong>Warning:</strong> Peer mode won't interoperate with ROS 2 nodes using <code>rmw_zenoh_cpp</code> in router mode.</p>
</div>
</details>
<details id="admonition-multi-segment-topics-like-robotsensorscamera-dont-receive-messages" class="admonition admonish-question" role="note" aria-labelledby="admonition-multi-segment-topics-like-robotsensorscamera-dont-receive-messages-title">
<summary class="admonition-title">
<div id="admonition-multi-segment-topics-like-robotsensorscamera-dont-receive-messages-title">
<p>Multi-segment topics like /robot/sensors/camera don't receive messages</p>
</div>
<a class="admonition-anchor-link" href="chapters/troubleshooting.html#admonition-multi-segment-topics-like-robotsensorscamera-dont-receive-messages"></a>
</summary>
<div>
<p><strong>Symptom:</strong> Publisher publishes to <code>/robot/sensors/camera</code> but subscriber never receives messages.</p>
<p><strong>Root Cause:</strong> Old versions of ros-z (before 0.1.0) incorrectly mangled slashes in topic key expressions, breaking multi-segment topic routing.</p>
<p><strong>Solution:</strong> Update to ros-z 0.1.0+ which correctly preserves internal slashes in topic key expressions.</p>
<p><strong>Verify the fix:</strong></p>
<pre><code class="language-bash"># Enable debug logging to see key expressions
RUST_LOG=ros_z=debug cargo run --example z_pubsub
</code></pre>
<p>Look for key expressions in the output:</p>
<div class="table-wrapper"><table><thead><tr><th>Key Expression</th><th>Status</th></tr></thead><tbody>
<tr><td><code>0/robot/sensors/camera/...</code></td><td>✅ Correct (slashes preserved)</td></tr>
<tr><td><code>0/robot%sensors%camera/...</code></td><td>❌ Wrong (slashes mangled)</td></tr>
</tbody></table>
</div>
<p><strong>Technical Details:</strong></p>
<ul>
<li><strong>Topic key expressions</strong> should use <code>strip_slashes()</code>: removes leading/trailing slashes, preserves internal slashes</li>
<li><strong>Liveliness tokens</strong> should use <code>mangle_name()</code>: replaces all <code>/</code> with <code>%</code></li>
<li>This matches the behavior of <code>rmw_zenoh_cpp</code></li>
</ul>
<p>See <a href="chapters/./keyexpr_formats.html#key-expression-behavior-important">Key Expression Formats</a> for details.</p>
</div>
</details>
<h2 id="resources-8"><a class="header" href="#resources-8">Resources</a></h2>
<ul>
<li><strong><a href="chapters/./building.html">Building Guide</a></strong> - Correct build procedures</li>
<li><strong><a href="chapters/./networking.html">Networking</a></strong> - Zenoh router setup</li>
<li><strong><a href="chapters/./feature_flags.html">Feature Flags</a></strong> - Available features</li>
<li><strong><a href="https://github.com/ZettaScaleLabs/ros-z/issues">GitHub Issues</a></strong> - Report bugs</li>
</ul>
<p><strong>Most issues are environmental. Verify your setup matches the build scenario requirements before diving deeper.</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
