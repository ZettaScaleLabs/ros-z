/* automatically generated by rust-bindgen 0.72.1 */

pub const RMW_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RMW_RET_OK: u32 = 0;
pub const RMW_RET_ERROR: u32 = 1;
pub const RMW_RET_TIMEOUT: u32 = 2;
pub const RMW_RET_UNSUPPORTED: u32 = 3;
pub const RMW_RET_BAD_ALLOC: u32 = 10;
pub const RMW_RET_INVALID_ARGUMENT: u32 = 11;
pub const RMW_RET_INCORRECT_RMW_IMPLEMENTATION: u32 = 12;
pub const RMW_RET_NODE_NAME_NON_EXISTENT: u32 = 203;
pub const RMW_GID_STORAGE_SIZE: u32 = 24;
pub const RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG : & [u8 ; 145] = b"RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.\0" ;
pub const RMW_INET_ADDRSTRLEN: u32 = 48;
pub const RMW_NODE_NAME_VALID: u32 = 0;
pub const RMW_NODE_NAME_INVALID_IS_EMPTY_STRING: u32 = 1;
pub const RMW_NODE_NAME_INVALID_CONTAINS_UNALLOWED_CHARACTERS: u32 = 2;
pub const RMW_NODE_NAME_INVALID_STARTS_WITH_NUMBER: u32 = 3;
pub const RMW_NODE_NAME_INVALID_TOO_LONG: u32 = 4;
pub const RMW_NODE_NAME_MAX_NAME_LENGTH: u32 = 255;
pub const RMW_TOPIC_VALID: u32 = 0;
pub const RMW_TOPIC_INVALID_IS_EMPTY_STRING: u32 = 1;
pub const RMW_TOPIC_INVALID_NOT_ABSOLUTE: u32 = 2;
pub const RMW_TOPIC_INVALID_ENDS_WITH_FORWARD_SLASH: u32 = 3;
pub const RMW_TOPIC_INVALID_CONTAINS_UNALLOWED_CHARACTERS: u32 = 4;
pub const RMW_TOPIC_INVALID_CONTAINS_REPEATED_FORWARD_SLASH: u32 = 5;
pub const RMW_TOPIC_INVALID_NAME_TOKEN_STARTS_WITH_NUMBER: u32 = 6;
pub const RMW_TOPIC_INVALID_TOO_LONG: u32 = 7;
pub const RMW_TOPIC_MAX_NAME_LENGTH: u32 = 247;
pub const RMW_NAMESPACE_VALID: u32 = 0;
pub const RMW_NAMESPACE_INVALID_IS_EMPTY_STRING: u32 = 1;
pub const RMW_NAMESPACE_INVALID_NOT_ABSOLUTE: u32 = 2;
pub const RMW_NAMESPACE_INVALID_ENDS_WITH_FORWARD_SLASH: u32 = 3;
pub const RMW_NAMESPACE_INVALID_CONTAINS_UNALLOWED_CHARACTERS: u32 = 4;
pub const RMW_NAMESPACE_INVALID_CONTAINS_REPEATED_FORWARD_SLASH: u32 = 5;
pub const RMW_NAMESPACE_INVALID_NAME_TOKEN_STARTS_WITH_NUMBER: u32 = 6;
pub const RMW_NAMESPACE_INVALID_TOO_LONG: u32 = 7;
pub const RMW_NAMESPACE_MAX_LENGTH: u32 = 245;
#[doc = " The type that holds a return value for an rcutils operation."]
pub type rcutils_ret_t = ::std::os::raw::c_int;
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_allocator_s {
    #[doc = " Allocate memory, given a size and the `state` pointer.\n** An error should be indicated by returning `NULL`. */"]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Deallocate previously allocated memory, mimicking free().\n** Also takes the `state` pointer. */"]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Reallocate if possible, otherwise it deallocates and allocates.\n**\n* Also takes the `state` pointer.\n*\n* If unsupported then do deallocate and then allocate.\n* This should behave as realloc() does, as opposed to posix's\n* [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given\n* by pointer will not be free'd automatically if realloc() fails.\n* For reallocf-like behavior use rcutils_reallocf().\n* This function must be able to take an input pointer of `NULL` and succeed.\n*/"]
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Allocate memory with all elements set to zero, given a number of elements and their size.\n** An error should be indicated by returning `NULL`. */"]
    pub zero_allocate: ::std::option::Option<
        unsafe extern "C" fn(
            number_of_elements: usize,
            size_of_element: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Implementation defined state storage.\n**\n* This is passed as the final parameter to other allocator functions.\n* Note that the contents of the state can be modified even in const-qualified\n* allocator objects.\n*/"]
    pub state: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_allocator_s"][::std::mem::size_of::<rcutils_allocator_s>() - 40usize];
    ["Alignment of rcutils_allocator_s"][::std::mem::align_of::<rcutils_allocator_s>() - 8usize];
    ["Offset of field: rcutils_allocator_s::allocate"]
        [::std::mem::offset_of!(rcutils_allocator_s, allocate) - 0usize];
    ["Offset of field: rcutils_allocator_s::deallocate"]
        [::std::mem::offset_of!(rcutils_allocator_s, deallocate) - 8usize];
    ["Offset of field: rcutils_allocator_s::reallocate"]
        [::std::mem::offset_of!(rcutils_allocator_s, reallocate) - 16usize];
    ["Offset of field: rcutils_allocator_s::zero_allocate"]
        [::std::mem::offset_of!(rcutils_allocator_s, zero_allocate) - 24usize];
    ["Offset of field: rcutils_allocator_s::state"]
        [::std::mem::offset_of!(rcutils_allocator_s, state) - 32usize];
};
impl Default for rcutils_allocator_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
pub type rcutils_allocator_t = rcutils_allocator_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized allocator.\n**\n* Note that this is an invalid allocator and should only be used as a placeholder.\n*/"]
    pub fn rcutils_get_zero_initialized_allocator() -> rcutils_allocator_t;
}
unsafe extern "C" {
    #[doc = " Return a properly initialized rcutils_allocator_t with default values.\n**\n* This defaults to:\n*\n* - allocate = wraps malloc()\n* - deallocate = wraps free()\n* - reallocate = wraps realloc()\n* - zero_allocate = wraps calloc()\n* - state = `NULL`\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*/"]
    pub fn rcutils_get_default_allocator() -> rcutils_allocator_t;
}
unsafe extern "C" {
    #[doc = " Return true if the given allocator has non-null function pointers.\n**\n* \\param[in] allocator to be checked by the function\n* \\return `true` if the allocator is valid, `false` otherwise.\n*/"]
    pub fn rcutils_allocator_is_valid(allocator: *const rcutils_allocator_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).\n**\n* This function will return `NULL` if the allocator is `NULL` or has `NULL` for\n* function pointer fields.\n* \\param[inout] pointer to the memory which will be reallocated\n* \\param[in] size in bytes\n* \\param[in] allocator to be used to allocate and deallocate memory\n*/"]
    pub fn rcutils_reallocf(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Return a duplicated string with an allocator, or null if an error occurs.\n**\n* This function is identical to rcutils_strndup() except the length of the\n* c string does not have to be given and therefore the c string must be\n* null terminated.\n*\n* \\see rcutils_strndup()\n*\n* \\param[in] str null terminated c string to be duplicated\n* \\param[in] allocator the allocator to use for allocation\n* \\return duplicated string, or\n* \\return `NULL` if there is an error.\n*/"]
    pub fn rcutils_strdup(
        str_: *const ::std::os::raw::c_char,
        allocator: rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return a duplicated string with an allocator, or null if an error occurs.\n**\n* This function can fail and return null if memory cannot be allocated or\n* if the input c string pointer is null.\n* In both cases no error message is set.\n* The returned string should be deallocated using the given allocator when\n* it is no longer needed.\n*\n* The string_length given does not include the null terminating character.\n* Therefore a string_length of 0 will still result in a duplicated string, but\n* the string will be an empty string of strlen 0, but it still must be\n* deallocated.\n* All returned strings are null terminated.\n*\n* \\param[in] str null terminated c string to be duplicated\n* \\param[in] string_length length of the string to duplicate\n* \\param[in] allocator the allocator to use for allocation\n* \\return duplicated string, or\n* \\return `NULL` if there is an error.\n*/"]
    pub fn rcutils_strndup(
        str_: *const ::std::os::raw::c_char,
        string_length: usize,
        allocator: rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __int64_t = ::std::os::raw::c_long;
pub type __int_least64_t = __int64_t;
pub type int_least64_t = __int_least64_t;
pub type va_list = __builtin_va_list;
unsafe extern "C" {
    #[doc = " Format a string.\n**\n* This function just wraps snprintf() as defined in C11 in a portable way.\n*\n* On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but\n* only returns -1 if errno is not 0.\n* Unlike _snprintf_s() which returns -1 when truncation occurs, this function\n* behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):\n*\n* > Number of characters written if successful or negative value if an error\n* > occurred.\n* > If the resulting string gets truncated due to buf_size limit, function\n* > returns the total number of characters (not including the terminating\n* > null-byte) which would have been written, if the limit was not imposed.\n*\n* If `NULL` and `0` are given for buffer and buffer_size respectively, the\n* size of the string that would be generated is returned.\n* Either snprintf() or _vscprintf() is used to calculate this value.\n*\n* \\see snprintf()\n* \\see _snprintf_s()\n* \\return the number of bytes that would have been written given enough space, or\n* \\return a negative number if there is an error, but unlike _snprintf_s(),\n*   -1 is not returned if there is truncation.\n*/"]
    pub fn rcutils_snprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Format a string with va_list for arguments, see rcutils_snprintf()."]
    pub fn rcutils_vsnprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rcutils_fault_injection_is_test_complete() -> bool;
}
unsafe extern "C" {
    #[doc = " \\brief Atomically set the fault injection counter.\n\n This is typically not the preferred method of interacting directly with the fault injection\n logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead.\n\n This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with\n something like the following:\n\n RCUTILS_FAULT_INJECTION_TEST({\n     ...  // code to run with fault injection\n     int64_t count = rcutils_fault_injection_get_count();\n     rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n     ...  // code to run without fault injection\n     rcutils_fault_injection_set_count(count);\n     ...  // code to run with fault injection\n });\n\n \\param count The count to set the fault injection counter to. If count is negative, then fault\n injection errors will be disabled. The counter is globally initialized to\n RCUTILS_FAULT_INJECTION_NEVER_FAIL."]
    pub fn rcutils_fault_injection_set_count(count: int_least64_t);
}
unsafe extern "C" {
    #[doc = " \\brief Atomically get the fault injection counter value\n\n This function is typically not used directly but instead indirectly inside an\n `RCUTILS_FAULT_INJECTION_TEST`"]
    pub fn rcutils_fault_injection_get_count() -> int_least64_t;
}
#[doc = " Struct wrapping a fixed-size c string used for returning the formatted error string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_string_s {
    #[doc = " The fixed-size C string used for returning the formatted error string."]
    pub str_: [::std::os::raw::c_char; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_error_string_s"][::std::mem::size_of::<rcutils_error_string_s>() - 1024usize];
    ["Alignment of rcutils_error_string_s"]
        [::std::mem::align_of::<rcutils_error_string_s>() - 1usize];
    ["Offset of field: rcutils_error_string_s::str_"]
        [::std::mem::offset_of!(rcutils_error_string_s, str_) - 0usize];
};
impl Default for rcutils_error_string_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct wrapping a fixed-size c string used for returning the formatted error string."]
pub type rcutils_error_string_t = rcutils_error_string_s;
#[doc = " Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_state_s {
    #[doc = " User message storage, limited to RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH characters."]
    pub message: [::std::os::raw::c_char; 768usize],
    #[doc = " File name, limited to what's left from RCUTILS_ERROR_STATE_MAX_SIZE characters\n after subtracting storage for others."]
    pub file: [::std::os::raw::c_char; 229usize],
    #[doc = " Line number of error."]
    pub line_number: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_error_state_s"][::std::mem::size_of::<rcutils_error_state_s>() - 1008usize];
    ["Alignment of rcutils_error_state_s"]
        [::std::mem::align_of::<rcutils_error_state_s>() - 8usize];
    ["Offset of field: rcutils_error_state_s::message"]
        [::std::mem::offset_of!(rcutils_error_state_s, message) - 0usize];
    ["Offset of field: rcutils_error_state_s::file"]
        [::std::mem::offset_of!(rcutils_error_state_s, file) - 768usize];
    ["Offset of field: rcutils_error_state_s::line_number"]
        [::std::mem::offset_of!(rcutils_error_state_s, line_number) - 1000usize];
};
impl Default for rcutils_error_state_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."]
pub type rcutils_error_state_t = rcutils_error_state_s;
unsafe extern "C" {
    #[doc = " Forces initialization of thread-local storage if called in a newly created thread.\n**\n* If this function is not called beforehand, then the first time the error\n* state is set or the first time the error message is retrieved, the default\n* allocator will be used to allocate thread-local storage.\n*\n* This function may or may not allocate memory.\n* The system's thread-local storage implementation may need to allocate\n* memory, since it usually has no way of knowing how much storage is needed\n* without knowing how many threads will be created.\n* Most implementations (e.g. C11, C++11, and pthread) do not have ways to\n* specify how this memory is allocated, but if the implementation allows, the\n* given allocator to this function will be used, but is otherwise unused.\n* This only occurs when creating and destroying threads, which can be avoided\n* in the \"steady\" state by reusing pools of threads.\n*\n* It is worth considering that repeated thread creation and destruction will\n* result in repeated memory allocations and could result in memory\n* fragmentation.\n* This is typically avoided anyways by using pools of threads.\n*\n* In case an error is indicated by the return code, no error message will have\n* been set.\n*\n* If called more than once in a thread, or after implicitly initialized by\n* setting the error state, it will still return `RCUTILS_RET_OK`, even\n* if the given allocator is invalid.\n* Essentially this function does nothing if thread-local storage has already\n* been called.\n* If already initialized, the given allocator is ignored, even if it does not\n* match the allocator used originally to initialize the thread-local storage.\n*\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, or\n* \\return #RCUTILS_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcutils_initialize_error_handling_thread_local_storage(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the error message, as well as the file and line on which it occurred.\n**\n* This is not meant to be used directly, but instead via the\n* RCUTILS_SET_ERROR_MSG(msg) macro.\n*\n* The error_msg parameter is copied into the internal error storage and must\n* be null terminated.\n* The file parameter is copied into the internal error storage and must\n* be null terminated.\n*\n* \\param[in] error_string The error message to set.\n* \\param[in] file The path to the file in which the error occurred.\n* \\param[in] line_number The line number on which the error occurred.\n*/"]
    pub fn rcutils_set_error_state(
        error_string: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line_number: usize,
    );
}
unsafe extern "C" {
    #[doc = " Return `true` if the error is set, otherwise `false`."]
    pub fn rcutils_error_is_set() -> bool;
}
unsafe extern "C" {
    #[doc = " Return an rcutils_error_state_t which was set with rcutils_set_error_state().\n**\n* The returned pointer will be NULL if no error has been set in this thread.\n*\n* The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,\n* or rcutils_reset_error are called in the same thread.\n*\n* \\return A pointer to the current error state struct.\n*/"]
    pub fn rcutils_get_error_state() -> *const rcutils_error_state_t;
}
unsafe extern "C" {
    #[doc = " Return the error message followed by `, at <file>:<line>` if set, else \"error not set\".\n**\n* This function is \"safe\" because it returns a copy of the current error\n* string or one containing the string \"error not set\" if no error was set.\n* This ensures that the copy is owned by the calling thread and is therefore\n* never invalidated by other error handling calls, and that the C string\n* inside is always valid and null terminated.\n*\n* \\return The current error string, with file and line number, or \"error not set\" if not set.\n*/"]
    pub fn rcutils_get_error_string() -> rcutils_error_string_t;
}
unsafe extern "C" {
    #[doc = " Reset the error state by clearing any previously set error state."]
    pub fn rcutils_reset_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for an array list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_array_list_impl_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_array_list_s"][::std::mem::size_of::<rcutils_array_list_s>() - 8usize];
    ["Alignment of rcutils_array_list_s"][::std::mem::align_of::<rcutils_array_list_s>() - 8usize];
    ["Offset of field: rcutils_array_list_s::impl_"]
        [::std::mem::offset_of!(rcutils_array_list_s, impl_) - 0usize];
};
impl Default for rcutils_array_list_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for an array list."]
pub type rcutils_array_list_t = rcutils_array_list_s;
unsafe extern "C" {
    #[doc = " Return an empty array_list struct.\n**\n* This function returns an empty and zero initialized array_list struct.\n* Calling rcutils_array_list_fini() on any non-initialized instance leads\n* to undefined behavior.\n* Every instance of array_list_t has to either be zero_initialized with this\n* function or manually allocated.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n*\n* ```c\n* rcutils_array_list_t foo;\n* rcutils_array_list_fini(&foo); // undefined behavior!\n*\n* rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();\n* rcutils_array_list_fini(&bar); // ok\n* ```\n*/"]
    pub fn rcutils_get_zero_initialized_array_list() -> rcutils_array_list_t;
}
unsafe extern "C" {
    #[doc = " Initialize an array list with a given initial capacity.\n**\n* This function will initialize a given, zero initialized, array_list to\n* a given size.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n*\n* ```c\n* rcutils_allocator_t allocator = rcutils_get_default_allocator();\n* rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();\n* rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... error handling\n* }\n* int data = 42;\n* int out_data = 0;\n* ret = rcutils_array_list_add(&array_list, &data);\n* data++;\n* ret = rcutils_array_list_get(&array_list, 0, &out_data);\n* assert(42 == out_data);\n* ret = rcutils_array_list_fini(&array_list);\n* ```\n*\n* \\param[inout] array_list object to be initialized\n* \\param[in] initial_capacity the initial capacity to allocate in the list\n* \\param[in] data_size the size (in bytes) of the data object being stored in the list\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_init(
        array_list: *mut rcutils_array_list_t,
        initial_capacity: usize,
        data_size: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize an array list, reclaiming all resources.\n**\n* This function reclaims any memory owned by the array list.\n*\n* The allocator used to initialize the array list is used to deallocate each\n* entry in the list and the list itself.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] array_list object to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_fini(array_list: *mut rcutils_array_list_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Adds an entry to the list\n**\n* This function adds the provided data to the end of the list. A shallow copy of\n* the provided data is made to store in the list instead of just storing\n* the pointer to the provided data.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] data a pointer to the data to add to the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_add(
        array_list: *mut rcutils_array_list_t,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Sets an entry in the list to the provided data\n**\n* This function sets the provided data at the specified index in the list.\n* A shallow copy of the provided data is made to store in the list instead\n* of just storing the pointer to the provided data.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the position in the list to set the data\n* \\param[in] data a pointer to the data that will be set in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_set(
        array_list: *mut rcutils_array_list_t,
        index: usize,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Removes an entry in the list at the provided index\n**\n* This function removes data from the list at the specified index. The capacity\n* of the list will never decrease when entries are removed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the index of the item to remove from the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_remove(
        array_list: *mut rcutils_array_list_t,
        index: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Retrieves an entry in the list at the provided index\n**\n* This function retrieves a copy of the data stored in the list at the provided index.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the index at which to get the data\n* \\param[out] data a copy of the data stored in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_get(
        array_list: *const rcutils_array_list_t,
        index: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Retrieves the size of the provided array_list\n**\n* This function retrieves the number of items in the provided array list\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n*\n* \\param[in] array_list list to get the size of\n* \\param[out] size The number of items currently stored in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_get_size(
        array_list: *const rcutils_array_list_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a char array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_char_array_s {
    #[doc = " A pointer to the allocated memory for this char array."]
    pub buffer: *mut ::std::os::raw::c_char,
    #[doc = " if this is true, we may safely free/realloc the buffer as needed;\n otherwise we will leave the buffer alone and alloc new memory if\n more space is needed"]
    pub owns_buffer: bool,
    #[doc = " The length of the data stored in the buffer pointer."]
    pub buffer_length: usize,
    #[doc = " The maximum capacity of the buffer pointer."]
    pub buffer_capacity: usize,
    #[doc = " The allocator used to allocate and free the data in the pointer."]
    pub allocator: rcutils_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_char_array_s"][::std::mem::size_of::<rcutils_char_array_s>() - 72usize];
    ["Alignment of rcutils_char_array_s"][::std::mem::align_of::<rcutils_char_array_s>() - 8usize];
    ["Offset of field: rcutils_char_array_s::buffer"]
        [::std::mem::offset_of!(rcutils_char_array_s, buffer) - 0usize];
    ["Offset of field: rcutils_char_array_s::owns_buffer"]
        [::std::mem::offset_of!(rcutils_char_array_s, owns_buffer) - 8usize];
    ["Offset of field: rcutils_char_array_s::buffer_length"]
        [::std::mem::offset_of!(rcutils_char_array_s, buffer_length) - 16usize];
    ["Offset of field: rcutils_char_array_s::buffer_capacity"]
        [::std::mem::offset_of!(rcutils_char_array_s, buffer_capacity) - 24usize];
    ["Offset of field: rcutils_char_array_s::allocator"]
        [::std::mem::offset_of!(rcutils_char_array_s, allocator) - 32usize];
};
impl Default for rcutils_char_array_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for a char array."]
pub type rcutils_char_array_t = rcutils_char_array_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized char array struct.\n**\n* \\return rcutils_char_array_t a zero initialized char array struct\n*/"]
    pub fn rcutils_get_zero_initialized_char_array() -> rcutils_char_array_t;
}
unsafe extern "C" {
    #[doc = " Initialize a zero initialized char array struct.\n**\n* This function may leak if the char array struct is already\n* pre-initialized.\n* If the capacity is set to 0, no memory is allocated and the internal buffer\n* is still NULL.\n*\n* \\param[in] char_array a pointer to the to be initialized char array struct\n* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream\n* \\param[in] allocator the allocator to use for the memory allocation\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_BAD_ALLOC if no memory could be allocated correctly\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_init(
        char_array: *mut rcutils_char_array_t,
        buffer_capacity: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize a char array struct.\n**\n* Cleans up and deallocates any resources owned by rcutils_char_array_t.\n* The array passed to this function needs to have been initialized by\n* rcutils_char_array_init().\n* If .owns_buffer is false, this function has no effect because that\n* implies that the char_array does not own the internal buffer.\n* Passing an uninitialized instance to this function leads to undefined\n* behavior.\n*\n* \\param[in] char_array pointer to the rcutils_char_array_t to be cleaned up\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the char_array argument is invalid\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_fini(char_array: *mut rcutils_char_array_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Resize the internal buffer of the char array.\n**\n* The internal buffer of the char array can be resized dynamically if needed.\n* If the new size is smaller than the current capacity, then the memory is\n* truncated.\n* Be aware, that this will deallocate the memory and therefore invalidates any\n* pointers to this storage.\n* If the new size is larger, new memory is getting allocated and the existing\n* content is copied over.\n* Note that if the array doesn't own the current buffer the function just\n* allocates a new block of memory and copies the contents of the old buffer\n* instead of resizing the existing buffer.\n*\n* \\param[in] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_resize(
        char_array: *mut rcutils_char_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Expand the internal buffer of the char array.\n**\n* This function is equivalent to `rcutils_char_array_resize` except that it resizes\n* the internal buffer only when it is not big enough.\n* If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without\n* doing anything.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_expand_as_needed(
        char_array: *mut rcutils_char_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Produce output according to format and args.\n**\n* This function is equivalent to `vsprintf(char_array->buffer, format, args)`\n* except that the buffer grows as needed so a user doesn't have to deal with\n* memory management.\n* The `va_list args` will be cloned before being used, so a user can safely\n* use it again after calling this function.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* written to\n* \\param[in] format the format string used by the underlying `vsnprintf`\n* \\param[in] args the `va_list` used by the underlying `vsnprintf`\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_vsprintf(
        char_array: *mut rcutils_char_array_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Append a string (or part of it) to the string in buffer.\n**\n* This function treats the internal buffer as a string and appends the src string to it.\n* If src is longer than n, n bytes will be used and an extra null byte will be appended.\n* It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer\n* grows as needed so a user doesn't have to deal with memory management.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being appended to\n* \\param[in] src the string to be appended to the end of the string in buffer\n* \\param[in] n it uses at most n bytes from the src string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strncat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Append a string to the string in buffer.\n**\n* This function treats the internal buffer as a string and appends the src string to it.\n* It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer\n* grows as needed. That is to say, a user can safely use it without doing calculation or\n* checks on the sizes of the src and buffer.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* appended to\n* \\param[in] src the string to be appended to the end of the string in buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strcat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Copy memory to buffer.\n**\n* This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer\n* grows as needed so a user doesn't have to worry about overflow.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] src the memory to be copied from\n* \\param[in] n a total of n bytes will be copied\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_memcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Copy a string to buffer.\n**\n* This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer\n* grows as needed so that `src` will fit without overflow.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* copied to\n* \\param[in] src the string to be copied from\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_hash_map_impl_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_hash_map_s"][::std::mem::size_of::<rcutils_hash_map_s>() - 8usize];
    ["Alignment of rcutils_hash_map_s"][::std::mem::align_of::<rcutils_hash_map_s>() - 8usize];
    ["Offset of field: rcutils_hash_map_s::impl_"]
        [::std::mem::offset_of!(rcutils_hash_map_s, impl_) - 0usize];
};
impl Default for rcutils_hash_map_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for a hash map."]
pub type rcutils_hash_map_t = rcutils_hash_map_s;
#[doc = " The function signature for a key hashing function.\n**\n* \\param[in] key The key that needs to be hashed\n* \\return A hash value for the provided string\n*/"]
pub type rcutils_hash_map_key_hasher_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> usize>;
#[doc = " The function signature for a key comparison function.\n**\n* \\param[in] val1 The first value to compare\n* \\param[in] val2 The second value to compare\n* \\return A negative number if val1 < val2, or\n* \\return A positve number if val1 > val2, or\n* \\return Zero if val1 == val2.\n*/"]
pub type rcutils_hash_map_key_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " A hashing function for a null terminated c string.\n**\n* A hashing function for a null terminated c string.\n* Should be used when your key is just a pointer to a c-string\n*/"]
    pub fn rcutils_hash_map_string_hash_func(key_str: *const ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = " A comparison function for a null terminated c string.\n**\n* A comparison function for a null terminated c string.\n* Should be used when your key is just a pointer to a c-string\n*/"]
    pub fn rcutils_hash_map_string_cmp_func(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return an empty hash_map struct.\n**\n* This function returns an empty and zero initialized hash_map struct.\n* All hash maps should be initialized with this or manually initialized\n* before being used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* // Do not do this:\n* // rcutils_hash_map_t foo;\n* // rcutils_hash_map_fini(&foo); // undefined behavior!\n*\n* // Do this instead:\n* rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();\n* rcutils_hash_map_fini(&bar); // ok\n* ```\n* */"]
    pub fn rcutils_get_zero_initialized_hash_map() -> rcutils_hash_map_t;
}
unsafe extern "C" {
    #[doc = " Initialize a rcutils_hash_map_t, allocating space for given capacity.\n**\n* This function initializes the rcutils_hash_map_t with a given initial\n* capacity for entries.\n* Note this does not allocate space for keys or values in the hash_map, just the\n* arrays of pointers to the keys and values.\n* rcutils_hash_map_set() should still be used when assigning values.\n*\n* The hash_map argument should point to allocated memory and should have\n* been zero initialized with rcutils_get_zero_initialized_hash_map().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();\n* rcutils_ret_t ret =\n*   rcutils_hash_map_init(&hash_map, 10, rcutils_get_default_allocator());\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* // ... use the hash_map and when done:\n* ret = rcutils_hash_map_fini(&hash_map);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* ```\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be initialized\n* \\param[in] initial_capacity the amount of initial capacity for the hash_map\n* \\param[in] key_size the size (in bytes) of the key used to index the data\n* \\param[in] data_size the size (in bytes) of the data being stored\n* \\param[in] key_hashing_func a function that returns a hashed value for a key\n* \\param[in] key_cmp_func a function used to compare keys\n* \\param[in] allocator the allocator to use through out the lifetime of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if alread initialized, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_init(
        hash_map: *mut rcutils_hash_map_t,
        initial_capacity: usize,
        key_size: usize,
        data_size: usize,
        key_hashing_func: rcutils_hash_map_key_hasher_t,
        key_cmp_func: rcutils_hash_map_key_cmp_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize the previously initialized hash_map struct.\n**\n* This function will free any resources which were created when initializing\n* or when calling rcutils_hash_map_set().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_fini(hash_map: *mut rcutils_hash_map_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the current capacity of the hash_map.\n**\n* This function will return the internal capacity of the hash_map, which is the\n* number of buckets the hash_map uses to sort the keys.\n* The capacity does not indicate how many key value pairs are stored in the\n* hash_map, the rcutils_hash_map_get_size() function can provide that, nor the\n* maximum number that can be stored without increasing the capacity.\n* The capacity can be set initially with rcutils_hash_map_init().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[out] capacity capacity of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_capacity(
        hash_map: *const rcutils_hash_map_t,
        capacity: *mut usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the current size of the hash_map.\n**\n* This function will return the internal size of the hash_map, which is the\n* current number of key value pairs in the hash_map.\n* The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[out] size size of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_size(
        hash_map: *const rcutils_hash_map_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Set a key value pair in the hash_map, increasing capacity if necessary.\n**\n* If the key already exists in the map then the value is updated to the new value\n* provided. If it does not already exist then a new entry is added for the new key\n* and value. The capacity will be increased if needed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be updated\n* \\param[in] key hash_map key\n* \\param[in] value value for given hash_map key\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_set(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Unset a key value pair in the hash_map.\n**\n* Unsets the key value pair in the hash_map and frees any internal resources allocated\n* for the entry. This function will never decrease the capacity when removing keys.\n* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be updated\n* \\param[in] key hash_map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if the key is not found in the map, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_unset(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get whether or not a key exists.\n**\n* Returns true if the provided key exists in the hash_map or false if it does not or\n* if the hash_map or key are invalid.\n* In all cases no error message is set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be searched\n* \\param[in] key hash_map key, must be null terminated c string\n* \\return `true` if key is in the hash_map, or\n* \\return `false` if key is not in the hash_map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the hash_map is invalid.\n*/"]
    pub fn rcutils_hash_map_key_exists(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get value given a key.\n**\n* This function can be used to retrieve a shallow copy of the stored data. The data\n* pointer must point to a section of memory large enough to copy the full size of\n* the data being stored, which is specified when the hash_map in initialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be searched\n* \\param[in] key hash_map key to look up the data for\n* \\param[out] data A copy of the data stored in the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_NOT_FOUND if the key doesn't exist in the map, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the next key in the hash_map, unless NULL is given, then get the first key.\n**\n* This function allows you to iteratively get each key/value pair in the hash_map.\n*\n* If NULL is given for the previous_key, then the first key in the hash_map is returned.\n* If that returned key is given as the previous_key for the next call to this function,\n* then the next key in the hash_map is returned.\n* If there are no more keys in the hash_map or if the given key is not in the hash_map,\n* an error will be returned.\n*\n* The order of the keys in the hash_map is arbitrary and if the hash_map is modified\n* between calls to this function the behavior is undefined.\n* If the hash_map is modified then iteration should begin again by passing NULL to\n* get the first key again.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* printf(\"entries in the hash_map:\\n\");\n* int key = 0, data = 0;\n* rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);\n* while (RCUTILS_RET_OK == status) {\n*   printf(\"%i: %i\\n\", key, data);\n*   status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);\n* }\n* ```\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[in] previous_key NULL to get the first key or the previous key to get the next for\n* \\param[out] key A copy of the next key in the sequence\n* \\param[out] data A copy of the next data in the sequence\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_NOT_FOUND if the previous_key doesn't exist in the map, or\n* \\return #RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES if there is no more data beyound the previous_key, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_next_key_and_data(
        hash_map: *const rcutils_hash_map_t,
        previous_key: *const ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Interface to qsort with rcutils-style argument validation.\n**\n* This function changes the order of the elements in the array so that they\n* are in ascending order according to the given comparison function.\n*\n* This function is thread-safe.\n*\n* \\param[inout] ptr object whose elements should be sorted.\n* \\param[in] count number of elements present in the object.\n* \\param[in] size size of each element, in bytes.\n* \\param[in] comp function used to compare two elements.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_qsort(
        ptr: *mut ::std::os::raw::c_void,
        count: usize,
        size: usize,
        comp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a string array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_array_s {
    #[doc = " The number of strings that can be stored in the string array."]
    pub size: usize,
    #[doc = " The allocated memory for the string array."]
    pub data: *mut *mut ::std::os::raw::c_char,
    #[doc = " The allocator used to allocate and free memory for the string array."]
    pub allocator: rcutils_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_string_array_s"][::std::mem::size_of::<rcutils_string_array_s>() - 56usize];
    ["Alignment of rcutils_string_array_s"]
        [::std::mem::align_of::<rcutils_string_array_s>() - 8usize];
    ["Offset of field: rcutils_string_array_s::size"]
        [::std::mem::offset_of!(rcutils_string_array_s, size) - 0usize];
    ["Offset of field: rcutils_string_array_s::data"]
        [::std::mem::offset_of!(rcutils_string_array_s, data) - 8usize];
    ["Offset of field: rcutils_string_array_s::allocator"]
        [::std::mem::offset_of!(rcutils_string_array_s, allocator) - 16usize];
};
impl Default for rcutils_string_array_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for a string array."]
pub type rcutils_string_array_t = rcutils_string_array_s;
unsafe extern "C" {
    #[doc = " Return an empty string array struct.\n**\n* This function returns an empty and zero initialized string array struct.\n* Calling rcutils_string_array_fini() on any non-initialized instance leads\n* to undefined behavior.\n* Every instance of string_array_t has to either be zero_initialized with this\n* function or manually allocated.\n*\n* Example:\n*\n* ```c\n* rcutils_string_array_t foo;\n* rcutils_string_array_fini(&foo); // undefined behavior!\n*\n* rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();\n* rcutils_string_array_fini(&bar); // ok\n* ```\n*/"]
    pub fn rcutils_get_zero_initialized_string_array() -> rcutils_string_array_t;
}
unsafe extern "C" {
    #[doc = " Initialize a string array with a given size.\n**\n* This function will initialize a given, zero initialized, string array to\n* a given size.\n*\n* Note that putting a string into the array gives owenship to the array.\n*\n* Example:\n*\n* ```c\n* rcutils_allocator_t allocator = rcutils_get_default_allocator();\n* rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();\n* rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... error handling\n* }\n* string_array.data[0] = rcutils_strdup(\"Hello\", &allocator);\n* string_array.data[1] = rcutils_strdup(\"World\", &allocator);\n* ret = rcutils_string_array_fini(&string_array);\n* ```\n*\n* \\param[inout] string_array object to be initialized\n* \\param[in] size the size the array should be\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_init(
        string_array: *mut rcutils_string_array_t,
        size: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize a string array, reclaiming all resources.\n**\n* This function reclaims any memory owned by the string array, including the\n* strings it references.\n*\n* The allocator used to initialize the string array is used to deallocate each\n* string in the array and the array of strings itself.\n*\n* \\param[inout] string_array object to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_fini(string_array: *mut rcutils_string_array_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Compare two string arrays.\n**\n* The two string arrays are compared according to lexicographical order.\n*\n* \\param[in] lhs The first string array.\n* \\param[in] rhs The second string array.\n* \\param[out] res Negative value if `lhs` appears before `rhs` in lexicographical order.\n*   Zero if `lhs` and `rhs` are equal.\n*   Positive value if `lhs` appears after `rhs` in lexographical order.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any argument is `NULL, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if `lhs->data` or `rhs->data` is `NULL, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_cmp(
        lhs: *const rcutils_string_array_t,
        rhs: *const rcutils_string_array_t,
        res: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Resize a string array, reclaiming removed resources.\n**\n* This function changes the size of an existing string array.\n* If the new size is larger, new entries are added to the end of the array and\n* are zero- initialized.\n* If the new size is smaller, entries are removed from the end of the array\n* and their resources reclaimed.\n*\n* \\par Note:\n* Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini.\n*\n* \\par Note:\n* If this function fails, \\p string_array remains unchanged and should still\n* be reclaimed with ::rcutils_string_array_fini.\n*\n* \\param[inout] string_array object to be resized.\n* \\param[in] new_size the size the array should be changed to.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_resize(
        string_array: *mut rcutils_string_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Lexicographic comparer for pointers to string pointers.\n**\n* This functions compares pointers to string pointers lexicographically\n* ascending.\n*\n* \\param[in] lhs pointer to the first string pointer.\n* \\param[in] rhs pointer to the second string pointer.\n* \\return <0 if lhs is lexicographically lower, or\n* \\return 0 if the strings are the same, or\n* \\return >0 if lhs is lexicographically higher.\n*/"]
    pub fn rcutils_string_array_sort_compare(
        lhs: *const ::std::os::raw::c_void,
        rhs: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a string map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_string_map_impl_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_string_map_s"][::std::mem::size_of::<rcutils_string_map_s>() - 8usize];
    ["Alignment of rcutils_string_map_s"][::std::mem::align_of::<rcutils_string_map_s>() - 8usize];
    ["Offset of field: rcutils_string_map_s::impl_"]
        [::std::mem::offset_of!(rcutils_string_map_s, impl_) - 0usize];
};
impl Default for rcutils_string_map_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for a string map."]
pub type rcutils_string_map_t = rcutils_string_map_s;
unsafe extern "C" {
    #[doc = " Return an empty string map struct.\n**\n* This function returns an empty and zero initialized string map struct.\n*\n* Example:\n*\n* ```c\n* // Do not do this:\n* // rcutils_string_map_t foo;\n* // rcutils_string_map_fini(&foo); // undefined behavior!\n*\n* // Do this instead:\n* rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();\n* rcutils_string_map_fini(&bar); // ok\n* ```\n* */"]
    pub fn rcutils_get_zero_initialized_string_map() -> rcutils_string_map_t;
}
unsafe extern "C" {
    #[doc = " Initialize a rcutils_string_map_t, allocating space for given capacity.\n**\n* This function initializes the rcutils_string_map_t with a given initial\n* capacity for entries.\n* Note this does not allocate space for keys or values in the map, just the\n* arrays of pointers to the keys and values.\n* rcutils_string_map_set() should still be used when assigning values.\n*\n* The string_map argument should point to allocated memory and should have\n* been zero initialized with rcutils_get_zero_initialized_string_map().\n* For example:\n*\n* ```c\n* rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();\n* rcutils_ret_t ret =\n*   rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* // ... use the string map and when done:\n* ret = rcutils_string_map_fini(&string_map);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* ```\n*\n* \\param[inout] string_map rcutils_string_map_t to be initialized\n* \\param[in] initial_capacity the amount of initial capacity for the string map\n* \\param[in] allocator the allocator to use through out the lifetime of the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if already initialized, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_init(
        string_map: *mut rcutils_string_map_t,
        initial_capacity: usize,
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize the previously initialized string map struct.\n**\n* This function will free any resources which were created when initializing\n* or when calling rcutils_string_map_set().\n*\n* \\param[inout] string_map rcutils_string_map_t to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_fini(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the current capacity of the string map.\n**\n* This function will return the internal capacity of the map, which is the\n* maximum number of key value pairs the map could hold.\n* The capacity can be set initially with rcutils_string_map_init() or\n* with rcutils_string_map_reserve().\n* The capacity does not indicate how many key value paris are stored in the\n* map, the rcutils_string_map_get_size() function can provide that.\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[out] capacity capacity of the string map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_capacity(
        string_map: *const rcutils_string_map_t,
        capacity: *mut usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the current size of the string map.\n**\n* This function will return the internal size of the map, which is the\n* current number of key value pairs in the map.\n* The size is changed when calling rcutils_string_map_set_no_resize(),\n* rcutils_string_map_set(), or rcutils_string_map_unset().\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[out] size size of the string map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_size(
        string_map: *const rcutils_string_map_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Reserve a given amount of capacity in the map.\n**\n* Increases the capacity of the map to at least the given size.\n*\n* If the current capacity is less than requested capacity then the capacity\n* is increased using the allocator given during initialization of the map in\n* rcutils_string_map_init().\n* If the requested capacity is less than the current capacity, the capacity\n* may be reduced, but no existing key value pairs will be truncated to do so.\n* In effect, the capacity will be shrunk to fit the number of items in map or\n* the requested capacity, which ever is larger.\n*\n* If recovering all resources is desired first call rcutils_string_map_clear()\n* and then this function with a capacity of 0.\n*\n* \\param[inout] string_map rcutils_string_map_t to have space reserved in\n* \\param[in] capacity requested size to reserve in the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_reserve(
        string_map: *mut rcutils_string_map_t,
        capacity: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Remove all key value pairs from the map.\n**\n* This function will remove all key value pairs from the map, and it will\n* reclaim all resources allocated as a result of setting key value pairs.\n* rcutils_string_map_fini() should still be called after this.\n*\n* \\param[inout] string_map rcutils_string_map_t to be cleared\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_clear(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Set a key value pair in the map, increasing capacity if necessary.\n**\n* The capacity will be increased if needed using rcutils_string_map_reserve().\n* Otherwise it is the same as rcutils_string_map_set_no_resize().\n*\n* \\see rcutils_string_map_set_no_resize()\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\param[in] value value for given map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_set(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Set a key value pair in the map but only if the map has enough capacity.\n**\n* If the map already contains the given key, the existing value will be\n* replaced with the given value.\n* If the map does not contain the given key, and the map has additional\n* unused capacity, then it will store the given key and value in the map.\n* If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE\n* is returned.\n*\n* The given key and value c strings are copied into the map, and so storage is\n* allocated for them in the map when this function is called if necessary.\n* The storage allocated for this purpose is reclaimed either when\n* rcutils_string_map_fini() is called on this map or when using this function\n* or rcutils_string_map_unset().\n*\n* Any allocation that occurs in this functions uses the allocator of the map,\n* which is given when the map is initialized in rcutils_string_map_init().\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\param[in] value value for given map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_NOT_ENOUGH_SPACE if map is full, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_set_no_resize(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Unset a key value pair in the map.\n**\n* The key needs to be a null terminated c string.\n* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if key not found, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_unset(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get whether or not a key exists.\n**\n* The key needs to be a null terminated c string.\n*\n* This function can fail and return false if the key is not found,\n* or the string_map is NULL or invalid, or if the key is NULL.\n* In all cases no error message is set.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key, must be null terminated c string\n* \\return `true` if key is in the map, or\n* \\return `false` if key is not in the map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the string map is invalid.\n*/"]
    pub fn rcutils_string_map_key_exists(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get whether or not a key of known length exists.\n**\n* Identical to rcutils_string_map_key_exists() but without relying on key to be\n* a null terminated c string.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key\n* \\param[in] key_length map key length\n* \\return `true` if key is in the map, or\n* \\return `false` if key is not in the map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the string map is invalid.\n*/"]
    pub fn rcutils_string_map_key_existsn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get value given a key.\n**\n* The key needs to be a null terminated c string.\n*\n* This function can fail, and therefore return NULL, if the key is not found,\n* or the string_map is NULL or invalid, or if the key is NULL.\n* In all cases no error message is set.\n*\n* The returned value string is still owned by the map, and it should not be\n* modified or free'd.\n* This also means that the value pointer becomes invalid if either\n* rcutils_string_map_clear() or rcutils_string_map_fini() are called or if\n* the key value pair is updated or removed with one of rcutils_string_map_set()\n* or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key, must be null terminated c string\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get value given a key and key length.\n**\n* Identical to rcutils_string_map_get() but without relying on key to be a\n* null terminated c string.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key\n* \\param[in] key_length map key length\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_getn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the next key in the map, unless NULL is given, then get the first key.\n**\n* This function allows you iteratively get each key in the map.\n*\n* If NULL is given for the key, then the first key in the map is returned.\n* If that returned key if given to the this function, then the next key in the\n* map is returned.\n* If there are no more keys in the map or if the given key is not in the map,\n* NULL is returned.\n*\n* The order of the keys in the map is arbitrary and if the map is modified\n* between calls to this function the behavior is undefined.\n* If the map is modifeid then iteration should begin again by passing NULL to\n* get the first key again.\n*\n* This function operates based on the address of the pointer, you cannot pass\n* a copy of a key to get the next key.\n*\n* Example:\n*\n* ```c\n* printf(\"keys in the map:\\n\");\n* const char * current_key = rcutils_string_map_get_next_key(&map, NULL);\n* while (current_key) {\n*   printf(\"  - %s\\n\", current_key);\n*   current_key = rcutils_string_map_get_next_key(&map, current_key);\n* }\n* ```\n*\n* NULL can also be returned if NULL is given for the string_map or if the\n* string_map is invalid.\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[in] key NULL to get the first key or the previous key to get the next\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if there are no more keys in the map, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_next_key(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Copy all the key value pairs from one map into another, overwritting and resizing if needed.\n**\n* If the destination string map does not have enough storage, then it is will\n* be resized.\n* If a key value pair exists in the destination map, its value will be\n* replaced with the source map's value.\n*\n* It is possible for only some of the values to be copied if an error happens\n* during the copying process, e.g. if memory allocation fails.\n*\n* \\param[in] src_string_map rcutils_string_map_t to be copied from\n* \\param[inout] dst_string_map rcutils_string_map_t to be copied to\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_copy(
        src_string_map: *const rcutils_string_map_t,
        dst_string_map: *mut rcutils_string_map_t,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a uint8 array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_uint8_array_s {
    #[doc = " The allocated memory for the uint8 array."]
    pub buffer: *mut u8,
    #[doc = " The number of valid elements in the uint8 array."]
    pub buffer_length: usize,
    #[doc = " The maximum capacity of the uint8 array."]
    pub buffer_capacity: usize,
    #[doc = " The allocator used to allocate and free memory for the uint8 array."]
    pub allocator: rcutils_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_uint8_array_s"][::std::mem::size_of::<rcutils_uint8_array_s>() - 64usize];
    ["Alignment of rcutils_uint8_array_s"]
        [::std::mem::align_of::<rcutils_uint8_array_s>() - 8usize];
    ["Offset of field: rcutils_uint8_array_s::buffer"]
        [::std::mem::offset_of!(rcutils_uint8_array_s, buffer) - 0usize];
    ["Offset of field: rcutils_uint8_array_s::buffer_length"]
        [::std::mem::offset_of!(rcutils_uint8_array_s, buffer_length) - 8usize];
    ["Offset of field: rcutils_uint8_array_s::buffer_capacity"]
        [::std::mem::offset_of!(rcutils_uint8_array_s, buffer_capacity) - 16usize];
    ["Offset of field: rcutils_uint8_array_s::allocator"]
        [::std::mem::offset_of!(rcutils_uint8_array_s, allocator) - 24usize];
};
impl Default for rcutils_uint8_array_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure holding the metadata for a uint8 array."]
pub type rcutils_uint8_array_t = rcutils_uint8_array_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized uint8 array struct.\n**\n* \\return rcutils_uint8_array_t a zero initialized uint8 array struct\n*/"]
    pub fn rcutils_get_zero_initialized_uint8_array() -> rcutils_uint8_array_t;
}
unsafe extern "C" {
    #[doc = " Initialize a zero initialized uint8 array struct.\n**\n* This function may leak if the uint8 array struct is already initialized.\n* If the capacity is set to 0, no memory is allocated and the internal buffer\n* is still NULL.\n*\n* \\param[inout] uint8_array a pointer to the to be initialized uint8 array struct\n* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream\n* \\param[in] allocator the allocator to use for the memory allocation\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_init(
        uint8_array: *mut rcutils_uint8_array_t,
        buffer_capacity: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize a uint8 array struct.\n**\n* Cleans up and deallocates any resources used in a rcutils_uint8_array_t.\n* The array passed to this function needs to have been initialized by\n* rcutils_uint8_array_init().\n* Passing an uninitialized instance to this function leads to undefined\n* behavior.\n*\n* \\param[in] uint8_array pointer to the rcutils_uint8_array_t to be cleaned up\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the uint8_array argument is invalid\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_fini(uint8_array: *mut rcutils_uint8_array_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Resize the internal buffer of the uint8 array.\n**\n* The internal buffer of the uint8 array can be resized dynamically if needed.\n* If the new size is smaller than the current capacity, then the memory is\n* truncated.\n* Be aware, that this might deallocate the memory and therefore invalidates any\n* pointers to this storage.\n*\n* \\param[inout] uint8_array pointer to the instance of rcutils_uint8_array_t which is\n* being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_resize(
        uint8_array: *mut rcutils_uint8_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
#[doc = " A single point in time, measured in nanoseconds since the Unix epoch."]
pub type rcutils_time_point_value_t = i64;
#[doc = " A duration of time, measured in nanoseconds."]
pub type rcutils_duration_value_t = i64;
unsafe extern "C" {
    #[doc = " This function returns the time from a system clock.\n The closest equivalent would be to std::chrono::system_clock::now();\n\n The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.\n\n The now argument must point to an allocated rcutils_time_point_value_t object,\n as the result is copied into this variable.\n\n <hr>\n Attribute          | Adherence\n ------------------ | -------------\n Allocates Memory   | No\n Thread-Safe        | Yes\n Uses Atomics       | No\n Lock-Free          | Yes\n\n \\param[out] now a datafield in which the current time is stored\n \\return #RCUTILS_RET_OK if the current time was successfully obtained, or\n \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    pub fn rcutils_system_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the current time as a rcutils_time_point_value_t object.\n**\n* This function returns the time from a monotonically increasing clock.\n* The closest equivalent would be to std::chrono::steady_clock::now();\n*\n* The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.\n*\n* The now argument must point to an allocated rcutils_time_point_value_t object,\n* as the result is copied into this variable.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] now a struct in which the current time is stored\n* \\return #RCUTILS_RET_OK if the current time was successfully obtained, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_steady_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the current time as a rcutils_time_point_value_t object.\n**\n* This function returns the time from a monotonically increasing slew-free clock.\n*\n* The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.\n*\n* The now argument must point to an allocated rcutils_time_point_value_t object,\n* as the result is copied into this variable.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] now a struct in which the current time is stored\n* \\return #RCUTILS_RET_OK if the current time was successfully obtained, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_raw_steady_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Return a time point as nanoseconds in a string.\n**\n* The number is always fixed width, with left padding zeros up to the maximum\n* number of digits the time point can represent.\n* Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.\n* Negative values will have a leading `-`, so they will be one character\n* longer than the positive values.\n*\n* The recommended minimum size of the input string is 32 characters, but\n* 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently\n* large for both positive and negative values.\n* If the given string is not large enough, the result will be truncated.\n* If you need a string with variable width, using `snprintf()` directly is\n* recommended.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if `snprintf()` does not allocate additional memory internally</i>\n*\n* \\param[in] time_point the time to be made into a string\n* \\param[out] str the output string in which it is stored\n* \\param[in] str_size the size of the output string\n* \\return #RCUTILS_RET_OK if successful (even if truncated), or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_time_point_value_as_nanoseconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Return a time point as an datetime in local time with milliseconds in a string.\n**\n*\n* If the given string is not large enough, the result will be truncated.\n* If you need a string with variable width, using `snprintf()` directly is\n* recommended.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if `snprintf()` does not allocate additional memory internally</i>\n*\n* \\param[in] time_point the time to be made into a string\n* \\param[out] str the output string in which it is stored\n* \\param[in] str_size the size of the output string\n* \\return #RCUTILS_RET_OK if successful (even if truncated), or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_time_point_value_as_date_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Return a time point as floating point seconds in a string.\n**\n* The number is always fixed width, with left padding zeros up to the maximum\n* number of digits for the mantissa that the time point can represent and a\n* characteristic (fractional-part) with a fixed width of 9 digits.\n* Right now that means the mantissa is always 10 digits to add up to 19 total\n* for the signed 64-bit time point type.\n* Negative values will have a leading `-`, so they will be one character\n* longer then positive values.\n*\n* The recommended minimum size of the input string is 32 characters, but\n* 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should\n* be sufficient for now.\n* If the given string is not large enough, the result will be truncated.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if `snprintf()` does not allocate additional memory internally</i>\n*\n* \\param[in] time_point the time to be made into a string\n* \\param[out] str the output string in which it is stored\n* \\param[in] str_size the size of the output string\n* \\return #RCUTILS_RET_OK if successful (even if truncated), or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_time_point_value_as_seconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: usize,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Initialize the logging system using the specified allocator.\n**\n* Initialize the logging system only if it was not in an initialized state.\n*\n* If an invalid allocator is passed, the initialization will fail.\n* Otherwise, this function will still set the internal state to initialized\n* even if an error occurs, to avoid repeated failing initialization attempts\n* since this function is called automatically from logging macros.\n* To re-attempt initialization, call rcutils_logging_shutdown() before\n* re-calling this function.\n*\n* If multiple errors occur, the error code of the last error will be returned.\n*\n* The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set\n* the output format of messages logged to the console.\n* Available tokens are:\n*   - `file_name`, the full file name of the caller including the path\n*   - `function_name`, the function name of the caller\n*   - `line_number`, the line number of the caller\n*   - `message`, the message string after it has been formatted\n*   - `name`, the full logger name\n*   - `severity`, the name of the severity level, e.g. `INFO`\n*   - `time`, the timestamp of log message in floating point seconds\n*   - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds\n*\n* The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours\n* are used or not. Available values are:\n*  - `1`: Force using colours.\n*  - `0`: Don't use colours.\n* If it is unset, colours are used depending if the target stream is a terminal or not.\n* See `isatty` documentation.\n*\n* The format string can use these tokens by referencing them in curly brackets,\n* e.g. `\"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"`.\n* Any number of tokens can be used.\n* The limit of the format string is 2048 characters.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] allocator rcutils_allocator_t to be used.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, in which\n*   case initialization will fail, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output\n*   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in\n*   which case the default format will be used, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be initialized, in which case logger severity\n*   levels will not be configurable.\n*/"]
    pub fn rcutils_logging_initialize_with_allocator(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Initialize the logging system.\n**\n* Call rcutils_logging_initialize_with_allocator() using the default allocator.\n* This function is called automatically when using the logging macros.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output\n*   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in\n*   which case the default format will be used, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be initialized, in which case logger levels\n*   will not be configurable.\n*/"]
    pub fn rcutils_logging_initialize() -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Shutdown the logging system.\n**\n* Free the resources allocated for the logging system.\n* This puts the system into a state equivalent to being uninitialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be finalized.\n*/"]
    pub fn rcutils_logging_shutdown() -> rcutils_ret_t;
}
#[doc = " The structure identifying the caller location in the source code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_log_location_s {
    #[doc = " The name of the function containing the log call."]
    pub function_name: *const ::std::os::raw::c_char,
    #[doc = " The name of the source file containing the log call."]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " The line number containing the log call."]
    pub line_number: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcutils_log_location_s"][::std::mem::size_of::<rcutils_log_location_s>() - 24usize];
    ["Alignment of rcutils_log_location_s"]
        [::std::mem::align_of::<rcutils_log_location_s>() - 8usize];
    ["Offset of field: rcutils_log_location_s::function_name"]
        [::std::mem::offset_of!(rcutils_log_location_s, function_name) - 0usize];
    ["Offset of field: rcutils_log_location_s::file_name"]
        [::std::mem::offset_of!(rcutils_log_location_s, file_name) - 8usize];
    ["Offset of field: rcutils_log_location_s::line_number"]
        [::std::mem::offset_of!(rcutils_log_location_s, line_number) - 16usize];
};
impl Default for rcutils_log_location_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The structure identifying the caller location in the source code."]
pub type rcutils_log_location_t = rcutils_log_location_s;
unsafe extern "C" {
    #[doc = " Get a severity value from its string representation (e.g. DEBUG).\n**\n* String representation must match one of the values in\n* `g_rcutils_log_severity_names`, but is not case-sensitive.\n* Examples: UNSET, DEBUG, INFO, WARN, Error, fatal.\n*\n* \\param[in] severity_string String representation of the severity, must be a\n*   null terminated c string\n* \\param[in] allocator rcutils_allocator_t to be used\n* \\param[in,out] severity The severity level as a represented by the\n*   `RCUTILS_LOG_SEVERITY` enum\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT on invalid arguments, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID if unable to match\n*   string, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occured.\n*/"]
    pub fn rcutils_logging_severity_level_from_string(
        severity_string: *const ::std::os::raw::c_char,
        allocator: rcutils_allocator_t,
        severity: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
#[doc = " The function signature to log messages.\n**\n* \\param[in] location The location information about where the log came from\n* \\param[in] severity The severity of the log message expressed as an integer\n* \\param[in] name The name of the logger that this message came from\n* \\param[in] timestamp The time at which the log message was generated\n* \\param[in] format The list of arguments to insert into the formatted log message\n* \\param[in] args The variable argument list\n*/"]
pub type rcutils_logging_output_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rcutils_log_location_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: rcutils_time_point_value_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut va_list,
    ),
>;
unsafe extern "C" {
    #[doc = " Get the current output handler.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return The function pointer of the current output handler.\n*/"]
    pub fn rcutils_logging_get_output_handler() -> rcutils_logging_output_handler_t;
}
unsafe extern "C" {
    #[doc = " Set the current output handler.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] function The function pointer of the output handler to be used.\n*/"]
    pub fn rcutils_logging_set_output_handler(function: rcutils_logging_output_handler_t);
}
unsafe extern "C" {
    #[doc = " Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT\n**\n* A formatter that is meant to be used by an output handler to format a log message to the match\n* the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The location information about where the log came from\n* \\param[in] severity The severity of the log message expressed as an integer\n* \\param[in] name The name of the logger that this message came from\n* \\param[in] timestamp The time at which the log message was generated\n* \\param[in] msg The message being logged\n* \\param[out] logging_output An output buffer for the formatted message\n* \\return #RCUTILS_RET_OK if successful.\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation error occured\n*/"]
    pub fn rcutils_logging_format_message(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        msg: *const ::std::os::raw::c_char,
        logging_output: *mut rcutils_char_array_t,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Get the default level for loggers.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return The level.\n*/"]
    pub fn rcutils_logging_get_default_logger_level() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the default severity level for loggers.\n**\n* If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default\n* value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)\n* will be restored instead.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] level The level to be used.\n*/"]
    pub fn rcutils_logging_set_default_logger_level(level: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Get the severity level for a logger.\n**\n* This considers the severity level of the specifed logger only.\n* To get the effective level of a logger given the severity level of its\n* ancestors, see rcutils_logging_get_logger_effective_level().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string\n* \\return The level of the logger if it has been set, or\n* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or\n* \\return `g_rcutils_logging_default_logger_level` for an empty name, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred\n*/"]
    pub fn rcutils_logging_get_logger_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the level for a logger and its name length.\n**\n* Identical to rcutils_logging_get_logger_level() but without\n* relying on the logger name to be a null terminated c string.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger\n* \\param[in] name_length Logger name length\n* \\return The level of the logger if it has been set, or\n* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or\n* \\return `g_rcutils_logging_default_logger_level` for `name_length` of `0`, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred\n*/"]
    pub fn rcutils_logging_get_logger_leveln(
        name: *const ::std::os::raw::c_char,
        name_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the severity level for a logger.\n**\n* If an empty string is specified as the name, the\n* `g_rcutils_logging_default_logger_level` will be set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string.\n* \\param[in] level The level to be used.\n* \\return `RCUTILS_RET_OK` if successful, or\n* \\return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or\n* \\return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or\n* \\return `RCUTILS_RET_ERROR` if an unspecified error occured\n*/"]
    pub fn rcutils_logging_set_logger_level(
        name: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
unsafe extern "C" {
    #[doc = " Determine if a logger is enabled for a severity level.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string or NULL.\n* \\param[in] severity The severity level.\n*\n* \\return `true` if the logger is enabled for the level, or\n* \\return `false` otherwise.\n*/"]
    pub fn rcutils_logging_logger_is_enabled_for(
        name: *const ::std::os::raw::c_char,
        severity: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Determine the effective level for a logger.\n**\n* The effective level is determined as the severity level of\n* the logger if it is set, otherwise it is the first specified severity\n* level of the logger's ancestors, starting with its closest ancestor.\n* The ancestor hierarchy is signified by logger names being separated by dots:\n* a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are\n* ancestors of `x.y.z`, etc.\n* If the level has not been set for the logger nor any of its\n* ancestors, the default level is used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string.\n*\n* \\return The level, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred.\n*/"]
    pub fn rcutils_logging_get_logger_effective_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Log a message.\n**\n* The attributes of this function are also being influenced by the currently\n* set output handler.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, for formatted outputs <= 1023 characters\n*                    | Yes, for formatted outputs >= 1024 characters\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string or NULL\n* \\param[in] format The format string\n* \\param[in] ... The variable arguments\n*/"]
    pub fn rcutils_log(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " The default output handler outputs log messages to the standard streams.\n**\n* The messages with a severity level `DEBUG` and `INFO` are written to `stdout`.\n* The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written\n* to `stderr`.\n* The console output format of the logged message can be configured through\n* the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see\n* rcutils_logging_initialize_with_allocator() for details.\n* For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:\n* see rcutils_logging_initialize_with_allocator() for details.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes, if the underlying *printf functions are\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string\n* \\param[in] timestamp The timestamp for when the log message was made\n* \\param[in] format The format string\n* \\param[in] args The `va_list` used by the logger\n*/"]
    pub fn rcutils_logging_console_output_handler(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    );
}
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_INVALID: rmw_qos_policy_kind_e = 1;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DURABILITY: rmw_qos_policy_kind_e = 2;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DEADLINE: rmw_qos_policy_kind_e = 4;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIVELINESS: rmw_qos_policy_kind_e = 8;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_RELIABILITY: rmw_qos_policy_kind_e = 16;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_HISTORY: rmw_qos_policy_kind_e = 32;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIFESPAN: rmw_qos_policy_kind_e = 64;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DEPTH: rmw_qos_policy_kind_e = 128;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION: rmw_qos_policy_kind_e =
    256;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS:
    rmw_qos_policy_kind_e = 512;
#[doc = " QoS Policy Kinds"]
pub type rmw_qos_policy_kind_e = ::std::os::raw::c_uint;
#[doc = " QoS Policy Kinds"]
pub use self::rmw_qos_policy_kind_e as rmw_qos_policy_kind_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_incompatible_event_status_s {
    #[doc = " Total cumulative number of times the concerned subscription discovered a\n publisher for the same topic with an offered QoS that was incompatible\n with that requested by the subscription."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was read."]
    pub total_count_change: i32,
    #[doc = " The Qos Policy Kind of one of the policies that was found to be\n incompatible the last time an incompatibility was detected."]
    pub last_policy_kind: rmw_qos_policy_kind_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_qos_incompatible_event_status_s"]
        [::std::mem::size_of::<rmw_qos_incompatible_event_status_s>() - 12usize];
    ["Alignment of rmw_qos_incompatible_event_status_s"]
        [::std::mem::align_of::<rmw_qos_incompatible_event_status_s>() - 4usize];
    ["Offset of field: rmw_qos_incompatible_event_status_s::total_count"]
        [::std::mem::offset_of!(rmw_qos_incompatible_event_status_s, total_count) - 0usize];
    ["Offset of field: rmw_qos_incompatible_event_status_s::total_count_change"]
        [::std::mem::offset_of!(rmw_qos_incompatible_event_status_s, total_count_change) - 4usize];
    ["Offset of field: rmw_qos_incompatible_event_status_s::last_policy_kind"]
        [::std::mem::offset_of!(rmw_qos_incompatible_event_status_s, last_policy_kind) - 8usize];
};
impl Default for rmw_qos_incompatible_event_status_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rmw_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_s;
#[doc = " Event state for a subscription's 'RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE' events."]
pub type rmw_requested_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " Event state for a publisher's 'RMW_EVENT_OFFERED_QOS_INCOMPATIBLE' events."]
pub type rmw_offered_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " QoS Liveliness Changed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_liveliness_changed_status_s {
    #[doc = " The total number of currently active Publishers which publish to the topic associated with\n the Subscription.\n This count increases when a newly matched Publisher asserts its liveliness for the first time\n or when a Publisher previously considered to be not alive reasserts its liveliness.\n The count decreases when a Publisher considered alive fails to assert its liveliness and\n becomes not alive, whether because it was deleted normally or for some other reason."]
    pub alive_count: i32,
    #[doc = " The total count of current Publishers which publish to the topic associated with the\n Subscription that are no longer asserting their liveliness.\n This count increases when a Publisher considered alive fails to assert its liveliness and\n becomes not alive for some reason other than the normal deletion of that Publisher.\n It decreases when a previously not alive Publisher either reasserts its liveliness or is\n deleted normally."]
    pub not_alive_count: i32,
    #[doc = " The change in the alive_count since the status was last read."]
    pub alive_count_change: i32,
    #[doc = " The change in the not_alive_count since the status was last read."]
    pub not_alive_count_change: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_liveliness_changed_status_s"]
        [::std::mem::size_of::<rmw_liveliness_changed_status_s>() - 16usize];
    ["Alignment of rmw_liveliness_changed_status_s"]
        [::std::mem::align_of::<rmw_liveliness_changed_status_s>() - 4usize];
    ["Offset of field: rmw_liveliness_changed_status_s::alive_count"]
        [::std::mem::offset_of!(rmw_liveliness_changed_status_s, alive_count) - 0usize];
    ["Offset of field: rmw_liveliness_changed_status_s::not_alive_count"]
        [::std::mem::offset_of!(rmw_liveliness_changed_status_s, not_alive_count) - 4usize];
    ["Offset of field: rmw_liveliness_changed_status_s::alive_count_change"]
        [::std::mem::offset_of!(rmw_liveliness_changed_status_s, alive_count_change) - 8usize];
    ["Offset of field: rmw_liveliness_changed_status_s::not_alive_count_change"]
        [::std::mem::offset_of!(rmw_liveliness_changed_status_s, not_alive_count_change) - 12usize];
};
#[doc = " QoS Liveliness Changed information provided by a subscription."]
pub type rmw_liveliness_changed_status_t = rmw_liveliness_changed_status_s;
#[doc = " QoS Liveliness Lost information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_liveliness_lost_status_s {
    #[doc = " Lifetime cumulative number of times that a previously-alive Publisher became not alive due to\n a failure to actively signal its liveliness within its offered liveliness period.\n This count does not change when an already not alive Publisher simply remains not alive for\n another liveliness period."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_liveliness_lost_status_s"]
        [::std::mem::size_of::<rmw_liveliness_lost_status_s>() - 8usize];
    ["Alignment of rmw_liveliness_lost_status_s"]
        [::std::mem::align_of::<rmw_liveliness_lost_status_s>() - 4usize];
    ["Offset of field: rmw_liveliness_lost_status_s::total_count"]
        [::std::mem::offset_of!(rmw_liveliness_lost_status_s, total_count) - 0usize];
    ["Offset of field: rmw_liveliness_lost_status_s::total_count_change"]
        [::std::mem::offset_of!(rmw_liveliness_lost_status_s, total_count_change) - 4usize];
};
#[doc = " QoS Liveliness Lost information provided by a publisher."]
pub type rmw_liveliness_lost_status_t = rmw_liveliness_lost_status_s;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_message_lost_status_s {
    #[doc = " Total number of messages lost."]
    pub total_count: usize,
    #[doc = " Number of messages lost since last callback."]
    pub total_count_change: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_message_lost_status_s"]
        [::std::mem::size_of::<rmw_message_lost_status_s>() - 16usize];
    ["Alignment of rmw_message_lost_status_s"]
        [::std::mem::align_of::<rmw_message_lost_status_s>() - 8usize];
    ["Offset of field: rmw_message_lost_status_s::total_count"]
        [::std::mem::offset_of!(rmw_message_lost_status_s, total_count) - 0usize];
    ["Offset of field: rmw_message_lost_status_s::total_count_change"]
        [::std::mem::offset_of!(rmw_message_lost_status_s, total_count_change) - 8usize];
};
pub type rmw_message_lost_status_t = rmw_message_lost_status_s;
#[doc = " QoS Deadline Missed information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_offered_deadline_missed_status_s {
    #[doc = " Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed\n to provide data.\n Missed deadlines accumulate; that is, each deadline period the total_count will be incremented\n by one."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_offered_deadline_missed_status_s"]
        [::std::mem::size_of::<rmw_offered_deadline_missed_status_s>() - 8usize];
    ["Alignment of rmw_offered_deadline_missed_status_s"]
        [::std::mem::align_of::<rmw_offered_deadline_missed_status_s>() - 4usize];
    ["Offset of field: rmw_offered_deadline_missed_status_s::total_count"]
        [::std::mem::offset_of!(rmw_offered_deadline_missed_status_s, total_count) - 0usize];
    ["Offset of field: rmw_offered_deadline_missed_status_s::total_count_change"]
        [::std::mem::offset_of!(rmw_offered_deadline_missed_status_s, total_count_change) - 4usize];
};
#[doc = " QoS Deadline Missed information provided by a publisher."]
pub type rmw_offered_deadline_missed_status_t = rmw_offered_deadline_missed_status_s;
#[doc = " QoS Requested Deadline Missed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_requested_deadline_missed_status_s {
    #[doc = " Lifetime cumulative number of missed deadlines detected for any instance read by the\n subscription.\n Missed deadlines accumulate; that is, each deadline period the total_count will be incremented\n by one for each instance for which data was not received."]
    pub total_count: i32,
    #[doc = " The incremental number of deadlines detected since the status was read."]
    pub total_count_change: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_requested_deadline_missed_status_s"]
        [::std::mem::size_of::<rmw_requested_deadline_missed_status_s>() - 8usize];
    ["Alignment of rmw_requested_deadline_missed_status_s"]
        [::std::mem::align_of::<rmw_requested_deadline_missed_status_s>() - 4usize];
    ["Offset of field: rmw_requested_deadline_missed_status_s::total_count"]
        [::std::mem::offset_of!(rmw_requested_deadline_missed_status_s, total_count) - 0usize];
    ["Offset of field: rmw_requested_deadline_missed_status_s::total_count_change"][::std::mem::offset_of!(
        rmw_requested_deadline_missed_status_s,
        total_count_change
    ) - 4usize];
};
#[doc = " QoS Requested Deadline Missed information provided by a subscription."]
pub type rmw_requested_deadline_missed_status_t = rmw_requested_deadline_missed_status_s;
#[doc = " Uses ROS_LOCALHOST_ONLY environment variable."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DEFAULT: rmw_localhost_only_e = 0;
#[doc = " Forces using only localhost."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_ENABLED: rmw_localhost_only_e = 1;
#[doc = " Forces disabling localhost only."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DISABLED: rmw_localhost_only_e = 2;
#[doc = " Used to specify if the context can only communicate through localhost."]
pub type rmw_localhost_only_e = ::std::os::raw::c_uint;
#[doc = " Used to specify if the context can only communicate through localhost."]
pub use self::rmw_localhost_only_e as rmw_localhost_only_t;
#[doc = " Return code for rmw functions"]
pub type rmw_ret_t = i32;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_PERMISSIVE:
    rmw_security_enforcement_policy_e = 0;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_ENFORCE:
    rmw_security_enforcement_policy_e = 1;
pub type rmw_security_enforcement_policy_e = ::std::os::raw::c_uint;
pub use self::rmw_security_enforcement_policy_e as rmw_security_enforcement_policy_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_security_options_s {
    pub enforce_security: rmw_security_enforcement_policy_t,
    pub security_root_path: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_security_options_s"][::std::mem::size_of::<rmw_security_options_s>() - 16usize];
    ["Alignment of rmw_security_options_s"]
        [::std::mem::align_of::<rmw_security_options_s>() - 8usize];
    ["Offset of field: rmw_security_options_s::enforce_security"]
        [::std::mem::offset_of!(rmw_security_options_s, enforce_security) - 0usize];
    ["Offset of field: rmw_security_options_s::security_root_path"]
        [::std::mem::offset_of!(rmw_security_options_s, security_root_path) - 8usize];
};
impl Default for rmw_security_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rmw_security_options_t = rmw_security_options_s;
unsafe extern "C" {
    #[doc = " Get zero initialized security options."]
    pub fn rmw_get_zero_initialized_security_options() -> rmw_security_options_t;
}
unsafe extern "C" {
    #[doc = " Copy the given security options.\n**\n* \\param[in] src security options to be copied.\n* \\param[in] allocator allocator used when copying data to the new security options.\n* \\param[out] dst security options to be set.\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_copy(
        src: *const rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
        dst: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the security root path for the given security options.\n**\n* The provided `security_root_path` will be copied into allocated memory.\n*\n* \\param[in] security_root_path path to be set.\n* \\param[in] allocator allocator used to allocate the new path.\n* \\param[inout] security_options security options to be set.\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_set_root_path(
        security_root_path: *const ::std::os::raw::c_char,
        allocator: *const rcutils_allocator_t,
        security_options: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize the given security_options.\n**\n* \\param[in] security_options security options to be finalized.\n* \\param[in] allocator allocator used to deallocate the root path.\n* \\returns RMW_RET_ERROR, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_fini(
        security_options: *mut rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_impl_s {
    _unused: [u8; 0],
}
#[doc = " Implementation defined options structure used during rmw_init().\n**\n* This should be defined by the rmw implementation.\n*/"]
pub type rmw_init_options_impl_t = rmw_init_options_impl_s;
#[doc = " Options structure used during rmw_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_s {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle.\n**\n* This should be set by the caller of `rmw_init()` to a number that is\n* unique within this process.\n* It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.\n*/"]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " ROS domain id"]
    pub domain_id: usize,
    #[doc = " Security options"]
    pub security_options: rmw_security_options_t,
    #[doc = " Enable localhost only"]
    pub localhost_only: rmw_localhost_only_t,
    #[doc = " Enclave, name used to find security artifacts in a sros2 keystore."]
    pub enclave: *mut ::std::os::raw::c_char,
    #[doc = " Allocator used during internal allocation of init options, if needed."]
    pub allocator: rcutils_allocator_t,
    #[doc = " Implementation defined init options.\n** May be NULL if there are no implementation defined options. */"]
    pub impl_: *mut rmw_init_options_impl_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_init_options_s"][::std::mem::size_of::<rmw_init_options_s>() - 104usize];
    ["Alignment of rmw_init_options_s"][::std::mem::align_of::<rmw_init_options_s>() - 8usize];
    ["Offset of field: rmw_init_options_s::instance_id"]
        [::std::mem::offset_of!(rmw_init_options_s, instance_id) - 0usize];
    ["Offset of field: rmw_init_options_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_init_options_s, implementation_identifier) - 8usize];
    ["Offset of field: rmw_init_options_s::domain_id"]
        [::std::mem::offset_of!(rmw_init_options_s, domain_id) - 16usize];
    ["Offset of field: rmw_init_options_s::security_options"]
        [::std::mem::offset_of!(rmw_init_options_s, security_options) - 24usize];
    ["Offset of field: rmw_init_options_s::localhost_only"]
        [::std::mem::offset_of!(rmw_init_options_s, localhost_only) - 40usize];
    ["Offset of field: rmw_init_options_s::enclave"]
        [::std::mem::offset_of!(rmw_init_options_s, enclave) - 48usize];
    ["Offset of field: rmw_init_options_s::allocator"]
        [::std::mem::offset_of!(rmw_init_options_s, allocator) - 56usize];
    ["Offset of field: rmw_init_options_s::impl_"]
        [::std::mem::offset_of!(rmw_init_options_s, impl_) - 96usize];
};
impl Default for rmw_init_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options structure used during rmw_init()."]
pub type rmw_init_options_t = rmw_init_options_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized init options structure."]
    pub fn rmw_get_zero_initialized_init_options() -> rmw_init_options_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_impl_s {
    _unused: [u8; 0],
}
#[doc = " Implementation defined context structure returned by rmw_init().\n**\n* This should be defined by the rmw implementation.\n*/"]
pub type rmw_context_impl_t = rmw_context_impl_s;
#[doc = " Initialization context structure which is used to store init specific information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_s {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle."]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Options used to initialize the context."]
    pub options: rmw_init_options_t,
    #[doc = " Domain id that is being used."]
    pub actual_domain_id: usize,
    #[doc = " Implementation defined context information.\n** May be NULL if there is no implementation defined context information. */"]
    pub impl_: *mut rmw_context_impl_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_context_s"][::std::mem::size_of::<rmw_context_s>() - 136usize];
    ["Alignment of rmw_context_s"][::std::mem::align_of::<rmw_context_s>() - 8usize];
    ["Offset of field: rmw_context_s::instance_id"]
        [::std::mem::offset_of!(rmw_context_s, instance_id) - 0usize];
    ["Offset of field: rmw_context_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_context_s, implementation_identifier) - 8usize];
    ["Offset of field: rmw_context_s::options"]
        [::std::mem::offset_of!(rmw_context_s, options) - 16usize];
    ["Offset of field: rmw_context_s::actual_domain_id"]
        [::std::mem::offset_of!(rmw_context_s, actual_domain_id) - 120usize];
    ["Offset of field: rmw_context_s::impl_"]
        [::std::mem::offset_of!(rmw_context_s, impl_) - 128usize];
};
impl Default for rmw_context_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Initialization context structure which is used to store init specific information."]
pub type rmw_context_t = rmw_context_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized context structure."]
    pub fn rmw_get_zero_initialized_context() -> rmw_context_t;
}
#[doc = " \\brief Serialized message as a string of bytes.\n\n It includes (but it is not limited to) the following members:\n   \\e \\c buffer the reference to internal storage, as a pointer\n   \\e \\c buffer_length the size of stored contents, as an unsigned integer\n   \\e \\c buffer_capacity the capacity of internal storage, as an unsigned integer"]
pub type rmw_serialized_message_t = rcutils_uint8_array_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_content_filter_options_s {
    #[doc = " Specify the criteria to select the data samples of interest.\n\n It is similar to the WHERE part of an SQL clause."]
    pub filter_expression: *mut ::std::os::raw::c_char,
    #[doc = " Give values to the tokens placeholder parameters (i.e., \"%n\" tokens begin from 0) in the\n filter_expression. The number of supplied parameters must fit with the requested values.\n\n It can be NULL if there is no \"%n\" tokens placeholder in filter_expression.\n The maximum index number must be smaller than 100."]
    pub expression_parameters: rcutils_string_array_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_subscription_content_filter_options_s"]
        [::std::mem::size_of::<rmw_subscription_content_filter_options_s>() - 64usize];
    ["Alignment of rmw_subscription_content_filter_options_s"]
        [::std::mem::align_of::<rmw_subscription_content_filter_options_s>() - 8usize];
    ["Offset of field: rmw_subscription_content_filter_options_s::filter_expression"][::std::mem::offset_of!(
        rmw_subscription_content_filter_options_s,
        filter_expression
    ) - 0usize];
    ["Offset of field: rmw_subscription_content_filter_options_s::expression_parameters"][::std::mem::offset_of!(
        rmw_subscription_content_filter_options_s,
        expression_parameters
    )
        - 8usize];
};
impl Default for rmw_subscription_content_filter_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rmw_subscription_content_filter_options_t = rmw_subscription_content_filter_options_s;
unsafe extern "C" {
    #[doc = " Get zero initialized content filter options."]
    pub fn rmw_get_zero_initialized_content_filter_options()
    -> rmw_subscription_content_filter_options_t;
}
#[doc = " A struct representing a duration or relative time in RMW - does not encode an origin."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_time_s {
    #[doc = " Seconds component"]
    pub sec: u64,
    #[doc = " Nanoseconds component"]
    pub nsec: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_time_s"][::std::mem::size_of::<rmw_time_s>() - 16usize];
    ["Alignment of rmw_time_s"][::std::mem::align_of::<rmw_time_s>() - 8usize];
    ["Offset of field: rmw_time_s::sec"][::std::mem::offset_of!(rmw_time_s, sec) - 0usize];
    ["Offset of field: rmw_time_s::nsec"][::std::mem::offset_of!(rmw_time_s, nsec) - 8usize];
};
#[doc = " A struct representing a duration or relative time in RMW - does not encode an origin."]
pub type rmw_time_t = rmw_time_s;
pub type rmw_time_point_value_t = rcutils_time_point_value_t;
pub type rmw_duration_t = rcutils_duration_value_t;
#[doc = " Structure which encapsulates an rmw node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_node_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this node's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " A concise name of this rmw node for identification"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The namespace of this rmw node"]
    pub namespace_: *const ::std::os::raw::c_char,
    #[doc = " Context information about node's init specific information"]
    pub context: *mut rmw_context_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_node_s"][::std::mem::size_of::<rmw_node_s>() - 40usize];
    ["Alignment of rmw_node_s"][::std::mem::align_of::<rmw_node_s>() - 8usize];
    ["Offset of field: rmw_node_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_node_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_node_s::data"][::std::mem::offset_of!(rmw_node_s, data) - 8usize];
    ["Offset of field: rmw_node_s::name"][::std::mem::offset_of!(rmw_node_s, name) - 16usize];
    ["Offset of field: rmw_node_s::namespace_"]
        [::std::mem::offset_of!(rmw_node_s, namespace_) - 24usize];
    ["Offset of field: rmw_node_s::context"][::std::mem::offset_of!(rmw_node_s, context) - 32usize];
};
impl Default for rmw_node_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure which encapsulates an rmw node"]
pub type rmw_node_t = rmw_node_s;
#[doc = " Endpoint type has not yet been set"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_INVALID: rmw_endpoint_type_e = 0;
#[doc = " Creates and publishes messages to the ROS topic"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_PUBLISHER: rmw_endpoint_type_e = 1;
#[doc = " Listens for and receives messages from a topic"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_SUBSCRIPTION: rmw_endpoint_type_e = 2;
#[doc = " Endpoint enumeration type"]
pub type rmw_endpoint_type_e = ::std::os::raw::c_uint;
#[doc = " Endpoint enumeration type"]
pub use self::rmw_endpoint_type_e as rmw_endpoint_type_t;
#[doc = " Unique network flow endpoints not required"]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 0 ;
#[doc = " Unique network flow endpoins strictly required.\n Error if not provided by RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 1 ;
#[doc = " Unique network flow endpoints optionally required.\n No error if not provided RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 2 ;
#[doc = " Unique network flow endpoints requirement decided by system."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT : rmw_unique_network_flow_endpoints_requirement_e = 3 ;
#[doc = " Unique network flow endpoints requirement enumeration"]
pub type rmw_unique_network_flow_endpoints_requirement_e = ::std::os::raw::c_uint;
#[doc = " Unique network flow endpoints requirement enumeration"]
pub use self::rmw_unique_network_flow_endpoints_requirement_e as rmw_unique_network_flow_endpoints_requirement_t;
#[doc = " Options that can be used to configure the creation of a publisher in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_options_s {
    #[doc = " Used to pass rmw implementation specific resources during publisher creation.\n**\n* This field is type erased (rather than forward declared) because it will\n* usually be a non-owned reference to an language specific object, e.g.\n* C++ it may be a polymorphic class that only the rmw implementation can use.\n*\n* The resource pointed to here needs to outlive this options structure, and\n* any rmw_publisher objects that are created using it, as they copy this\n* structure and may use this payload throughout their lifetime.\n*/"]
    pub rmw_specific_publisher_payload: *mut ::std::os::raw::c_void,
    #[doc = " Require middleware to generate unique network flow endpoints.\n**\n* Unique network flow endpoints are required to differentiate the QoS provided by\n* networks for flows between publishers and subscribers in communicating\n* nodes.\n* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.\n*/"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_publisher_options_s"][::std::mem::size_of::<rmw_publisher_options_s>() - 16usize];
    ["Alignment of rmw_publisher_options_s"]
        [::std::mem::align_of::<rmw_publisher_options_s>() - 8usize];
    ["Offset of field: rmw_publisher_options_s::rmw_specific_publisher_payload"]
        [::std::mem::offset_of!(rmw_publisher_options_s, rmw_specific_publisher_payload) - 0usize];
    ["Offset of field: rmw_publisher_options_s::require_unique_network_flow_endpoints"][::std::mem::offset_of!(
        rmw_publisher_options_s,
        require_unique_network_flow_endpoints
    ) - 8usize];
};
impl Default for rmw_publisher_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options that can be used to configure the creation of a publisher in rmw."]
pub type rmw_publisher_options_t = rmw_publisher_options_s;
#[doc = " Structure which encapsulates an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this publisher's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of the ROS topic this publisher publishes to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Publisher options.\n**\n* The options structure passed to rmw_create_publisher() should be\n* assigned to this field by the rmw implementation.\n* The fields should not be modified after creation, but\n* the contents of the options structure may or may not be const, i.e.\n* shallow const-ness.\n* This field is not marked const to avoid any const casting during setup.\n*/"]
    pub options: rmw_publisher_options_t,
    #[doc = " Indicate whether this publisher supports loaning messages"]
    pub can_loan_messages: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_publisher_s"][::std::mem::size_of::<rmw_publisher_s>() - 48usize];
    ["Alignment of rmw_publisher_s"][::std::mem::align_of::<rmw_publisher_s>() - 8usize];
    ["Offset of field: rmw_publisher_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_publisher_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_publisher_s::data"]
        [::std::mem::offset_of!(rmw_publisher_s, data) - 8usize];
    ["Offset of field: rmw_publisher_s::topic_name"]
        [::std::mem::offset_of!(rmw_publisher_s, topic_name) - 16usize];
    ["Offset of field: rmw_publisher_s::options"]
        [::std::mem::offset_of!(rmw_publisher_s, options) - 24usize];
    ["Offset of field: rmw_publisher_s::can_loan_messages"]
        [::std::mem::offset_of!(rmw_publisher_s, can_loan_messages) - 40usize];
};
impl Default for rmw_publisher_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure which encapsulates an rmw publisher"]
pub type rmw_publisher_t = rmw_publisher_s;
#[doc = " Options that can be used to configure the creation of a subscription in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_options_s {
    #[doc = " Used to pass rmw implementation specific resources during subscription creation.\n**\n* All the same details and restrictions of this field in\n* rmw_publisher_options_t apply to this struct as well.\n*\n* \\sa rmw_publisher_options_t.rmw_specific_publisher_payload\n*/"]
    pub rmw_specific_subscription_payload: *mut ::std::os::raw::c_void,
    #[doc = " If true then the middleware should not deliver data from local publishers.\n**\n* This setting is most often used when data should only be received from\n* remote nodes, especially to avoid \"double delivery\" when both intra- and\n* inter- process communication is taking place.\n*\n* \\todo(wjwwood): nail this down when participant mapping is sorted out.\n*   See: https://github.com/ros2/design/pull/250\n*\n* The definition of local is somewhat vague at the moment.\n* Right now it means local to the node, and that definition works best, but\n* may become more complicated when/if participants map to a context instead.\n*/"]
    pub ignore_local_publications: bool,
    #[doc = " Require middleware to generate unique network flow endpoints.\n**\n* Unique network flow endpoints are required to differentiate the QoS provided by\n* networks for flows between publishers and subscribers in communicating\n* nodes.\n* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.\n*/"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
    #[doc = " Used to create a content filter options during subscription creation."]
    pub content_filter_options: *mut rmw_subscription_content_filter_options_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_subscription_options_s"]
        [::std::mem::size_of::<rmw_subscription_options_s>() - 24usize];
    ["Alignment of rmw_subscription_options_s"]
        [::std::mem::align_of::<rmw_subscription_options_s>() - 8usize];
    ["Offset of field: rmw_subscription_options_s::rmw_specific_subscription_payload"][::std::mem::offset_of!(
        rmw_subscription_options_s,
        rmw_specific_subscription_payload
    ) - 0usize];
    ["Offset of field: rmw_subscription_options_s::ignore_local_publications"]
        [::std::mem::offset_of!(rmw_subscription_options_s, ignore_local_publications) - 8usize];
    ["Offset of field: rmw_subscription_options_s::require_unique_network_flow_endpoints"][::std::mem::offset_of!(
        rmw_subscription_options_s,
        require_unique_network_flow_endpoints
    )
        - 12usize];
    ["Offset of field: rmw_subscription_options_s::content_filter_options"]
        [::std::mem::offset_of!(rmw_subscription_options_s, content_filter_options) - 16usize];
};
impl Default for rmw_subscription_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options that can be used to configure the creation of a subscription in rmw."]
pub type rmw_subscription_options_t = rmw_subscription_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this subscription"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Name of the ros topic this subscription listens to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Subscription options.\n**\n* The options structure passed to rmw_create_subscription() should be\n* assigned to this field by the rmw implementation.\n* The fields should not be modified after creation, but\n* the contents of the options structure may or may not be const, i.e.\n* shallow const-ness.\n* This field is not marked const to avoid any const casting during setup.\n*/"]
    pub options: rmw_subscription_options_t,
    #[doc = " Indicates whether this subscription can loan messages"]
    pub can_loan_messages: bool,
    #[doc = " Indicates whether content filtered topic of this subscription is enabled"]
    pub is_cft_enabled: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_subscription_s"][::std::mem::size_of::<rmw_subscription_s>() - 56usize];
    ["Alignment of rmw_subscription_s"][::std::mem::align_of::<rmw_subscription_s>() - 8usize];
    ["Offset of field: rmw_subscription_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_subscription_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_subscription_s::data"]
        [::std::mem::offset_of!(rmw_subscription_s, data) - 8usize];
    ["Offset of field: rmw_subscription_s::topic_name"]
        [::std::mem::offset_of!(rmw_subscription_s, topic_name) - 16usize];
    ["Offset of field: rmw_subscription_s::options"]
        [::std::mem::offset_of!(rmw_subscription_s, options) - 24usize];
    ["Offset of field: rmw_subscription_s::can_loan_messages"]
        [::std::mem::offset_of!(rmw_subscription_s, can_loan_messages) - 48usize];
    ["Offset of field: rmw_subscription_s::is_cft_enabled"]
        [::std::mem::offset_of!(rmw_subscription_s, is_cft_enabled) - 49usize];
};
impl Default for rmw_subscription_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rmw_subscription_t = rmw_subscription_s;
#[doc = " A handle to an rmw service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_service_s"][::std::mem::size_of::<rmw_service_s>() - 24usize];
    ["Alignment of rmw_service_s"][::std::mem::align_of::<rmw_service_s>() - 8usize];
    ["Offset of field: rmw_service_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_service_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_service_s::data"][::std::mem::offset_of!(rmw_service_s, data) - 8usize];
    ["Offset of field: rmw_service_s::service_name"]
        [::std::mem::offset_of!(rmw_service_s, service_name) - 16usize];
};
impl Default for rmw_service_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A handle to an rmw service"]
pub type rmw_service_t = rmw_service_s;
#[doc = " A handle to an rmw service client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_client_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service client"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_client_s"][::std::mem::size_of::<rmw_client_s>() - 24usize];
    ["Alignment of rmw_client_s"][::std::mem::align_of::<rmw_client_s>() - 8usize];
    ["Offset of field: rmw_client_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_client_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_client_s::data"][::std::mem::offset_of!(rmw_client_s, data) - 8usize];
    ["Offset of field: rmw_client_s::service_name"]
        [::std::mem::offset_of!(rmw_client_s, service_name) - 16usize];
};
impl Default for rmw_client_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A handle to an rmw service client"]
pub type rmw_client_t = rmw_client_s;
#[doc = " Handle for an rmw guard condition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_condition_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this guard condition"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " rmw context associated with this guard condition"]
    pub context: *mut rmw_context_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_guard_condition_s"][::std::mem::size_of::<rmw_guard_condition_s>() - 24usize];
    ["Alignment of rmw_guard_condition_s"]
        [::std::mem::align_of::<rmw_guard_condition_s>() - 8usize];
    ["Offset of field: rmw_guard_condition_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_guard_condition_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_guard_condition_s::data"]
        [::std::mem::offset_of!(rmw_guard_condition_s, data) - 8usize];
    ["Offset of field: rmw_guard_condition_s::context"]
        [::std::mem::offset_of!(rmw_guard_condition_s, context) - 16usize];
};
impl Default for rmw_guard_condition_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Handle for an rmw guard condition"]
pub type rmw_guard_condition_t = rmw_guard_condition_s;
#[doc = " Allocation of memory for an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_allocation_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_publisher_allocation_s"]
        [::std::mem::size_of::<rmw_publisher_allocation_s>() - 16usize];
    ["Alignment of rmw_publisher_allocation_s"]
        [::std::mem::align_of::<rmw_publisher_allocation_s>() - 8usize];
    ["Offset of field: rmw_publisher_allocation_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_publisher_allocation_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_publisher_allocation_s::data"]
        [::std::mem::offset_of!(rmw_publisher_allocation_s, data) - 8usize];
};
impl Default for rmw_publisher_allocation_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Allocation of memory for an rmw publisher"]
pub type rmw_publisher_allocation_t = rmw_publisher_allocation_s;
#[doc = " Allocation of memory for an rmw subscription"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_allocation_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_subscription_allocation_s"]
        [::std::mem::size_of::<rmw_subscription_allocation_s>() - 16usize];
    ["Alignment of rmw_subscription_allocation_s"]
        [::std::mem::align_of::<rmw_subscription_allocation_s>() - 8usize];
    ["Offset of field: rmw_subscription_allocation_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_subscription_allocation_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_subscription_allocation_s::data"]
        [::std::mem::offset_of!(rmw_subscription_allocation_s, data) - 8usize];
};
impl Default for rmw_subscription_allocation_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Allocation of memory for an rmw subscription"]
pub type rmw_subscription_allocation_t = rmw_subscription_allocation_s;
#[doc = " Array of subscriber handles.\n**\n* An array of void * pointers representing type-erased middleware-specific subscriptions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of subscriptions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscriptions_s {
    #[doc = " The number of subscribers represented by the array."]
    pub subscriber_count: usize,
    #[doc = " Pointer to an array of void * pointers of subscriptions."]
    pub subscribers: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_subscriptions_s"][::std::mem::size_of::<rmw_subscriptions_s>() - 16usize];
    ["Alignment of rmw_subscriptions_s"][::std::mem::align_of::<rmw_subscriptions_s>() - 8usize];
    ["Offset of field: rmw_subscriptions_s::subscriber_count"]
        [::std::mem::offset_of!(rmw_subscriptions_s, subscriber_count) - 0usize];
    ["Offset of field: rmw_subscriptions_s::subscribers"]
        [::std::mem::offset_of!(rmw_subscriptions_s, subscribers) - 8usize];
};
impl Default for rmw_subscriptions_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of subscriber handles.\n**\n* An array of void * pointers representing type-erased middleware-specific subscriptions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of subscriptions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_subscriptions_t = rmw_subscriptions_s;
#[doc = " Array of service handles.\n**\n* An array of void * pointers representing type-erased middleware-specific services.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of services represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_services_s {
    #[doc = " The number of services represented by the array."]
    pub service_count: usize,
    #[doc = " Pointer to an array of void * pointers of services."]
    pub services: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_services_s"][::std::mem::size_of::<rmw_services_s>() - 16usize];
    ["Alignment of rmw_services_s"][::std::mem::align_of::<rmw_services_s>() - 8usize];
    ["Offset of field: rmw_services_s::service_count"]
        [::std::mem::offset_of!(rmw_services_s, service_count) - 0usize];
    ["Offset of field: rmw_services_s::services"]
        [::std::mem::offset_of!(rmw_services_s, services) - 8usize];
};
impl Default for rmw_services_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of service handles.\n**\n* An array of void * pointers representing type-erased middleware-specific services.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of services represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_services_t = rmw_services_s;
#[doc = " Array of client handles.\n**\n* An array of void * pointers representing type-erased middleware-specific clients.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of clients represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_clients_s {
    #[doc = " The number of clients represented by the array."]
    pub client_count: usize,
    #[doc = " Pointer to an array of void * pointers of clients."]
    pub clients: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_clients_s"][::std::mem::size_of::<rmw_clients_s>() - 16usize];
    ["Alignment of rmw_clients_s"][::std::mem::align_of::<rmw_clients_s>() - 8usize];
    ["Offset of field: rmw_clients_s::client_count"]
        [::std::mem::offset_of!(rmw_clients_s, client_count) - 0usize];
    ["Offset of field: rmw_clients_s::clients"]
        [::std::mem::offset_of!(rmw_clients_s, clients) - 8usize];
};
impl Default for rmw_clients_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of client handles.\n**\n* An array of void * pointers representing type-erased middleware-specific clients.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of clients represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_clients_t = rmw_clients_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_events_s {
    #[doc = " The number of events represented by the array."]
    pub event_count: usize,
    #[doc = " Pointer to an array of void * pointers of events."]
    pub events: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_events_s"][::std::mem::size_of::<rmw_events_s>() - 16usize];
    ["Alignment of rmw_events_s"][::std::mem::align_of::<rmw_events_s>() - 8usize];
    ["Offset of field: rmw_events_s::event_count"]
        [::std::mem::offset_of!(rmw_events_s, event_count) - 0usize];
    ["Offset of field: rmw_events_s::events"]
        [::std::mem::offset_of!(rmw_events_s, events) - 8usize];
};
impl Default for rmw_events_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rmw_events_t = rmw_events_s;
#[doc = " Array of guard condition handles.\n**\n* An array of void * pointers representing type-erased middleware-specific guard conditions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of guard conditions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_conditions_s {
    #[doc = " The number of guard conditions represented by the array."]
    pub guard_condition_count: usize,
    #[doc = " Pointer to an array of void * pointers of guard conditions."]
    pub guard_conditions: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_guard_conditions_s"][::std::mem::size_of::<rmw_guard_conditions_s>() - 16usize];
    ["Alignment of rmw_guard_conditions_s"]
        [::std::mem::align_of::<rmw_guard_conditions_s>() - 8usize];
    ["Offset of field: rmw_guard_conditions_s::guard_condition_count"]
        [::std::mem::offset_of!(rmw_guard_conditions_s, guard_condition_count) - 0usize];
    ["Offset of field: rmw_guard_conditions_s::guard_conditions"]
        [::std::mem::offset_of!(rmw_guard_conditions_s, guard_conditions) - 8usize];
};
impl Default for rmw_guard_conditions_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of guard condition handles.\n**\n* An array of void * pointers representing type-erased middleware-specific guard conditions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of guard conditions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_guard_conditions_t = rmw_guard_conditions_s;
#[doc = " Container for guard conditions to be waited on"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_wait_set_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " The guard condition to be waited on"]
    pub guard_conditions: *mut rmw_guard_conditions_t,
    #[doc = " Type erased pointer to this wait set's data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_wait_set_s"][::std::mem::size_of::<rmw_wait_set_s>() - 24usize];
    ["Alignment of rmw_wait_set_s"][::std::mem::align_of::<rmw_wait_set_s>() - 8usize];
    ["Offset of field: rmw_wait_set_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_wait_set_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_wait_set_s::guard_conditions"]
        [::std::mem::offset_of!(rmw_wait_set_s, guard_conditions) - 8usize];
    ["Offset of field: rmw_wait_set_s::data"]
        [::std::mem::offset_of!(rmw_wait_set_s, data) - 16usize];
};
impl Default for rmw_wait_set_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Container for guard conditions to be waited on"]
pub type rmw_wait_set_t = rmw_wait_set_s;
#[doc = " An rmw service request identifier"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_request_id_s {
    #[doc = " The guid of the writer associated with this request"]
    pub writer_guid: [i8; 16usize],
    #[doc = " Sequence number of this service"]
    pub sequence_number: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_request_id_s"][::std::mem::size_of::<rmw_request_id_s>() - 24usize];
    ["Alignment of rmw_request_id_s"][::std::mem::align_of::<rmw_request_id_s>() - 8usize];
    ["Offset of field: rmw_request_id_s::writer_guid"]
        [::std::mem::offset_of!(rmw_request_id_s, writer_guid) - 0usize];
    ["Offset of field: rmw_request_id_s::sequence_number"]
        [::std::mem::offset_of!(rmw_request_id_s, sequence_number) - 16usize];
};
#[doc = " An rmw service request identifier"]
pub type rmw_request_id_t = rmw_request_id_s;
#[doc = " Meta-data for a service-related take."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmw_service_info_s {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub request_id: rmw_request_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_service_info_s"][::std::mem::size_of::<rmw_service_info_s>() - 40usize];
    ["Alignment of rmw_service_info_s"][::std::mem::align_of::<rmw_service_info_s>() - 8usize];
    ["Offset of field: rmw_service_info_s::source_timestamp"]
        [::std::mem::offset_of!(rmw_service_info_s, source_timestamp) - 0usize];
    ["Offset of field: rmw_service_info_s::received_timestamp"]
        [::std::mem::offset_of!(rmw_service_info_s, received_timestamp) - 8usize];
    ["Offset of field: rmw_service_info_s::request_id"]
        [::std::mem::offset_of!(rmw_service_info_s, request_id) - 16usize];
};
#[doc = " Meta-data for a service-related take."]
pub type rmw_service_info_t = rmw_service_info_s;
#[doc = " Implementation specific default"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT:
    rmw_qos_reliability_policy_e = 0;
#[doc = " Guarantee that samples are delivered, may retry multiple times."]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_RELIABLE:
    rmw_qos_reliability_policy_e = 1;
#[doc = " Attempt to deliver samples, but some may be lost if the network is not robust"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT:
    rmw_qos_reliability_policy_e = 2;
#[doc = " Reliability policy has not yet been set"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_UNKNOWN:
    rmw_qos_reliability_policy_e = 3;
pub type rmw_qos_reliability_policy_e = ::std::os::raw::c_uint;
pub use self::rmw_qos_reliability_policy_e as rmw_qos_reliability_policy_t;
#[doc = " Implementation default for history policy"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT: rmw_qos_history_policy_e =
    0;
#[doc = " Only store up to a maximum number of samples, dropping oldest once max is exceeded"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_LAST: rmw_qos_history_policy_e = 1;
#[doc = " Store all samples, subject to resource limits"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_ALL: rmw_qos_history_policy_e = 2;
#[doc = " History policy has not yet been set"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_UNKNOWN: rmw_qos_history_policy_e = 3;
#[doc = " QoS history enumerations describing how samples endure"]
pub type rmw_qos_history_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS history enumerations describing how samples endure"]
pub use self::rmw_qos_history_policy_e as rmw_qos_history_policy_t;
#[doc = " Impplementation specific default"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT:
    rmw_qos_durability_policy_e = 0;
#[doc = " The rmw publisher is responsible for persisting samples for late-joining subscribers"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL:
    rmw_qos_durability_policy_e = 1;
#[doc = " Samples are not persistent"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_VOLATILE:
    rmw_qos_durability_policy_e = 2;
#[doc = " Durability policy has not yet been set"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_UNKNOWN:
    rmw_qos_durability_policy_e = 3;
#[doc = " QoS durability enumerations describing how samples persist"]
pub type rmw_qos_durability_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS durability enumerations describing how samples persist"]
pub use self::rmw_qos_durability_policy_e as rmw_qos_durability_policy_t;
#[doc = " Implementation specific default"]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT:
    rmw_qos_liveliness_policy_e = 0;
#[doc = " The signal that establishes a Topic is alive comes from the ROS rmw layer."]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_AUTOMATIC:
    rmw_qos_liveliness_policy_e = 1;
#[doc = " Explicitly asserting node liveliness is required in this case.\n This option is deprecated, use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if your application\n requires to assert liveliness manually."]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE:
    rmw_qos_liveliness_policy_e = 2;
#[doc = " The signal that establishes a Topic is alive is at the Topic level. Only publishing a message\n on the Topic or an explicit signal from the application to assert liveliness on the Topic\n will mark the Topic as being alive."]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC:
    rmw_qos_liveliness_policy_e = 3;
#[doc = " Liveliness policy has not yet been set"]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_UNKNOWN:
    rmw_qos_liveliness_policy_e = 4;
#[doc = " QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.\n For a subscriber, these are its requirements for its topic's publishers."]
pub type rmw_qos_liveliness_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.\n For a subscriber, these are its requirements for its topic's publishers."]
pub use self::rmw_qos_liveliness_policy_e as rmw_qos_liveliness_policy_t;
#[doc = " ROS MiddleWare quality of service profile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_profile_s {
    pub history: rmw_qos_history_policy_e,
    #[doc = " Size of the message queue."]
    pub depth: usize,
    #[doc = " Reliabiilty QoS policy setting"]
    pub reliability: rmw_qos_reliability_policy_e,
    #[doc = " Durability QoS policy setting"]
    pub durability: rmw_qos_durability_policy_e,
    #[doc = " The period at which messages are expected to be sent/received\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation.\n*/"]
    pub deadline: rmw_time_s,
    #[doc = " The age at which messages are considered expired and no longer valid\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that messages do not expire.\n*/"]
    pub lifespan: rmw_time_s,
    #[doc = " Liveliness QoS policy setting"]
    pub liveliness: rmw_qos_liveliness_policy_e,
    #[doc = " The time within which the RMW node or publisher must show that it is alive\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that liveliness is not enforced.\n*/"]
    pub liveliness_lease_duration: rmw_time_s,
    #[doc = " If true, any ROS specific namespacing conventions will be circumvented.\n**\n* In the case of DDS and topics, for example, this means the typical\n* ROS specific prefix of `rt` would not be applied as described here:\n*\n*   http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix\n*\n* This might be useful when trying to directly connect a native DDS topic\n* with a ROS 2 topic.\n*/"]
    pub avoid_ros_namespace_conventions: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_qos_profile_s"][::std::mem::size_of::<rmw_qos_profile_s>() - 88usize];
    ["Alignment of rmw_qos_profile_s"][::std::mem::align_of::<rmw_qos_profile_s>() - 8usize];
    ["Offset of field: rmw_qos_profile_s::history"]
        [::std::mem::offset_of!(rmw_qos_profile_s, history) - 0usize];
    ["Offset of field: rmw_qos_profile_s::depth"]
        [::std::mem::offset_of!(rmw_qos_profile_s, depth) - 8usize];
    ["Offset of field: rmw_qos_profile_s::reliability"]
        [::std::mem::offset_of!(rmw_qos_profile_s, reliability) - 16usize];
    ["Offset of field: rmw_qos_profile_s::durability"]
        [::std::mem::offset_of!(rmw_qos_profile_s, durability) - 20usize];
    ["Offset of field: rmw_qos_profile_s::deadline"]
        [::std::mem::offset_of!(rmw_qos_profile_s, deadline) - 24usize];
    ["Offset of field: rmw_qos_profile_s::lifespan"]
        [::std::mem::offset_of!(rmw_qos_profile_s, lifespan) - 40usize];
    ["Offset of field: rmw_qos_profile_s::liveliness"]
        [::std::mem::offset_of!(rmw_qos_profile_s, liveliness) - 56usize];
    ["Offset of field: rmw_qos_profile_s::liveliness_lease_duration"]
        [::std::mem::offset_of!(rmw_qos_profile_s, liveliness_lease_duration) - 64usize];
    ["Offset of field: rmw_qos_profile_s::avoid_ros_namespace_conventions"]
        [::std::mem::offset_of!(rmw_qos_profile_s, avoid_ros_namespace_conventions) - 80usize];
};
impl Default for rmw_qos_profile_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ROS MiddleWare quality of service profile."]
pub type rmw_qos_profile_t = rmw_qos_profile_s;
#[doc = " ROS graph ID of the topic"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_gid_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Bype data Gid value"]
    pub data: [u8; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_gid_s"][::std::mem::size_of::<rmw_gid_s>() - 32usize];
    ["Alignment of rmw_gid_s"][::std::mem::align_of::<rmw_gid_s>() - 8usize];
    ["Offset of field: rmw_gid_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_gid_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_gid_s::data"][::std::mem::offset_of!(rmw_gid_s, data) - 8usize];
};
impl Default for rmw_gid_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ROS graph ID of the topic"]
pub type rmw_gid_t = rmw_gid_s;
#[doc = " Information describing an rmw message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_s {
    #[doc = " Time when the message was published by the publisher.\n**\n* The exact point at which the timestamp is taken is not specified, but\n* it should be taken consistently at the same point in the\n* publishing process each time.\n*/"]
    pub source_timestamp: rmw_time_point_value_t,
    #[doc = " Time when the message was received by the subscription.\n**\n* The exact point at which the timestamp is taken is not specified, but\n* it should be taken consistently at the same point in the\n* process of receiving a message each time.\n*/"]
    pub received_timestamp: rmw_time_point_value_t,
    #[doc = " Sequence number of the received message set by the publisher.\n**\n* This sequence number is set by the publisher and therefore uniquely identifies\n* a message when combined with the publisher GID.\n* For long running applications, the sequence number might wrap around at some point.\n*\n* If the rmw implementation doesn't support sequence numbers, its value will be\n* RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n*\n* Requirements:\n*\n* If `psn1` and `psn2` are the publication sequence numbers obtained by\n* calls to `rmw_take*()`, where `psn1` was obtained in a call that happened before `psn2` and both\n* sequence numbers are from the same publisher (i.e. also same publisher gid), then:\n*\n* - psn2 > psn1 (except in the case of a wrap around)\n* - `psn2 - psn1 - 1` is the number of messages the publisher sent in the middle of both\n*   received messages.\n*   Those might have already been taken by other `rmw_take*()` calls that happened in between or lost.\n*   `psn2 - psn1 - 1 = 0` if and only if the messages were sent by the publisher consecutively.\n*/"]
    pub publication_sequence_number: u64,
    #[doc = " Sequence number of the received message set by the subscription.\n**\n* This sequence number is set by the subscription regardless of which\n* publisher sent the message.\n* For long running applications, the sequence number might wrap around at some point.\n*\n* If the rmw implementation doesn't support sequence numbers, its value will be\n* RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n*\n* Requirements:\n*\n* If `rsn1` and `rsn2` are the reception sequence numbers obtained by\n* calls to `rmw_take*()`, where `rsn1` was obtained in a call that happened before `rsn2`, then:\n*\n* - rsn2 > rsn1 (except in the case of a wrap around)\n* - `rsn2 = rsn1 + 1` if and only if both `rmw_take*()` calls happened consecutively.\n*/"]
    pub reception_sequence_number: u64,
    #[doc = " Global unique identifier of the publisher that sent the message.\n**\n* The identifier uniquely identifies the publisher for the local context, but\n* it will not necessarily be the same identifier given in other contexts or processes\n* for the same publisher.\n* Therefore the identifier will uniquely identify the publisher within your application\n* but may disagree about the identifier for that publisher when compared to another\n* application.\n* Even with this limitation, when combined with the publisher sequence number it can\n* uniquely identify a message within your local context.\n* Publisher GIDs generated by the rmw implementation could collide at some point, in which\n* case it is not possible to distinguish which publisher sent the message.\n* The details of how GIDs are generated are rmw implementation dependent.\n*\n* It is possible the the rmw implementation needs to reuse a publisher GID,\n* due to running out of unique identifiers or some other constraint, in which case\n* the rmw implementation may document what happens in that case, but that\n* behavior is not defined here.\n* However, this should be avoided, if at all possible, by the rmw implementation,\n* and should be unlikely to happen in practice.\n*\n* \\todo In the future we want this to uniquely identify the publisher globally across\n*   contexts, processes, and machines.\n*/"]
    pub publisher_gid: rmw_gid_t,
    #[doc = " Whether this message is from intra_process communication or not"]
    pub from_intra_process: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_message_info_s"][::std::mem::size_of::<rmw_message_info_s>() - 72usize];
    ["Alignment of rmw_message_info_s"][::std::mem::align_of::<rmw_message_info_s>() - 8usize];
    ["Offset of field: rmw_message_info_s::source_timestamp"]
        [::std::mem::offset_of!(rmw_message_info_s, source_timestamp) - 0usize];
    ["Offset of field: rmw_message_info_s::received_timestamp"]
        [::std::mem::offset_of!(rmw_message_info_s, received_timestamp) - 8usize];
    ["Offset of field: rmw_message_info_s::publication_sequence_number"]
        [::std::mem::offset_of!(rmw_message_info_s, publication_sequence_number) - 16usize];
    ["Offset of field: rmw_message_info_s::reception_sequence_number"]
        [::std::mem::offset_of!(rmw_message_info_s, reception_sequence_number) - 24usize];
    ["Offset of field: rmw_message_info_s::publisher_gid"]
        [::std::mem::offset_of!(rmw_message_info_s, publisher_gid) - 32usize];
    ["Offset of field: rmw_message_info_s::from_intra_process"]
        [::std::mem::offset_of!(rmw_message_info_s, from_intra_process) - 64usize];
};
impl Default for rmw_message_info_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Information describing an rmw message"]
pub type rmw_message_info_t = rmw_message_info_s;
unsafe extern "C" {
    #[doc = " Get zero initialized mesage info."]
    pub fn rmw_get_zero_initialized_message_info() -> rmw_message_info_t;
}
pub const RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT: _bindgen_ty_1 = 0;
#[doc = " Default size of the rmw queue when history is set to RMW_QOS_POLICY_HISTORY_KEEP_LAST,\n 0 indicates it is currently not set"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Debug log severity, for pedantic messaging"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_DEBUG: rmw_log_severity_t = 10;
#[doc = " Informational log severity, for reporting expected but not overwhelming information"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_INFO: rmw_log_severity_t = 20;
#[doc = " Warning log severity, for reporting recoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_WARN: rmw_log_severity_t = 30;
#[doc = " Error log severity, for reporting uncoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_ERROR: rmw_log_severity_t = 40;
#[doc = " Fatal log severity, for reporting issue causing imminent shutdown"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_FATAL: rmw_log_severity_t = 50;
#[doc = " Type mapping of rcutils log severity types to rmw specific types."]
pub type rmw_log_severity_t = ::std::os::raw::c_uint;
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_CHANGED: rmw_event_type_e = 0;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_DEADLINE_MISSED: rmw_event_type_e = 1;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE: rmw_event_type_e = 2;
pub const rmw_event_type_e_RMW_EVENT_MESSAGE_LOST: rmw_event_type_e = 3;
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_LOST: rmw_event_type_e = 4;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_DEADLINE_MISSED: rmw_event_type_e = 5;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_QOS_INCOMPATIBLE: rmw_event_type_e = 6;
pub const rmw_event_type_e_RMW_EVENT_INVALID: rmw_event_type_e = 7;
#[doc = " Define publisher/subscription events"]
pub type rmw_event_type_e = ::std::os::raw::c_uint;
#[doc = " Define publisher/subscription events"]
pub use self::rmw_event_type_e as rmw_event_type_t;
#[doc = " Encapsulate the RMW event implementation, data, and type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_event_s {
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Data specific to this event type from either the publisher or subscriber."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The event type that occurred."]
    pub event_type: rmw_event_type_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_event_s"][::std::mem::size_of::<rmw_event_s>() - 24usize];
    ["Alignment of rmw_event_s"][::std::mem::align_of::<rmw_event_s>() - 8usize];
    ["Offset of field: rmw_event_s::implementation_identifier"]
        [::std::mem::offset_of!(rmw_event_s, implementation_identifier) - 0usize];
    ["Offset of field: rmw_event_s::data"][::std::mem::offset_of!(rmw_event_s, data) - 8usize];
    ["Offset of field: rmw_event_s::event_type"]
        [::std::mem::offset_of!(rmw_event_s, event_type) - 16usize];
};
impl Default for rmw_event_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encapsulate the RMW event implementation, data, and type."]
pub type rmw_event_t = rmw_event_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized event structure."]
    pub fn rmw_get_zero_initialized_event() -> rmw_event_t;
}
unsafe extern "C" {
    #[doc = " Finalize an rmw_event_t.\n**\n* \\param[in] event to finalize\n*/"]
    pub fn rmw_event_fini(event: *mut rmw_event_t) -> rmw_ret_t;
}
#[doc = " `rmw_message_info_t.publication_sequence_number` is filled correctly\n by the rmw implementation."]
pub const rmw_feature_e_RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER: rmw_feature_e = 0;
#[doc = " `rmw_message_info_t.reception_sequence_number` is filled correctly\n by the rmw implementation."]
pub const rmw_feature_e_RMW_FEATURE_MESSAGE_INFO_RECEPTION_SEQUENCE_NUMBER: rmw_feature_e = 1;
#[doc = " List of optional rmw features.\n**\n* Some of the features listed here might become mandatory in the feature, in which case all rmw\n* implementations should return `true`.\n*\n* There might be some optional features that are not listed here, but the goal is to have all of\n* them added.\n*/"]
pub type rmw_feature_e = ::std::os::raw::c_uint;
#[doc = " List of optional rmw features.\n**\n* Some of the features listed here might become mandatory in the feature, in which case all rmw\n* implementations should return `true`.\n*\n* There might be some optional features that are not listed here, but the goal is to have all of\n* them added.\n*/"]
pub use self::rmw_feature_e as rmw_feature_t;
pub const rmw_transport_protocol_e_RMW_TRANSPORT_PROTOCOL_UNKNOWN: rmw_transport_protocol_e = 0;
pub const rmw_transport_protocol_e_RMW_TRANSPORT_PROTOCOL_UDP: rmw_transport_protocol_e = 1;
pub const rmw_transport_protocol_e_RMW_TRANSPORT_PROTOCOL_TCP: rmw_transport_protocol_e = 2;
pub const rmw_transport_protocol_e_RMW_TRANSPORT_PROTOCOL_COUNT: rmw_transport_protocol_e = 3;
#[doc = " Transport protocol types"]
pub type rmw_transport_protocol_e = ::std::os::raw::c_uint;
#[doc = " Transport protocol types"]
pub use self::rmw_transport_protocol_e as rmw_transport_protocol_t;
pub const rmw_internet_protocol_e_RMW_INTERNET_PROTOCOL_UNKNOWN: rmw_internet_protocol_e = 0;
pub const rmw_internet_protocol_e_RMW_INTERNET_PROTOCOL_IPV4: rmw_internet_protocol_e = 1;
pub const rmw_internet_protocol_e_RMW_INTERNET_PROTOCOL_IPV6: rmw_internet_protocol_e = 2;
pub const rmw_internet_protocol_e_RMW_INTERNET_PROTOCOL_COUNT: rmw_internet_protocol_e = 3;
#[doc = " Internet protocol types"]
pub type rmw_internet_protocol_e = ::std::os::raw::c_uint;
#[doc = " Internet protocol types"]
pub use self::rmw_internet_protocol_e as rmw_internet_protocol_t;
#[doc = " Structure that describes network flow endpoint of a publisher or subscription"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_network_flow_endpoint_s {
    pub transport_protocol: rmw_transport_protocol_t,
    pub internet_protocol: rmw_internet_protocol_t,
    pub transport_port: u16,
    pub flow_label: u32,
    pub dscp: u8,
    pub internet_address: [::std::os::raw::c_char; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_network_flow_endpoint_s"]
        [::std::mem::size_of::<rmw_network_flow_endpoint_s>() - 68usize];
    ["Alignment of rmw_network_flow_endpoint_s"]
        [::std::mem::align_of::<rmw_network_flow_endpoint_s>() - 4usize];
    ["Offset of field: rmw_network_flow_endpoint_s::transport_protocol"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, transport_protocol) - 0usize];
    ["Offset of field: rmw_network_flow_endpoint_s::internet_protocol"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, internet_protocol) - 4usize];
    ["Offset of field: rmw_network_flow_endpoint_s::transport_port"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, transport_port) - 8usize];
    ["Offset of field: rmw_network_flow_endpoint_s::flow_label"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, flow_label) - 12usize];
    ["Offset of field: rmw_network_flow_endpoint_s::dscp"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, dscp) - 16usize];
    ["Offset of field: rmw_network_flow_endpoint_s::internet_address"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_s, internet_address) - 17usize];
};
impl Default for rmw_network_flow_endpoint_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure that describes network flow endpoint of a publisher or subscription"]
pub type rmw_network_flow_endpoint_t = rmw_network_flow_endpoint_s;
unsafe extern "C" {
    #[doc = " Return a rmw_network_flow_endpoint_t struct with zero-initialized members"]
    pub fn rmw_get_zero_initialized_network_flow_endpoint() -> rmw_network_flow_endpoint_t;
}
#[doc = " Structure to hold an arrary of network_flow_endpoint_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_network_flow_endpoint_array_s {
    #[doc = " Size of the array"]
    pub size: usize,
    #[doc = " Array of rmw_network_flow_endpoint_t"]
    pub network_flow_endpoint: *mut rmw_network_flow_endpoint_t,
    #[doc = " Allocator"]
    pub allocator: *mut rcutils_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_network_flow_endpoint_array_s"]
        [::std::mem::size_of::<rmw_network_flow_endpoint_array_s>() - 24usize];
    ["Alignment of rmw_network_flow_endpoint_array_s"]
        [::std::mem::align_of::<rmw_network_flow_endpoint_array_s>() - 8usize];
    ["Offset of field: rmw_network_flow_endpoint_array_s::size"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_array_s, size) - 0usize];
    ["Offset of field: rmw_network_flow_endpoint_array_s::network_flow_endpoint"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_array_s, network_flow_endpoint) - 8usize];
    ["Offset of field: rmw_network_flow_endpoint_array_s::allocator"]
        [::std::mem::offset_of!(rmw_network_flow_endpoint_array_s, allocator) - 16usize];
};
impl Default for rmw_network_flow_endpoint_array_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure to hold an arrary of network_flow_endpoint_t"]
pub type rmw_network_flow_endpoint_array_t = rmw_network_flow_endpoint_array_s;
unsafe extern "C" {
    #[doc = " Return a rmw_network_flow_endpoint_array_t instance with zero-initialized members"]
    pub fn rmw_get_zero_initialized_network_flow_endpoint_array()
    -> rmw_network_flow_endpoint_array_t;
}
#[doc = " Associative array of topic or service names and types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_names_and_types_s {
    #[doc = " Array of names"]
    pub names: rcutils_string_array_t,
    #[doc = " Dynamic array of arrays of type names, with the same length as `names`"]
    pub types: *mut rcutils_string_array_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_names_and_types_s"][::std::mem::size_of::<rmw_names_and_types_s>() - 64usize];
    ["Alignment of rmw_names_and_types_s"]
        [::std::mem::align_of::<rmw_names_and_types_s>() - 8usize];
    ["Offset of field: rmw_names_and_types_s::names"]
        [::std::mem::offset_of!(rmw_names_and_types_s, names) - 0usize];
    ["Offset of field: rmw_names_and_types_s::types"]
        [::std::mem::offset_of!(rmw_names_and_types_s, types) - 56usize];
};
impl Default for rmw_names_and_types_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Associative array of topic or service names and types."]
pub type rmw_names_and_types_t = rmw_names_and_types_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized array of names and types."]
    pub fn rmw_get_zero_initialized_names_and_types() -> rmw_names_and_types_t;
}
unsafe extern "C" {
    #[doc = " Check that the given `names_and_types` array is zero initialized.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Access to the array of names and types is read-only, but it is not synchronized.\n*   Concurrent `names_and_types` reads are safe, but concurrent reads and writes are not.\n*\n* \\param[in] names_and_types Array to be checked.\n* \\return RMW_RET_OK if array is zero initialized, RMW_RET_INVALID_ARGUMENT otherwise.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_check_zero(names_and_types: *mut rmw_names_and_types_t)
    -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Initialize an array of names and types.\n**\n* This function initializes the string array for the names and allocates space\n* for all the string arrays for the types according to the given size, but\n* it does not initialize the string array for each setup of types.\n* However, the string arrays for each set of types is zero initialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Initialization is a reentrant procedure, but:\n*   - Access to arrays of names and types is not synchronized.\n*     It is not safe to read or write `names_and_types` during initialization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] names_and_types Array to be initialized on success,\n*   but left unchanged on failure.\n* \\param[in] size Size of the array.\n* \\param[in] allocator Allocator to be used to populate `names_and_types`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is not\n*   a zero initialized array, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_init(
        names_and_types: *mut rmw_names_and_types_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize an array of names and types.\n**\n* This function deallocates the string array of names and the array of string arrays of types,\n* and zero initializes the given array.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will return\n* early, leaving the given array unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but access to arrays of names and types\n*   is not synchronized.\n*   It is not safe to read or write `names_and_types` during initialization.\n*\n* \\param[inout] names_and_types Array to be finalized.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_fini(names_and_types: *mut rmw_names_and_types_t) -> rmw_ret_t;
}
#[doc = " A data structure that encapsulates the node name, node namespace,\n topic_type, gid, and qos_profile of publishers and subscriptions\n for a topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_s {
    #[doc = " Name of the node"]
    pub node_name: *const ::std::os::raw::c_char,
    #[doc = " Namespace of the node"]
    pub node_namespace: *const ::std::os::raw::c_char,
    #[doc = " The associated topic type"]
    pub topic_type: *const ::std::os::raw::c_char,
    #[doc = " The endpoint type"]
    pub endpoint_type: rmw_endpoint_type_t,
    #[doc = " The GID of the endpoint"]
    pub endpoint_gid: [u8; 24usize],
    #[doc = " QoS profile of the endpoint"]
    pub qos_profile: rmw_qos_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_topic_endpoint_info_s"]
        [::std::mem::size_of::<rmw_topic_endpoint_info_s>() - 144usize];
    ["Alignment of rmw_topic_endpoint_info_s"]
        [::std::mem::align_of::<rmw_topic_endpoint_info_s>() - 8usize];
    ["Offset of field: rmw_topic_endpoint_info_s::node_name"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, node_name) - 0usize];
    ["Offset of field: rmw_topic_endpoint_info_s::node_namespace"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, node_namespace) - 8usize];
    ["Offset of field: rmw_topic_endpoint_info_s::topic_type"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, topic_type) - 16usize];
    ["Offset of field: rmw_topic_endpoint_info_s::endpoint_type"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, endpoint_type) - 24usize];
    ["Offset of field: rmw_topic_endpoint_info_s::endpoint_gid"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, endpoint_gid) - 28usize];
    ["Offset of field: rmw_topic_endpoint_info_s::qos_profile"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_s, qos_profile) - 56usize];
};
impl Default for rmw_topic_endpoint_info_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A data structure that encapsulates the node name, node namespace,\n topic_type, gid, and qos_profile of publishers and subscriptions\n for a topic."]
pub type rmw_topic_endpoint_info_t = rmw_topic_endpoint_info_s;
unsafe extern "C" {
    #[doc = " Return zero initialized topic endpoint info data structure.\n**\n* Endpoint type will be invalid.\n* Endpoint QoS profile will be the system default.\n*/"]
    pub fn rmw_get_zero_initialized_topic_endpoint_info() -> rmw_topic_endpoint_info_t;
}
unsafe extern "C" {
    #[doc = " Finalize a topic endpoint info data structure.\n**\n* This function deallocates all allocated members of the given data structure,\n* and then zero initializes it.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function\n* will return early, leaving the given data structure unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write `topic_endpoint` during finalization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] topic_endpoint_info Data structure to be finalized.\n* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_fini(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the topic type in the given topic endpoint info data structure.\n**\n* This functions allocates memory and copies the value of the `topic_type`\n* argument to set the data structure `topic_type` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `topic_type` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `topic_type` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `topic_type` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] topic_type Type name to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_type` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_topic_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        topic_type: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the node name in the given topic endpoint info data structure.\n**\n* This functions allocates memory and copies the value of the `node_name`\n* argument to set the data structure `node_name` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `node_name` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `node_name` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `node_name` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] node_name Node name to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_name` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_node_name(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_name: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the node namespace in the given topic endpoint info data structure.\n**\n* This functions allocates memory and copies the value of the `node_namespace`\n* argument to set the data structure `node_namespace` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `node_namespace` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `node_namespace` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `node_namespace` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] node_namespace Node namespace to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_namespace` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_node_namespace(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_namespace: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the endpoint type in the given topic endpoint info data structure.\n**\n* This functions assigns the value of the `type` argument to the data structure\n* `endpoint_type` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `endpoint_type` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] type Endpoint type to be set.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_endpoint_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        type_: rmw_endpoint_type_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the endpoint gid in the given topic endpoint info data structure.\n**\n* This functions copies the value of the `gid` argument to the data structure\n* `endpoint_gid` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `gid` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] gid Endpoint gid to be set.\n* \\param[in] size Size of the given `gid`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `size` is greater than RMW_GID_STORAGE_SIZE, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_gid(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        gid: *const u8,
        size: usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Set the endpoint QoS profile in the given topic endpoint info data structure.\n**\n* This functions assigns the value of the `qos_profile` argument to the data structure\n* `qos_profile` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `qos_profile` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] qos_profile QoS profile to be set.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `qos_profile` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_qos_profile(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        qos_profile: *const rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
#[doc = " Array of topic endpoint information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_array_s {
    #[doc = " Size of the array."]
    pub size: usize,
    #[doc = " Contiguous storage for topic endpoint information elements."]
    pub info_array: *mut rmw_topic_endpoint_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rmw_topic_endpoint_info_array_s"]
        [::std::mem::size_of::<rmw_topic_endpoint_info_array_s>() - 16usize];
    ["Alignment of rmw_topic_endpoint_info_array_s"]
        [::std::mem::align_of::<rmw_topic_endpoint_info_array_s>() - 8usize];
    ["Offset of field: rmw_topic_endpoint_info_array_s::size"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_array_s, size) - 0usize];
    ["Offset of field: rmw_topic_endpoint_info_array_s::info_array"]
        [::std::mem::offset_of!(rmw_topic_endpoint_info_array_s, info_array) - 8usize];
};
impl Default for rmw_topic_endpoint_info_array_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of topic endpoint information"]
pub type rmw_topic_endpoint_info_array_t = rmw_topic_endpoint_info_array_s;
unsafe extern "C" {
    #[doc = " Return a zero initialized array of topic endpoint information."]
    pub fn rmw_get_zero_initialized_topic_endpoint_info_array() -> rmw_topic_endpoint_info_array_t;
}
unsafe extern "C" {
    #[doc = " Check that the given `topic_endpoint_info_array` is zero initialized.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Access to the array of topic endpoint information is read-only, but it is not synchronized.\n*   Concurrent `topic_endpoint_info_array` reads are safe, but concurrent reads\n*   and writes are not.\n*\n* \\param[in] topic_endpoint_info_array Array to be checked.\n* \\returns `RMW_RET_OK` if array is zero initialized, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_ERROR` if `topic_endpoint_info_array` is not zero initialized.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_check_zero(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Initialize an array of topic endpoint information.\n**\n* This function allocates space to hold `size` topic endpoint information elements.\n* Both `info_array` and `size` members are updated accordingly.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Initialization is a reentrant procedure, but:\n*   - Access to the array of topic endpoint information is not synchronized.\n*     It is not safe to read or write `topic_endpoint_info_array` during initialization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] topic_endpoint_info_array Array to be initialized on success,\n*   but left unchanged on failure.\n* \\param[in] size Size of the array.\n* \\param[in] allocator Allocator to be used to populate `names_and_types`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is not\n*   a zero initialized array, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_init_with_size(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Finalize an array of topic endpoint information.\n**\n* This function deallocates the given array storage, and then zero initializes it.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will\n* return early, leaving the given array unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but:\n*   - Access to the array of topic endpoint information is not synchronized.\n*     It is not safe to read or write `topic_endpoint_info_array` during finalization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `allocator` must be the same used to initialize the given `topic_endpoint_info_array`.\n*\n* \\param[inout] topic_endpoint_info_array object to be finalized.\n* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info_array`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_fini(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Check that a string_array struct is zero initialized\n**\n* This sets error message and returns error code if array is not zero initialized\n*\n* \\param[in] array The string array to check\n* \\return RMW_RET_OK if array is zero initialized, otherwise RMW_RET_ERROR\n*/"]
    pub fn rmw_check_zero_rmw_string_array(array: *mut rcutils_string_array_t) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Determine if a node name is valid.\n**\n* Node names must follow these rules:\n*\n* - must not be an empty string\n* - must only contain alphanumeric characters and underscores (a-z|A-Z|0-9|_)\n* - must not start with a number\n*\n* If either the node name C string or validation_result pointer are null, then\n* `RMW_RET_INVALID_ARGUMENT` will be returned.\n* The node_name should be a valid, null-terminated C string.\n* The validation_result int pointer should point to valid memory so a result\n* can be stored in it as an output variable.\n* The invalid_index size_t pointer should either point NULL or to valid memory\n* so in the event of a validation error, the location in the input string can\n* be stored therein.\n* If NULL is passed in for invalid_index, it will be not be set.\n*\n* The invalid_index will not be assigned a value if the node name is valid.\n*\n* The int which validation_result points to will have a one of a few possible\n* results values (defined with macros) stored into it:\n*\n* - RMW_NODE_NAME_VALID\n* - RMW_NODE_NAME_INVALID_IS_EMPTY_STRING\n* - RMW_NODE_NAME_INVALID_CONTAINS_UNALLOWED_CHARACTERS\n* - RMW_NODE_NAME_INVALID_STARTS_WITH_NUMBER\n* - RMW_NODE_NAME_INVALID_TOO_LONG\n*\n* The result value can be converted to a description with the\n* rmw_node_name_validation_result_string() function.\n*\n* The `RMW_NODE_NAME_INVALID_TOO_LONG` is guaranteed to be checked last, such\n* that if you get that result, then you can assume all other checks succeeded.\n* This is done so that the length limit can be treated as a warning rather\n* than an error if desired.\n*\n* \\param[in] node_name node name to be validated\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index size_t index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_node_name(
        node_name: *const ::std::os::raw::c_char,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Deterimine if a given node name is valid.\n**\n* This is an overload with an extra parameter for the length of node_name.\n*\n* \\sa rmw_validate_node_name(const char *, int *, size_t *)\n*\n* \\param[in] node_name node name to be validated\n* \\param[in] node_name_length The number of characters in node_name.\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index size_t index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_node_name_with_size(
        node_name: *const ::std::os::raw::c_char,
        node_name_length: usize,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Determine if a given fully qualified topic name is valid.\n** Validity of a FQN for topic is determined based on rules defined here:\n*\n*   http://design.ros2.org/articles/topic_and_service_names.html\n*\n* Note that this function expects any URL suffixes as described in the above\n* document to have already been removed.\n*\n* If either the C string or validation_result pointer are null, then\n* `RMW_RET_INVALID_ARGUMENT` will be returned.\n* The topic_name should be a valid, null-terminated C string.\n* The validation_result int pointer should point to valid memory so a result\n* can be stored in it as an output variable.\n* The invalid_index size_t pointer should either point NULL or to valid memory\n* so in the event of a validation error, the location in the input string can\n* be stored therein.\n* If NULL is passed in for invalid_index, it will be not be set.\n*\n* The invalid_index will not be assigned a value if the topic is valid.\n*\n* The int which validation_result points to will have a one of a few possible\n* results values (defined with macros) stored into it:\n*\n* - RMW_TOPIC_VALID\n* - RMW_TOPIC_INVALID_IS_EMPTY_STRING\n* - RMW_TOPIC_INVALID_NOT_ABSOLUTE\n* - RMW_TOPIC_INVALID_ENDS_WITH_FORWARD_SLASH\n* - RMW_TOPIC_INVALID_CONTAINS_UNALLOWED_CHARACTERS\n* - RMW_TOPIC_INVALID_CONTAINS_REPEATED_FORWARD_SLASH\n* - RMW_TOPIC_INVALID_NAME_TOKEN_STARTS_WITH_NUMBER\n* - RMW_TOPIC_INVALID_TOO_LONG\n*\n* The result value can be converted to a description with the\n* rmw_full_topic_name_validation_result_string() function.\n*\n* The `RMW_TOPIC_INVALID_TOO_LONG` is guaranteed to be checked last, such\n* that if you get that result, then you can assume all other checks succeeded.\n* This is done so that the length limit can be treated as a warning rather\n* than an error if desired.\n*\n* \\param[in] topic_name topic name to be validated\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index size_t index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_full_topic_name(
        topic_name: *const ::std::os::raw::c_char,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Deterimine if a given topic name is valid.\n**\n* This is an overload with an extra parameter for the length of topic_name.\n*\n* \\sa rmw_validate_full_topic_name(const char *, int *, size_t *)\n*\n* \\param[in] topic_name topic name to be validated\n* \\param[in] topic_name_length The number of characters in topic_name.\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index size_t index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_full_topic_name_with_size(
        topic_name: *const ::std::os::raw::c_char,
        topic_name_length: usize,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Determine if a given namespace is valid.\n** Validity of a namespace is based on rules for a topic defined here:\n*\n*   http://design.ros2.org/articles/topic_and_service_names.html\n*\n* Note that this function expects that there are no URL suffixes as described\n* in the above document which can be used for topics and services.\n*\n* If either the C string or validation_result pointer are null, then\n* `RMW_RET_INVALID_ARGUMENT` will be returned.\n* The namespace_ should be a valid, null-terminated C string.\n* The validation_result int pointer should point to valid memory so a result\n* can be stored in it as an output variable.\n* The invalid_index size_t pointer should either point NULL or to valid memory\n* so in the event of a validation error, the location in the input string can\n* be stored therein.\n* If NULL is passed in for invalid_index, it will be not be set.\n*\n* The invalid_index will not be assigned a value if the namespace is valid.\n*\n* The int which validation_result points to will have a one of a few possible\n* results values (defined with macros) stored into it:\n*\n* - RMW_NAMESPACE_VALID\n* - RMW_NAMESPACE_INVALID_IS_EMPTY_STRING\n* - RMW_NAMESPACE_INVALID_NOT_ABSOLUTE\n* - RMW_NAMESPACE_INVALID_ENDS_WITH_FORWARD_SLASH\n* - RMW_NAMESPACE_INVALID_CONTAINS_UNALLOWED_CHARACTERS\n* - RMW_NAMESPACE_INVALID_CONTAINS_REPEATED_FORWARD_SLASH\n* - RMW_NAMESPACE_INVALID_NAME_TOKEN_STARTS_WITH_NUMBER\n* - RMW_NAMESPACE_INVALID_TOO_LONG\n*\n* The result value can be converted to a description with the\n* rmw_namespace_validation_result_string() function.\n*\n* The ``RMW_NAMESPACE_INVALID_ENDS_WITH_FORWARD_SLASH`` validation result does\n* not apply to ``\"/\"``, which is a valid namespace.\n*\n* The ``RMW_NAMESPACE_INVALID_TOO_LONG`` is guaranteed to be checked last,\n* such that if you get that result, then you can assume all other checks\n* succeeded.\n* This is done so that the length limit can be treated as a warning rather\n* than an error if desired.\n*\n* If a non RMW_RET_OK return value is returned, the RMW error message will be set\n*\n* \\param[in] namespace_ namespace to be validated\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_namespace(
        namespace_: *const ::std::os::raw::c_char,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
unsafe extern "C" {
    #[doc = " Deterimine if a given namespace is valid.\n**\n* This is an overload with an extra parameter for the length of namespace_.\n* If a non RMW_RET_OK return value is returned, the RMW error message will be set.\n*\n* \\sa rmw_validate_namespace(const char *, int *, size_t *)\n*\n* \\param[in] namespace_ namespace to be validated\n* \\param[in] namespace_length The number of characters in namespace_.\n* \\param[out] validation_result int in which the result of the check is stored\n* \\param[out] invalid_index index of the input string where an error occurred\n* \\returns `RMW_RET_OK` on successfully running the check, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` on invalid parameters, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n*/"]
    pub fn rmw_validate_namespace_with_size(
        namespace_: *const ::std::os::raw::c_char,
        namespace_length: usize,
        validation_result: *mut ::std::os::raw::c_int,
        invalid_index: *mut usize,
    ) -> rmw_ret_t;
}
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
#[doc = " Contains rosidl message type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_message_type_support_t {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the message type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the message type support handler function"]
    pub func: rosidl_message_typesupport_handle_function,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rosidl_message_type_support_t"]
        [::std::mem::size_of::<rosidl_message_type_support_t>() - 24usize];
    ["Alignment of rosidl_message_type_support_t"]
        [::std::mem::align_of::<rosidl_message_type_support_t>() - 8usize];
    ["Offset of field: rosidl_message_type_support_t::typesupport_identifier"]
        [::std::mem::offset_of!(rosidl_message_type_support_t, typesupport_identifier) - 0usize];
    ["Offset of field: rosidl_message_type_support_t::data"]
        [::std::mem::offset_of!(rosidl_message_type_support_t, data) - 8usize];
    ["Offset of field: rosidl_message_type_support_t::func"]
        [::std::mem::offset_of!(rosidl_message_type_support_t, func) - 16usize];
};
impl Default for rosidl_message_type_support_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
