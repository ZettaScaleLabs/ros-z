// This module re-exports auto-generated ROS message types
// The actual code is generated at build time and included from OUT_DIR

// Include the CDR-compatible generated code (serde-based)
include!(concat!(env!("OUT_DIR"), "/generated.rs"));

// Accurate size estimation for SHM serialization (trait + primitives)
// Implementations for ROS messages are auto-generated by ros-z-codegen
pub mod size_estimation;

// Re-export the namespaced modules for compatibility
pub use self::ros::*;

// Include the protobuf-compatible generated code (prost-based) if feature is enabled
#[cfg(feature = "protobuf")]
pub mod proto {
    //! Protobuf-serializable message types
    //!
    //! These types are compatible with `ros_z::msg::ProtobufSerdes` and can be used
    //! for protobuf serialization instead of CDR.
    //!
    //! # Example
    //! ```no_run
    //! use ros_z_msgs::proto::geometry_msgs::Vector3;
    //! use ros_z::msg::ProtobufSerdes;
    //!
    //! let vec = Vector3 { x: 1.0, y: 2.0, z: 3.0 };
    //! // Use with .with_serdes::<ProtobufSerdes<Vector3>>()
    //! ```

    include!(concat!(env!("OUT_DIR"), "/generated_proto.rs"));
}

// Include the protobuf type info implementations if feature is enabled
#[cfg(feature = "protobuf")]
include!(concat!(env!("OUT_DIR"), "/protobuf_type_info.rs"));

#[cfg(not(feature = "protobuf"))]
pub mod proto {
    //! Placeholder module when protobuf feature is not enabled
}

// Include generated Python bindings (complete module)
#[cfg(feature = "python_registry")]
include!(concat!(env!("OUT_DIR"), "/python_bindings.rs"));

// Re-export commonly used items from ros-z for convenience
pub use ros_z::{
    MessageTypeInfo,
    entity::{TypeHash, TypeInfo},
};
