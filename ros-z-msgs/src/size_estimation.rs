//! Accurate size estimation for ROS message serialization to SHM.
//!
//! This module provides the trait definition for size estimation. Implementations
//! are automatically generated by ros-z-codegen for all message types with dynamic
//! fields (Vec, String, ZBuf).
//!
//! # CDR Serialization Size Components
//!
//! | Component | Size | Notes |
//! |-----------|------|-------|
//! | CDR Header | 4 bytes | Always present |
//! | u8, i8, bool | 1 byte | No alignment |
//! | u16, i16 | 2 bytes | 2-byte aligned |
//! | u32, i32, f32 | 4 bytes | 4-byte aligned |
//! | u64, i64, f64 | 8 bytes | 8-byte aligned |
//! | String | 4 + len | Length prefix + UTF-8 bytes |
//! | Vec<T> | 4 + (len Ã— sizeof(T)) | Length prefix + elements |
//! | ZBuf | 4 + len | Length prefix + data |
//! | Padding | 0-7 bytes | For alignment (codegen adds conservative +16) |

/// Helper trait for messages that can provide accurate size estimates.
///
/// This is automatically implemented by ros-z-codegen for all message types with
/// dynamic fields to enable efficient zero-copy SHM serialization.
///
/// # Example
///
/// ```rust,ignore
/// use ros_z_msgs::sensor_msgs::PointCloud2;
/// use ros_z_msgs::size_estimation::SizeEstimation;
///
/// let cloud = create_pointcloud();
/// let estimated_size = cloud.estimated_cdr_size();
/// println!("Estimated CDR size: {} bytes", estimated_size);
/// ```
pub trait SizeEstimation {
    /// Calculate an accurate upper bound on the serialized CDR size.
    ///
    /// The estimate should be conservative (slightly larger than actual) to
    /// avoid buffer overflow, but not excessively large to avoid wasting SHM.
    ///
    /// This method returns the size WITHOUT the 4-byte CDR header. Use
    /// `estimated_serialized_size()` for the full size including header.
    fn estimated_cdr_size(&self) -> usize;
}

// Provide default implementations for primitive types that might be nested
impl SizeEstimation for bool {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        1
    }
}

impl SizeEstimation for u8 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        1
    }
}

impl SizeEstimation for i8 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        1
    }
}

impl SizeEstimation for u16 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        2
    }
}

impl SizeEstimation for i16 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        2
    }
}

impl SizeEstimation for u32 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        4
    }
}

impl SizeEstimation for i32 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        4
    }
}

impl SizeEstimation for f32 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        4
    }
}

impl SizeEstimation for u64 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        8
    }
}

impl SizeEstimation for i64 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        8
    }
}

impl SizeEstimation for f64 {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        8
    }
}

impl SizeEstimation for String {
    #[inline]
    fn estimated_cdr_size(&self) -> usize {
        4 + self.len()  // Length prefix + string data
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_primitive_size_estimation() {
        assert_eq!(true.estimated_cdr_size(), 1);
        assert_eq!(42u8.estimated_cdr_size(), 1);
        assert_eq!(42i8.estimated_cdr_size(), 1);
        assert_eq!(42u16.estimated_cdr_size(), 2);
        assert_eq!(42i16.estimated_cdr_size(), 2);
        assert_eq!(42u32.estimated_cdr_size(), 4);
        assert_eq!(42i32.estimated_cdr_size(), 4);
        assert_eq!(42f32.estimated_cdr_size(), 4);
        assert_eq!(42u64.estimated_cdr_size(), 8);
        assert_eq!(42i64.estimated_cdr_size(), 8);
        assert_eq!(42f64.estimated_cdr_size(), 8);
    }

    #[test]
    fn test_string_size_estimation() {
        let s = "hello".to_string();
        assert_eq!(s.estimated_cdr_size(), 4 + 5);  // Length prefix + 5 chars

        let empty = String::new();
        assert_eq!(empty.estimated_cdr_size(), 4);  // Just length prefix
    }
}
